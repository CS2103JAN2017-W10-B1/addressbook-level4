# A0147996E
###### /java/guitests/AddCommandTest.java
``` java
package guitests;

import static org.junit.Assert.assertTrue;
import static seedu.address.logic.commands.AddCommand.COMMAND_ADD;
import static seedu.address.logic.commands.AddCommand.MESSAGE_SUCCESS;
import static seedu.address.model.task.Event.MESSAGE_EVENT_CONSTRAINT;

import org.junit.Before;
import org.junit.Test;

import seedu.address.commons.core.Messages;
import seedu.address.logic.commands.AddCommand;
import seedu.address.logic.commands.CommandFormatter;
import seedu.address.testutil.TestEvent;
import seedu.address.testutil.TestRecurringTask;
import seedu.address.testutil.TestTask;
import seedu.address.testutil.TestUtil;

public class AddCommandTest extends TaskManagerGuiTest {
    private TestTask[] currentList = {};

    @Before
    public void setUp() {
        String initCommand = "clear";
        commandBox.runCommand(initCommand);
    }

    @Test
    public void add_addFloatingTask_addSuccess() {
        TestTask taskToAdd = td.shopping2;
        assertAddSuccess(taskToAdd, currentList);
        currentList = TestUtil.addTasksToList(currentList, taskToAdd);
    }

    @Test
    public void add_addInvalidDuplicate_duplicateFailure() {
         //add a task with all fields specified first
        TestTask taskToAdd = td.date;
        assertAddSuccess(taskToAdd, currentList);
        currentList = TestUtil.addTasksToList(currentList, taskToAdd);

        //duplicate task tests
        commandBox.runCommand(td.date.getAddCommand());
        assertResultMessage(AddCommand.MESSAGE_DUPLICATE_TASK);
        assertTrue(taskListPanel.isListMatching(currentList));
    }

    @Test
    public void add_addValidDuplicates_addSuccess() {
        TestTask taskToAdd = td.date2;
        assertAddSuccess(taskToAdd, currentList);
        currentList = TestUtil.addTasksToList(currentList, taskToAdd);

        taskToAdd = td.date3;
        assertAddSuccess(taskToAdd, currentList);
        currentList = TestUtil.addTasksToList(currentList, taskToAdd);

        taskToAdd = td.date4;
        assertAddSuccess(taskToAdd, currentList);
        currentList = TestUtil.addTasksToList(currentList, taskToAdd);
    }

    @Test
    public void add_addEventWithIllegalStartDate_addUnsuccess() {
        TestEvent eventToAdd = te.shopping;
        commandBox.runCommand(eventToAdd.getAddCommand());
        assertResultMessage(MESSAGE_EVENT_CONSTRAINT);
    }

    @Test
    public void add_addEventsWithSomeDuplicateFields_success() {
        TestEvent eventToAdd = te.date;
        assertAddSuccess(eventToAdd, currentList);
        currentList = (TestUtil.addTasksToList(currentList, eventToAdd));

        eventToAdd = te.date2;
        assertAddSuccess(eventToAdd, currentList);
        currentList = (TestUtil.addTasksToList(currentList, eventToAdd));

        eventToAdd = te.date3;
        assertAddSuccess(eventToAdd, currentList);
        currentList = (TestUtil.addTasksToList(currentList, eventToAdd));
    }

    @Test
    public void add_addRecurringTask_success() {
        TestRecurringTask recurringTaskToAdd = tr.homework;
        assertAddSuccess(recurringTaskToAdd, currentList);
        currentList = (TestUtil.addTasksToList(currentList, recurringTaskToAdd));

        recurringTaskToAdd = tr.homework2;
        assertAddSuccess(recurringTaskToAdd, currentList);
        currentList = (TestUtil.addTasksToList(currentList, recurringTaskToAdd));

        recurringTaskToAdd = tr.cs2103;
        assertAddSuccess(recurringTaskToAdd, currentList);
        currentList = (TestUtil.addTasksToList(currentList, recurringTaskToAdd));
    }

    @Test
    public void addCommand_invalidCommandFormat_failure () {
        commandBox.runCommand("addhomework");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);

        commandBox.runCommand("add p/important");
        assertResultMessage(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));

        commandBox.runCommand("add p/important homework");
        assertResultMessage(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
    }

    private void assertAddSuccess(TestTask taskToAdd, TestTask... currentList) {
        commandBox.runCommand(taskToAdd.getAddCommand());

        //AssertTrue if can navigate to the task card in current list view that matches the taskToAdd
        assertTrue(taskListPanel.navigateToTask(taskToAdd));

        //confirm the list now contains all previous tasks plus the new task
        TestTask[] expectedList = TestUtil.addTasksToList(currentList, taskToAdd);
        assertTrue(taskListPanel.isListMatching(expectedList));
        assertResultMessage(CommandFormatter.undoFormatter(
                String.format(MESSAGE_SUCCESS, taskToAdd.getName()), COMMAND_ADD));
    }
}
```
###### /java/guitests/ClearCommandTest.java
``` java
package guitests;

import static org.junit.Assert.assertTrue;
import static seedu.address.logic.commands.ClearCommand.COMMAND_CLEAR;
import static seedu.address.logic.commands.ClearCommand.MESSAGE_SUCCESS;

import org.junit.Test;

import seedu.address.logic.commands.CommandFormatter;

public class ClearCommandTest extends TaskManagerGuiTest {

    @Test
    public void clear_otherCommandsWorkAfterClear_success() {
        assertTrue(taskListPanel.isListMatching(td.getTypicalTasks()));
        assertClearCommandSuccess();

        commandBox.runCommand(td.gym.getAddCommand());
        assertTrue(taskListPanel.isListMatching(td.gym));

        commandBox.runCommand("delete 1");
        assertListSize(0);
    }

    private void assertClearCommandSuccess() {
        commandBox.runCommand("clear");
        assertListSize(0);
        assertResultMessage(CommandFormatter.undoFormatter(MESSAGE_SUCCESS, COMMAND_CLEAR));
    }
}
```
###### /java/guitests/DeleteCommandTest.java
``` java
package guitests;

import static org.junit.Assert.assertTrue;
import static seedu.address.commons.core.Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX;
import static seedu.address.logic.commands.DeleteCommand.COMMAND_DELETE;
import static seedu.address.logic.commands.DeleteCommand.MESSAGE_DELETE_TASK_SUCCESS;

import org.junit.Test;

import seedu.address.logic.commands.CommandFormatter;
import seedu.address.testutil.TestTask;
import seedu.address.testutil.TestUtil;

public class DeleteCommandTest extends TaskManagerGuiTest {

    private TestTask[] currentList = td.getTypicalTasks();

    @Test
    public void delete_validIndexGiven_deleteSucess() {
        int targetIndex = 1;
        System.out.println("啊 啊啊啊啊" + currentList[targetIndex - 1].toString());
        assertDeleteSuccess(targetIndex, currentList);
        currentList = TestUtil.removeTaskFromList(currentList, targetIndex);

        targetIndex = currentList.length;
        assertDeleteSuccess(targetIndex, currentList);
        currentList = TestUtil.removeTaskFromList(currentList, targetIndex);

        targetIndex = currentList.length / 2;
        assertDeleteSuccess(targetIndex, currentList);
        currentList = TestUtil.removeTaskFromList(currentList, targetIndex);
    }

    @Test
    public void delete_invalidIndexGiven_deleteFailure() {
        commandBox.runCommand("delete " + (currentList.length + 1));
        assertResultMessage(MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
    }

    /**
     * Runs the delete command to delete the task at specified index and confirms the result is correct.
     * @param targetIndex e.g. index 1 to delete the first task in the list,
     * @param currentList A copy of the current list of tasks (before deletion).
     */
    private void assertDeleteSuccess(int targetIndex, final TestTask[] currentList) {
        TestTask taskToDelete = currentList[targetIndex - 1]; // -1 as array uses zero indexing
        TestTask[] expectedRemainder = TestUtil.removeTaskFromList(currentList, targetIndex);

        commandBox.runCommand("delete " + targetIndex);
        assertTrue(taskListPanel.isListMatching(expectedRemainder));

        System.out.println("啊 啊啊啊啊" + currentList[targetIndex - 1].toString());
        assertResultMessage(CommandFormatter.undoFormatter(
                String.format(MESSAGE_DELETE_TASK_SUCCESS, taskToDelete), COMMAND_DELETE));
    }
}
```
###### /java/guitests/EditCommandTest.java
``` java
package guitests;

import static org.junit.Assert.assertTrue;
import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.model.task.Event.MESSAGE_EVENT_CONSTRAINT;

import org.junit.Test;

import seedu.address.commons.core.Messages;
import seedu.address.logic.commands.CommandFormatter;
import seedu.address.logic.commands.EditCommand;
import seedu.address.model.task.Name;
import seedu.address.model.task.Priority;
import seedu.address.model.task.TaskDate;
import seedu.address.model.task.TaskTime;
import seedu.address.testutil.TaskBuilder;
import seedu.address.testutil.TestEvent;
import seedu.address.testutil.TestRecurringTask;
import seedu.address.testutil.TestTask;
import seedu.address.testutil.TestUtil;

public class EditCommandTest extends TaskManagerGuiTest {

    private TestTask[] expectedTasksList = td.getTypicalTasks();

    @Test
    public void editTask_changeAllTaskFields_editSuccess() throws Exception {
        String detailsToEdit = "due/10/05/2017 dueT/16:00 #study d/Interesting module @I3 p/3 *u";
        int taskManagerIndex = 1;

        TestTask editedTask = new TaskBuilder().withName("assignment").withDate("10/05/2017").withTag("study")
                .withTime("16:00").withDescription("Interesting module").withFinished(false).
                withVenue("I3").withPriority("3").withFavorite(false).build();
        assertEditSuccess(taskManagerIndex, taskManagerIndex, detailsToEdit, editedTask);
    }

    @Test
    public void editTask_someFieldsSpecified_editSuccess() throws Exception {
        String detailsToEdit = "due/10/05/2017 #newlist dueT/16:35 d/Random description p/trivial";
        int taskManagerIndex = 2;
        TestTask editedTask = new TestTask(expectedTasksList[taskManagerIndex - 1]);

        editedTask.setDate("10/05/2017");
        editedTask.setTag("newlist");
        editedTask.setTime("16:35");
        editedTask.setDescription("Random description");
        editedTask.setPriority("trivial");
        assertEditSuccess(taskManagerIndex, taskManagerIndex, detailsToEdit, editedTask);
    }

    @Test
    public void editTask_toBecomeEvent_editSuccess() throws Exception {
        String detailsToEdit = "start/03/03/2017 startT/10:00";
        int taskManagerIndex = 1;
        TestEvent editedTask = te.assignment;
        editedTask.setStartDate("03/03/2017");
        editedTask.setStartTime("10:00");
        assertEditSuccess(taskManagerIndex, taskManagerIndex, detailsToEdit, editedTask);
    }

    @Test
    public void editTask_toBecomeRecurringTask_editSuccess() {
        String detailsToEdit = "f/weekly";
        int taskManagerIndex = 2;
        TestRecurringTask editedTask = tr.gym;
        assertEditSuccess(taskManagerIndex, taskManagerIndex, detailsToEdit, editedTask);
    }

    @Test
    public void editEvent_editDuplicateTask_editFailure() throws Exception {
        commandBox.runCommand("add testevent due/today start/today startT/23:59");
        commandBox.runCommand("add testevent2 due/today start/today startT/23:59");
        commandBox.runCommand("edit 2 n/testevent");
        assertResultMessage(EditCommand.MESSAGE_DUPLICATE_TASK);
    }

    @Test
    public void editEvent_toBecomeTask_editSuccess() throws Exception {
        expectedTasksList = TestUtil.addTasksToList(expectedTasksList, te.travel);
        TestEvent eventToAdd = te.travel;
        commandBox.runCommand(eventToAdd.getAddCommand());

        String detailsToEdit = "start/ startT/";
        int taskManagerIndex = 5;
        TestTask editedTask = new TestTask(expectedTasksList[taskManagerIndex - 1]);

        assertEditSuccess(taskManagerIndex, taskManagerIndex, detailsToEdit, editedTask);
    }

    @Test
    public void editEvent_withIllegalStartDate_editUnsuccess() {
        TestEvent eventToAdd = te.travel;
        commandBox.runCommand(eventToAdd.getAddCommand());

        String detailsToEdit = "start/01/02/2018";
        commandBox.runCommand("edit 5 " + detailsToEdit);
        assertResultMessage(MESSAGE_EVENT_CONSTRAINT);
    }
    @Test
    public void editEvent_withRecurrence_editFailure() {
        //TODO: after edit command is modified
    }

    @Test
    public void editRecurringTask_withStartDate_editFailure() {
        //TODO: after edit command is modified
    }

    @Test
    public void edit_invalidCommands_InvalidCommandFailure() {
        commandBox.runCommand("edit p/2");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
    }

    @Test
    public void edit_invalidTaskIndex_indexFailure() {
        commandBox.runCommand("edit 8 p/2");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
    }

    @Test
    public void edit_noFieldsSpecified_editUnsuccessful() {
        commandBox.runCommand("edit 1");
        assertResultMessage(EditCommand.MESSAGE_NOT_EDITED);
    }

    @Test
    public void edit_invalidValues_constraintViolations() {
        commandBox.runCommand("edit 1 n/*&");
        assertResultMessage(Name.MESSAGE_NAME_CONSTRAINTS_1);

        commandBox.runCommand("edit 1 due/1111");
        assertResultMessage(TaskDate.MESSAGE_DATE_CONSTRAINTS_1);

        commandBox.runCommand("edit 1 dueT/1200");
        assertResultMessage(TaskTime.MESSAGE_TIME_CONSTRAINTS);

        commandBox.runCommand("edit 1 p/5");
        assertResultMessage(Priority.MESSAGE_PRIORITY_CONSTRAINTS);
    }

    /**
     * Checks whether the edited Task has the correct updated details.
     *
     * @param filteredTaskListIndex index of Task to edit in filtered list
     * @param addressBookIndex index of Task to edit in the address book.
     *      Must refer to the same Task as {@code filteredTaskListIndex}
     * @param detailsToEdit details to edit the Task with as input to the edit command
     * @param editedTask the expected Task after editing the Task's details
     */
    private void assertEditSuccess(int filteredTaskListIndex, int taskManagerIndex,
                                    String detailsToEdit, TestTask editedTask) {
        commandBox.runCommand("edit " + filteredTaskListIndex + " " + detailsToEdit);

        // confirm the new task is added to the current list
        assertTrue(taskListPanel.navigateToTask(editedTask));

        // confirm the list now contains all previous Tasks plus the Task with updated details
        expectedTasksList = TestUtil.replaceTaskFromList(expectedTasksList, editedTask, taskManagerIndex - 1);
        assertTrue(taskListPanel.isListMatching(expectedTasksList));
        assertResultMessage(CommandFormatter.undoFormatter(
                String.format(EditCommand.MESSAGE_EDIT_TASK_SUCCESS, editedTask.getName()), "edit command"));
    }
}
```
###### /java/guitests/FindCommandTest.java
``` java
package guitests;

import static org.junit.Assert.assertTrue;

import org.junit.Test;

import seedu.address.commons.core.Messages;
import seedu.address.logic.commands.Command;
import seedu.address.testutil.TestTask;

public class FindCommandTest extends TaskManagerGuiTest {
    private TestTask[] currentList = td.getTypicalTasks();

    @Test
    public void find_inNonEmptyList_findSuccess() {
        assertFindResult("find all birthday");
        assertFindResult("find unfinished CS2103", td.cs2103);
        assertFindResult("find gym cs2103", td.gym, td.gym2, td.gym3, td.cs2103);
    }

    @Test
    public void find_deletedTask_findFailure() {
        int targetIndex = 1;
        String  keyWord = currentList[targetIndex - 1].getName().toString();
        commandBox.runCommand("delete " + targetIndex);
        assertFindResult("find " + keyWord);
    }

    @Test
    public void find_finishedTask_findUnsucess() {
        int targetIndex = 3;
        String  keyWord = currentList[targetIndex - 1].getName().toString();
        commandBox.runCommand("finish " + targetIndex);
        assertFindResult("find unfinished" + keyWord);
    }

    @Test
    public void findEmptyList() {
        commandBox.runCommand("clear");
        assertFindResult("find exercise");
    }

    @Test
    public void findInvalidCommandFail() {
        commandBox.runCommand("finds study");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

    private void assertFindResult(String command, TestTask... expectedHits) {
        commandBox.runCommand(command);
        assertListSize(expectedHits.length);
        assertResultMessage(String.format(Command.getMessageForTaskFoundShownSummary(expectedHits.length)));
        assertTrue(taskListPanel.isListMatching(expectedHits));
    }
}
```
###### /java/guitests/FinishCommandTest.java
``` java
package guitests;

import static org.junit.Assert.assertTrue;
import static seedu.address.logic.commands.FinishCommand.MESSAGE_FINISH_TASK_MARKED;
import static seedu.address.logic.commands.FinishCommand.MESSAGE_FINISH_TASK_SUCCESS;

import org.junit.Test;

import seedu.address.commons.core.Messages;
import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.testutil.TestTask;
import seedu.address.testutil.TestUtil;

public class FinishCommandTest extends TaskManagerGuiTest {
    private TestTask[] currentList = td.getTypicalTasks();

    @Test
    public void finish_recurringTask_finishSuccess() throws IllegalValueException {
        commandBox.runCommand("clear");
        TestTask[] currentList = {};
        int targetIndex = 1;
        currentList = TestUtil.addTasksToList(currentList, tr.gym);
        commandBox.runCommand(tr.gym.getAddCommand());

        currentList = TestUtil.addTasksToList(currentList, tr.cs2103);
        commandBox.runCommand(tr.cs2103.getAddCommand());

        commandBox.runCommand("finish " + targetIndex);
        currentList[targetIndex - 1].setDate("27/12/2017");

        targetIndex = 2;
        commandBox.runCommand("finish " + targetIndex);
        currentList[targetIndex - 1].setDate("01/03/2018");
        assertTrue(taskListPanel.isListMatching(currentList));
    }

    @Test
    public void finish_validIndexTest_finishSuccess() {
        int targetIndex = 1;
        assertFinishSuccess(targetIndex);
        targetIndex = currentList.length / 2;
        assertFinishSuccess(targetIndex);
        targetIndex = currentList.length;
        assertFinishSuccess(targetIndex);
    }

    @Test
    public void finish_alreadyFinishedTask_finishUnsuccess() {
        int targetIndex = 1;
        commandBox.runCommand("finish " + targetIndex);
        commandBox.runCommand("list all");
        commandBox.runCommand("finish " + targetIndex);
        assertResultMessage(MESSAGE_FINISH_TASK_MARKED);
    }

    @Test
    public void finish_outOfBoundInx_finishUnsuccess() {
        int maxIndex = currentList.length;
        commandBox.runCommand("finish " + (maxIndex + 1));
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
    }

    @Test
    public void finish_invalidCommandFormat_unknownCommand() {
        commandBox.runCommand("finishes 1");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

    @Test
    public void finish_validEvent_finishSuccess() {
        commandBox.runCommand("clear");
        TestTask[] currentList = {};
        int targetIndex = 1;
        currentList = TestUtil.addTasksToList(currentList, te.gym);
        commandBox.runCommand(te.gym.getAddCommand());

        currentList = TestUtil.addTasksToList(currentList, te.cs2103);
        commandBox.runCommand(te.cs2103.getAddCommand());

        commandBox.runCommand("finish " + targetIndex);
        currentList[targetIndex - 1].setFinished(true);

        targetIndex = 1;
        commandBox.runCommand("finish " + targetIndex);
        currentList[targetIndex - 1].setFinished(true);
        assertTrue(taskListPanel.isListMatching());

    }

    /**
     * Runs the finish command to finish the task at specified index and confirms the result is correct.
     * @param targetIndexOneIndexed e.g. index 1 to finish the first task in the list,
     * @param currentList A copy of the current unfinished list of tasks (before finish command).
     */
    private void assertFinishSuccess(int targetIndexOneIndexed) {
        TestTask taskToFinish = currentList[targetIndexOneIndexed - 1]; // -1 as array uses zero indexing
        currentList = TestUtil.removeTaskFromList(currentList, targetIndexOneIndexed);

        commandBox.runCommand("finish " + targetIndexOneIndexed);
        assertResultMessage(String.format(MESSAGE_FINISH_TASK_SUCCESS, taskToFinish.getName()));
        commandBox.runCommand("list");
        assertTrue(taskListPanel.isListMatching(currentList));
    }
}
```
###### /java/guitests/guihandles/TagCardHandle.java
``` java
package guitests.guihandles;

import guitests.GuiRobot;
import javafx.scene.Node;
import javafx.stage.Stage;
import seedu.address.model.tag.Tag;

/**
 * Provides a handle to a tag card in the tag list panel.
 */
public class TagCardHandle extends GuiHandle {
    private static final String NAME_FIELD_ID = "#name";

    private Node node;

    public TagCardHandle(GuiRobot guiRobot, Stage primaryStage, Node node) {
        super(guiRobot, primaryStage, null);
        this.node = node;
    }

    protected String getTextFromLabel(String fieldId) {
        return getTextFromLabel(fieldId, node);
    }

    public String getFullName() {
        return getTextFromLabel(NAME_FIELD_ID);
    }

    public boolean isSameTag(Tag tag) {
        return getFullName().equals(tag.getName());
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof TagCardHandle) {
            TagCardHandle handle = (TagCardHandle) obj;
            return getFullName().equals(handle.getFullName());
        }
        return super.equals(obj);
    }

    @Override
    public String toString() {
        return getFullName();
    }
}
```
###### /java/guitests/guihandles/TagListPanelHandle.java
``` java
package guitests.guihandles;

import static org.junit.Assert.assertTrue;

import java.util.List;
import java.util.Optional;
import java.util.Set;

import guitests.GuiRobot;
import javafx.geometry.Point2D;
import javafx.scene.Node;
import javafx.scene.control.ListView;
import javafx.stage.Stage;
import seedu.address.TestApp;
import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.tag.Tag;
import seedu.address.testutil.TestUtil;

/**
 * Provides a handle for the panel containing the tag list.
 */
public class TagListPanelHandle extends GuiHandle {

    public static final int NOT_FOUND = -1;
    public static final String CARD_PANE_ID = "#tagCardPane";

    private static final String TAG_LIST_VIEW_ID = "#tagListView";

    public TagListPanelHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    public List<Tag> getSelectedTags() {
        ListView<Tag> tagList = getListView();
        return tagList.getSelectionModel().getSelectedItems();
    }

    public ListView<Tag> getListView() {
        return getNode(TAG_LIST_VIEW_ID);
    }

    /**
     * Returns true if the list is showing the tag details correctly and in correct order.
     * @param tags A list of tag in the correct order.
     * @throws IllegalValueException
     * @throws IllegalArgumentException
     */
    public boolean isListMatching(Tag... tags) throws IllegalArgumentException, IllegalValueException {
        return this.isListMatching(0, tags);
    }

    /**
     * Returns true if the list is showing the tag details correctly and in correct order.
     * @param startPosition The starting position of the sub list.
     * @param tags A list of tag in the correct order.
     * @throws IllegalValueException
     */
    public boolean isListMatching(int startPosition, Tag... tags)
            throws IllegalArgumentException, IllegalValueException {
        if (tags.length + startPosition != getListView().getItems().size()) {
            throw new IllegalArgumentException("List size mismatched\n" +
                    "Expected " + (getListView().getItems().size() - 1) + " tags");
        }
        assertTrue(this.containsInOrder(startPosition, tags));
        for (int i = 0; i < tags.length; i++) {
            final int scrollTo = i + startPosition;
            guiRobot.interact(() -> getListView().scrollTo(scrollTo));
            guiRobot.sleep(200);
            if (!TestUtil.compareCardAndTag(getTagCardHandle(startPosition + i), tags[i])) {
                return false;
            }
        }
        return true;
    }

    /**
     * Clicks on the ListView.
     */
    public void clickOnListView() {
        Point2D point = TestUtil.getScreenMidPoint(getListView());
        guiRobot.clickOn(point.getX(), point.getY());
    }

    /**
     * Returns true if the {@code tags} appear as the sub list (in that order) at position {@code startPosition}.
     */
    public boolean containsInOrder(int startPosition, Tag... tags) {
        List<Tag> tagsInList = getListView().getItems();

        // Return false if the list in panel is too short to contain the given list
        if (startPosition + tags.length > tagsInList.size()) {
            return false;
        }

        // Return false if any of the tags doesn't match
        for (int i = 0; i < tags.length; i++) {
            if (!tagsInList.get(startPosition + i).getName().equals(tags[i].getName())) {
                return false;
            }
        }
        return true;
    }

    public TagCardHandle navigateToTag(String name) {
        guiRobot.sleep(500); //Allow a bit of time for the list to be updated
        final Optional<Tag> tag = getListView().getItems().stream()
                                                    .filter(p -> p.getName().equals(name))
                                                    .findAny();
        if (!tag.isPresent()) {
            throw new IllegalStateException("Name not found: " + name);
        }

        return navigateToTag(tag.get());
    }

    /**
     * Navigates the listview to display and select the tag.
     */
    public TagCardHandle navigateToTag(Tag tag) {
        int index = getTagIndex(tag);

        guiRobot.interact(() -> {
            getListView().scrollTo(index);
            guiRobot.sleep(150);
            getListView().getSelectionModel().select(index);
        });
        guiRobot.sleep(100);
        return getTagCardHandle(tag);
    }


    /**
     * Returns the position of the tag given, {@code NOT_FOUND} if not found in the list.
     */
    public int getTagIndex(Tag targetTag) {
        List<Tag> tagsInList = getListView().getItems();
        for (int i = 0; i < tagsInList.size(); i++) {
            if (tagsInList.get(i).getName().equals(targetTag.getName())) {
                return i;
            }
        }
        return NOT_FOUND;
    }

    /**
     * Gets a tag from the list by index
     */
    public Tag getTag(int index) {
        return getListView().getItems().get(index);
    }

    public TagCardHandle getTagCardHandle(int index) throws IllegalValueException {
        return getTagCardHandle(new Tag(getListView().getItems().get(index)));
    }

    public TagCardHandle getTagCardHandle(Tag tag) {
        Set<Node> nodes = getAllCardNodes();
        Optional<Node> tagCardNode = nodes.stream()
                .filter(n -> new TagCardHandle(guiRobot, primaryStage, n).isSameTag(tag))
                .findFirst();
        if (tagCardNode.isPresent()) {
            return new TagCardHandle(guiRobot, primaryStage, tagCardNode.get());
        } else {
            return null;
        }
    }

    protected Set<Node> getAllCardNodes() {
        return guiRobot.lookup(CARD_PANE_ID).queryAll();
    }

    public int getNumberOfTags() {
        return getListView().getItems().size();
    }
}
```
###### /java/guitests/guihandles/TaskCardHandle.java
``` java
package guitests.guihandles;

import guitests.GuiRobot;
import javafx.scene.Node;
import javafx.stage.Stage;
import seedu.address.model.task.ReadOnlyTask;

/**
 * Provides a handle to a task card in the task list panel.
 */
public class TaskCardHandle extends GuiHandle {
    private static final String NAME_FIELD_ID = "#name";
    private static final String DATE_FIELD_ID = "#date";
    private static final String TIME_FIELD_ID = "#time";
    private static final String START_DATE_FIELD_ID = "#startDate";
    private static final String START_TIME_FIELD_ID = "#startTime";
    private static final String DESCRIPTION_FIELD_ID = "#description";
    private static final String TAG_FIELD_ID = "#tag";
    private static final String VENUE_FIELD_ID = "#venue";
    private static final String PRIORITY_FIELD_ID = "#priority";
    private static final String FAVORITE_FIELD_ID = "#isFavorite";
    private static final String FINISHED_FIELD_ID = "#isFinished";

    private Node node;

    public TaskCardHandle(GuiRobot guiRobot, Stage primaryStage, Node node) {
        super(guiRobot, primaryStage, null);
        this.node = node;
    }

    protected String getTextFromLabel(String fieldId) {
        return getTextFromLabel(fieldId, node);
    }

    public String getName() {
        return getTextFromLabel(NAME_FIELD_ID);
    }

    public String getDate() {
        return getTextFromLabel(DATE_FIELD_ID);
    }

    public String getStartDate() {
        return getTextFromLabel(START_DATE_FIELD_ID);
    }

    public String getTime() {
        return getTextFromLabel(TIME_FIELD_ID);
    }

    public String getStartTime() {
        return getTextFromLabel(START_TIME_FIELD_ID);
    }

    public String getDescription() {
        return getTextFromLabel(DESCRIPTION_FIELD_ID);
    }

    public String getTag() {
        return getTextFromLabel(TAG_FIELD_ID);
    }

    public String getVenue() {
        return getTextFromLabel(VENUE_FIELD_ID);
    }

    public String getPriority() {
        return getTextFromLabel(PRIORITY_FIELD_ID);
    }

    public String isFavorite() {
        return getTextFromLabel(FAVORITE_FIELD_ID);
    }

    public String isFinished() {
        return getTextFromLabel(FINISHED_FIELD_ID);
    }

    public boolean isSameStateAs(ReadOnlyTask other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && other.getName().getDisplayText().equals(this.getName())
                && other.getDate().getDisplayText().equals(this.getDate())
                && other.getTime().getDisplayText().equals(this.getTime())
                && other.getTag().getDisplayText().equals(this.getTag())); // state checks here onwards
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof TaskCardHandle) {
            TaskCardHandle handle = (TaskCardHandle) obj;
            return getName().equals(handle.getName())
                    && getDate().equals(handle.getDate())
                    && getTime().equals(handle.getTime())
                    && getDescription().equals(handle.getDescription())
                    && getTag().equals(handle.getTag())
                    && getVenue().equals(handle.getVenue())
                    && getPriority().equals(handle.getPriority())
                    && isFavorite().equals(handle.isFavorite())
                    && isFinished().equals(handle.isFinished());
        }
        return super.equals(obj);
    }

    @Override
    public String toString() {
        return getName();
    }
}
```
###### /java/guitests/guihandles/TaskListPanelHandle.java
``` java
package guitests.guihandles;

import static org.junit.Assert.assertTrue;

import java.util.List;
import java.util.Optional;
import java.util.Set;

import guitests.GuiRobot;
import javafx.geometry.Point2D;
import javafx.scene.Node;
import javafx.scene.control.ListView;
import javafx.stage.Stage;
import seedu.address.TestApp;
import seedu.address.model.task.ReadOnlyTask;
import seedu.address.model.task.Task;
import seedu.address.testutil.TestTask;
import seedu.address.testutil.TestUtil;

/**
 * Provides a handle for the panel containing the task list.
 */
public class TaskListPanelHandle extends GuiHandle {

    public static final int NOT_FOUND = -1;
    public static final String CARD_PANE_ID = "#taskCardPane";

    private static final String TASK_LIST_VIEW_ID = "#taskListView";

    public TaskListPanelHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    public List<ReadOnlyTask> getSelectedTasks() {
        ListView<ReadOnlyTask> taskList = getListView();
        return taskList.getSelectionModel().getSelectedItems();
    }

    public ListView<ReadOnlyTask> getListView() {
        return getNode(TASK_LIST_VIEW_ID);
    }

    /**
     * Returns true if the list is showing the task details correctly and in correct order.
     * @param tasks A list of task in the correct order.
     */
    public boolean isListMatching(ReadOnlyTask... tasks) {
        return this.isListMatching(0, tasks);
    }

    /**
     * Returns true if the list is showing the task details correctly and in correct order.
     * @param startPosition The starting position of the sub list.
     * @param tasks A list of task in the correct order.
     */
    public boolean isListMatching(int startPosition, ReadOnlyTask... tasks) throws IllegalArgumentException {
        if (tasks.length + startPosition != getListView().getItems().size()) {
            throw new IllegalArgumentException("List size mismatched\n" +
                    (tasks.length + startPosition) + " compared to " +  getListView().getItems().size());
        }
        //The order of the task list should be ordered first by date then by priority
        assertTrue(this.containsInOrder(startPosition, tasks));
        for (int i = 0; i < tasks.length; i++) {
            final int scrollTo = i + startPosition;
            guiRobot.interact(() -> getListView().scrollTo(scrollTo));
            guiRobot.sleep(200);
            if (!TestUtil.compareCardAndTask(getTaskCardHandle(startPosition + i), tasks[i])) {
                return false;
            }
        }
        return true;
    }

    /**
     * Clicks on the ListView.
     */
    public void clickOnListView() {
        Point2D point = TestUtil.getScreenMidPoint(getListView());
        guiRobot.clickOn(point.getX(), point.getY());
    }

    /**
     * Returns true if the {@code tasks} appear as the sub list (in that order) at position {@code startPosition}.
     */
    public boolean containsInOrder(int startPosition, ReadOnlyTask... tasks) {
        List<ReadOnlyTask> tasksInList = getListView().getItems();

        // Return false if the list in panel is too short to contain the given list
        if (startPosition + tasks.length > tasksInList.size()) {
            System.out.println("List size does not match\n");
            return false;
        }

        // Return false if any of the tasks doesn't match
        for (int i = 0; i < tasks.length; i++) {
            if (!tasksInList.get(startPosition + i).isSameCardAs(tasks[i])) {
                System.out.println(tasksInList.get(startPosition + i).getAsText()
                        + " compared to " + tasks[i].getAsText());
                return false;
            }
        }
        return true;
    }

    /**
     * Navigates the listview to display and select the task.
     */
    public boolean navigateToTask(TestTask testTask) {
        guiRobot.sleep(500); //Allow a bit of time for the list to be updated

        List<ReadOnlyTask> tasksInList = getListView().getItems();
        for (int i = 0; i < tasksInList.size(); i++) {
            if (tasksInList.get(i).isSameCardAs(testTask)) {
                //System.out.println(tasksInList.get(i).toString() + " compared to " + testTask.getAsText());
                //System.out.println("Card is found!\n");
                return true;
            }
        } return false;
    }

    /**
     * Returns the position of the task given, {@code NOT_FOUND} if not found in the list.
     */
    public int getTaskIndex(ReadOnlyTask targetTask) {
        List<ReadOnlyTask> tasksInList = getListView().getItems();
        for (int i = 0; i < tasksInList.size(); i++) {
            if (tasksInList.get(i).isSameCardAs(targetTask)) {
                return i;
            }
        }
        return NOT_FOUND;
    }

    /**
     * Gets a task from the list by index
     */
    public ReadOnlyTask getTask(int index) {
        return getListView().getItems().get(index);
    }

    public TaskCardHandle getTaskCardHandle(int index) {
        return getTaskCardHandle(new Task(getListView().getItems().get(index)));
    }

    public TaskCardHandle getTaskCardHandle(ReadOnlyTask task) {
        Set<Node> nodes = getAllCardNodes();
        Optional<Node> taskCardNode = nodes.stream()
                .filter(n -> new TaskCardHandle(guiRobot, primaryStage, n).isSameStateAs(task))
                .findAny();
        if (taskCardNode.isPresent()) {
            return new TaskCardHandle(guiRobot, primaryStage, taskCardNode.get());
        } else {
            return null;
        }
    }

    protected Set<Node> getAllCardNodes() {
        return guiRobot.lookup(CARD_PANE_ID).queryAll();
    }

    public int getNumberOfTasks() {
        return getListView().getItems().size();
    }
}
```
###### /java/guitests/HelpCommandTest.java
``` java
package guitests;

import org.junit.Test;

import seedu.address.logic.commands.AddCommand;
import seedu.address.logic.commands.DeleteCommand;
import seedu.address.logic.commands.EditCommand;
import seedu.address.logic.commands.FindCommand;
import seedu.address.logic.commands.FinishCommand;
import seedu.address.logic.commands.ListCommand;
import seedu.address.logic.commands.LoadCommand;
import seedu.address.logic.commands.ScrollToCommand;
import seedu.address.logic.commands.ViewNextCommand;
import seedu.address.logic.commands.ViewOnCommand;

public class HelpCommandTest extends TaskManagerGuiTest {
    @Test
    public void help_getSpecificHelpMessage_success() {
        assertHelpCommandSuccess("add");
        assertHelpCommandSuccess("delete");
        assertHelpCommandSuccess("edit");
        assertHelpCommandSuccess("find");
        assertHelpCommandSuccess("finish");
        assertHelpCommandSuccess("list");
        assertHelpCommandSuccess("load");
        assertHelpCommandSuccess("scroll");
        assertHelpCommandSuccess("view");
    }
    private void assertHelpCommandSuccess(String commandWord) {
        commandBox.runCommand("help " + commandWord);
        if (commandWord.equalsIgnoreCase("add")) {
            assertResultMessage(AddCommand.MESSAGE_USAGE);
        } else if (commandWord.equalsIgnoreCase("delete")) {
            assertResultMessage(DeleteCommand.MESSAGE_USAGE);
        } else if (commandWord.equalsIgnoreCase("edit")) {
            assertResultMessage(EditCommand.MESSAGE_USAGE);
        } else if (commandWord.equalsIgnoreCase("find")) {
            assertResultMessage(FindCommand.MESSAGE_USAGE);
        } else if (commandWord.equalsIgnoreCase("finish")) {
            assertResultMessage(FinishCommand.MESSAGE_USAGE);
        } else if (commandWord.equalsIgnoreCase("list")) {
            assertResultMessage(ListCommand.MESSAGE_USAGE);
        } else if (commandWord.equalsIgnoreCase("load")) {
            assertResultMessage(LoadCommand.MESSAGE_USAGE);
        } else if (commandWord.equalsIgnoreCase("scroll")) {
            assertResultMessage(ScrollToCommand.MESSAGE_USAGE);
        } else if (commandWord.equalsIgnoreCase("view")) {
            assertResultMessage(ViewNextCommand.MESSAGE_USAGE + "\n" +  ViewOnCommand.MESSAGE_USAGE);
        }
    }
}
```
###### /java/guitests/ListCommandTest.java
``` java
package guitests;

import static org.junit.Assert.assertTrue;
import static seedu.address.logic.commands.ListCommand.MESSAGE_LIST_DOES_NOT_EXIST;

import org.junit.Test;

import seedu.address.commons.core.Messages;
import seedu.address.testutil.TestTask;

public class ListCommandTest extends TaskManagerGuiTest {

    @Test
    public void list_byListNamesFavouriteAll_listSuccess() {
        assertListResult("list all", td.assignment, td.gym, td.gym2, td.gym3, td.cs2103,
                td.date, td.study);
        assertListResult("list personal", td.gym, td.gym2, td.gym3, td.date);
        assertListResult("list study", td.assignment);
        assertListResult("list favorite", td.assignment, td.gym, td.cs2103, td.study);
        assertListResult("list favorite study", td.assignment);
        assertListResult("list favorite personal", td.gym);
    }

    @Test
    public void list_finishedTasks_listSuccess() {
        commandBox.runCommand("list all");
        commandBox.runCommand("finish 1");
        td.assignment.setFinished(true);
        assertListResult("list finished", td.assignment);
        commandBox.runCommand("list");
        commandBox.runCommand("finish 1");
        commandBox.runCommand("finish 1");
        commandBox.runCommand("finish 1");
        td.gym.setFinished(true);
        td.gym2.setFinished(true);
        td.gym3.setFinished(true);
        assertListResult("list finished personal", td.gym, td.gym2, td.gym3);
    }

    @Test
    public void list_invalidCommandFormat_unknownCommand() {
        commandBox.runCommand("lists study");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
        commandBox.runCommand("liststudy");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

    @Test
    public void list_EmptyList_noTasksListed() {
        commandBox.runCommand("clear");
        assertListResult("list exercise");
        assertResultMessage(MESSAGE_LIST_DOES_NOT_EXIST);
    }

    private void assertListResult(String command, TestTask... expectedHits) {
        commandBox.runCommand(command);
        assertListSize(expectedHits.length);
        assertTrue(taskListPanel.isListMatching(expectedHits));
    }
}
```
###### /java/guitests/LoadCommandTest.java
``` java
package guitests;

import static seedu.address.logic.commands.LoadCommand.COMMAND_WORD;
import static seedu.address.logic.commands.LoadCommand.MESSAGE_LOAD_SUCCESS;
import static seedu.address.logic.commands.LoadCommand.MESSAGE_LOAD_UNSUCCESS;

import org.junit.Test;

import seedu.address.logic.commands.CommandFormatter;

public class LoadCommandTest extends TaskManagerGuiTest {

    @Test
    public void load_LoadFromInternalDirectory_loadSuccess() {
        String path = "data/dueue.xml";
        commandBox.runCommand("load " + path);
        assertResultMessage(CommandFormatter.undoFormatter(
                String.format(MESSAGE_LOAD_SUCCESS, path), COMMAND_WORD));
        //TODO: verify if mode has accepted a new ReadOnlyTaskManager
    }
    @Test
    public void load_loadFromEmptyFile_loadUnsuccess() {
        String path = "data/doeNotExist.xml";
        commandBox.runCommand("load " + path);
        assertResultMessage(MESSAGE_LOAD_UNSUCCESS);
    }
}
```
###### /java/guitests/RedoCommandTest.java
``` java
package guitests;

import static org.junit.Assert.assertTrue;

import org.junit.Test;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.CommandFormatter;
import seedu.address.logic.commands.RedoCommand;
import seedu.address.testutil.TestEvent;
import seedu.address.testutil.TestTask;
import seedu.address.testutil.TestUtil;

public class RedoCommandTest extends TaskManagerGuiTest {

    @Test
    public void redo_undoCommands_redoSuccess() throws IllegalValueException {
        TestTask[] currentList = td.getTypicalTasks();

        String commandToRedo = "add ";
        TestEvent eventToAdd = te.assignment;
        commandBox.runCommand(eventToAdd.getAddCommand());
        currentList = (TestUtil.addTasksToList(currentList, eventToAdd));
        assertRedoSuccess(currentList, commandToRedo);

        int targetIndex = 2;
        commandToRedo = "delete ";
        commandBox.runCommand(commandToRedo + targetIndex);
        currentList = TestUtil.removeTaskFromList(currentList, targetIndex);
        assertRedoSuccess(currentList, commandToRedo);

        commandToRedo = "finish ";
        targetIndex = 2;
        commandBox.runCommand(commandToRedo + targetIndex);
        currentList = TestUtil.removeTaskFromList(currentList, targetIndex);
        assertRedoSuccess(currentList, commandToRedo);

        commandToRedo = "edit ";
        targetIndex = 1;
        String detailsToEdit = " @Home";
        commandBox.runCommand(commandToRedo + targetIndex + detailsToEdit);
        currentList[targetIndex].setVenue("Home");
        assertRedoSuccess(currentList, commandToRedo);

        commandToRedo = "clear ";
        commandBox.runCommand(commandToRedo);
        currentList = new TestTask[] {};
        assertRedoSuccess(currentList, commandToRedo);
    }

    private void assertRedoSuccess(final TestTask[] currentList, String commandWord) {
        commandBox.runCommand("undo");
        commandBox.runCommand("redo");

        assertTrue(taskListPanel.isListMatching(currentList));
        assertResultMessage(CommandFormatter.undoMessageFormatter(
                RedoCommand.MESSAGE_SUCCESS, commandWord + "command"));
    }
}
```
###### /java/guitests/UndoCommandTest.java
``` java
package guitests;

import static org.junit.Assert.assertTrue;

import static seedu.address.logic.commands.UndoCommand.MESSAGE_SUCCESS;
import static seedu.address.logic.commands.UndoCommand.MESSAGE_UNSUCCESS;

import org.junit.Test;

import seedu.address.logic.commands.CommandFormatter;
import seedu.address.testutil.TestEvent;
import seedu.address.testutil.TestTask;
import seedu.address.testutil.TestUtil;

public class UndoCommandTest extends TaskManagerGuiTest {
    private TestTask[] currentList = td.getTypicalTasks();
    private String commandToUndo;
    private String commandWord;

    @Test
    public void undo_ableUndoCommands_undoSuccess() {
        TestEvent eventToAdd = te.assignment;
        commandToUndo = eventToAdd.getAddCommand();
        commandWord = "add";
        assertUndoSuccess(currentList, commandToUndo, commandWord);

        commandToUndo = "delete 1";
        commandWord = "delete";
        assertUndoSuccess(currentList, commandToUndo, commandWord);

        commandToUndo = "finish 1";
        commandWord = "finish";
        assertUndoSuccess(currentList, commandToUndo, commandWord);

        commandToUndo = "load data/dueue.xml";
        commandWord = "load";
        assertUndoSuccess(currentList, commandToUndo, commandWord);

        String detailsToEdit = " n/assignment2 dueT/18:30";
        commandToUndo = "edit 2 " + detailsToEdit;
        commandWord = "edit";
        assertUndoSuccess(currentList, commandToUndo, commandWord);
    }
    @Test
    public void undo_noMoreCommandToUndo_undoUnsuccess() {
        commandBox.runCommand("list all"); //list is not ableUndoCommand
        commandBox.runCommand("undo");
        assertResultMessage(MESSAGE_UNSUCCESS);
    }

    @Test
    public void undo_stackOfAbleUndoCommands_undoSuccess() {
        commandBox.runCommand("finish 1");
        TestTask finishedTask = currentList[0];
        currentList = TestUtil.removeTaskFromList(currentList, 1);

        assertUndoSuccess(currentList, "clear", "clear");
        currentList = TestUtil.addTasksToList(currentList, finishedTask);

        commandWord = "finish";
        commandBox.runCommand("undo");
        assertTrue(taskListPanel.isListMatching(currentList));
        assertResultMessage(CommandFormatter.undoMessageFormatter(MESSAGE_SUCCESS,
                (commandWord + " command")));
    }

    private void assertUndoSuccess(final TestTask[] currentList,
            String commandToUndo, String commandWord) {
        commandBox.runCommand(commandToUndo);
        commandBox.runCommand("undo");
        assertTrue(taskListPanel.isListMatching(currentList));
        assertResultMessage(CommandFormatter.undoMessageFormatter(MESSAGE_SUCCESS,
                (commandWord + " command")));
    }
}
```
###### /java/guitests/ViewCommandTest.java
``` java
package guitests;

import static org.junit.Assert.assertTrue;
import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.commands.ViewNextCommand.MESSAGE_SUCCESS_TMR;
import static seedu.address.logic.commands.ViewNextCommand.MESSAGE_SUCCESS_TODAY;
import static seedu.address.logic.commands.ViewOnCommand.MESSAGE_NONNEGATIVE;

import org.junit.Test;

import seedu.address.commons.core.Messages;
import seedu.address.logic.commands.ViewOnCommand;
import seedu.address.testutil.TestTask;

public class ViewCommandTest extends TaskManagerGuiTest {

    @Test
    public void view_viewNextNDays_viewSuccess() {
        commandBox.runCommand(td.homework.getAddCommand());
        commandBox.runCommand(td.homework2.getAddCommand());
        assertViewResult("view next/1", td.homework, td.homework2);
        assertViewResult("view next/1000", td.homework, td.homework2, td.assignment,
            td.gym, td.gym2, td.gym3, td.cs2103, td.date, td.study);
    }

    @Test
    public void view_viewNextDate_viewSuccess() {
        assertViewResult("view next/01/01/2018", td.assignment, td.gym, td.gym2, td.gym3);
        assertViewResult("view next/01/01/2050", td.assignment,
            td.gym, td.gym2, td.gym3, td.cs2103, td.date, td.study);
    }
    @Test
    public void view_illegalParam_errorMessage() {
        commandBox.runCommand("view next/-1");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_NONNEGATIVE));
        commandBox.runCommand("view on/01/04/2017");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ViewOnCommand.MESSAGE_USAGE));
    }
    @Test
    public void view_viewOnNDays_viewSuccess() {
        commandBox.runCommand("clear");
        commandBox.runCommand(td.homework.getAddCommand());
        commandBox.runCommand(td.homework2.getAddCommand());
        assertViewResult("view on/tmr", td.homework, td.homework2);
    }

    @Test
    public void view_viewOnDate_viewSuccess() {
        assertViewResult("view on/20/12/2017", td.gym);
        assertViewResult("view on/01/02", td.cs2103);
    }

    @Test
    public void view_feedBackMsg_msgMatches() {
        commandBox.runCommand("view");
        assertResultMessage(String.format(MESSAGE_SUCCESS_TODAY, 0));
        commandBox.runCommand("view next/tmr");
        assertResultMessage(String.format(MESSAGE_SUCCESS_TMR, 1));
    }

    @Test
    public void view_invalidCommand_unknownCommand() {
        commandBox.runCommand("views next/10");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);

        commandBox.runCommand("viewnext /10");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

    private void assertViewResult(String command, TestTask... expectedHits) {
        commandBox.runCommand(command);
        assertListSize(expectedHits.length);
        assertTrue(taskListPanel.isListMatching(expectedHits));
    }
}
```
###### /java/seedu/address/storage/XmlTaskManagerStorageTest.java
``` java
    @Test
    public void readMissingFileEmptyResult() throws Exception {
        thrown.expect(FileNotFoundException.class);
        assertFalse(readTaskManager("NonExistentFile.xml").isPresent());
    }

    @Test
    public void readNotXmlFormatExceptionThrown() throws Exception {
        thrown.expect(FileNotFoundException.class);
        readTaskManager("NotXmlFormatTaskManager.xml");
    }
```
###### /java/seedu/address/testutil/EventBuilder.java
``` java
package seedu.address.testutil;

import seedu.address.commons.exceptions.IllegalValueException;

public class EventBuilder extends TaskBuilder {

    private TestEvent event;

    public EventBuilder() {
        this.event = new TestEvent();
    }

    /**
     * Initializes the TaskBuilder with the data of {@code eventToCopy}.
     */
    public EventBuilder(TestEvent eventToCopy) {
        this.event = new TestEvent(eventToCopy);
    }

    public EventBuilder withName(String name) throws IllegalValueException {
        this.event.setName(name);
        return this;
    }

    public EventBuilder withTag(String tag) throws IllegalValueException {
        event.setTag(tag);
        return this;
    }

    public EventBuilder withDate(String date) throws IllegalValueException {
        this.event.setDate(date);
        return this;
    }

    public EventBuilder withTime(String time) throws IllegalValueException {
        this.event.setTime(time);
        return this;
    }

    public EventBuilder withStartDate(String date) throws IllegalValueException {
        this.event.setStartDate(date);
        return this;
    }

    public EventBuilder withStartTime(String time) throws IllegalValueException {
        this.event.setStartTime(time);
        return this;
    }
    public EventBuilder withDescription(String description) throws IllegalValueException {
        this.event.setDescription(description);
        return this;
    }

    public EventBuilder withVenue(String venue) throws IllegalValueException {
        this.event.setVenue(venue);
        return this;
    }

    public EventBuilder withPriority(String priority) throws IllegalValueException {
        this.event.setPriority(priority);
        return this;
    }

    public TestEvent build() {
        return this.event;
    }

    public EventBuilder withFavorite(boolean isFavorite) throws IllegalValueException {
        this.event.setFavorite(isFavorite);
        return this;
    }

    public EventBuilder withFinished(boolean isFinished) throws IllegalValueException {
        this.event.setFinished(isFinished);
        return this;
    }

    public EventBuilder withEvent(boolean isEvent) throws IllegalValueException {
        this.event.setEvent(isEvent);
        return this;
    }
}
```
###### /java/seedu/address/testutil/RecurringTaskBuilder.java
``` java
package seedu.address.testutil;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.task.ReadOnlyRecurringTask.RecurringMode;

public class RecurringTaskBuilder extends TaskBuilder {

    private TestRecurringTask task;

    public RecurringTaskBuilder() {
        this.task = new TestRecurringTask();
    }
    /**
     * Initializes the TaskBuilder with the data of {@code taskToCopy}.
     */
    public RecurringTaskBuilder(TestRecurringTask taskToCopy) {
        this.task = new TestRecurringTask(taskToCopy);
    }

    public RecurringTaskBuilder withName(String name) throws IllegalValueException {
        this.task.setName(name);
        return this;
    }

    public RecurringTaskBuilder withTag(String tag) throws IllegalValueException {
        task.setTag(tag);
        return this;
    }

    public RecurringTaskBuilder withDate(String date) throws IllegalValueException {
        this.task.setDate(date);
        return this;
    }

    public RecurringTaskBuilder withTime(String time) throws IllegalValueException {
        this.task.setTime(time);
        return this;
    }

    public RecurringTaskBuilder withDescription(String description) throws IllegalValueException {
        this.task.setDescription(description);
        return this;
    }

    public RecurringTaskBuilder withVenue(String venue) throws IllegalValueException {
        this.task.setVenue(venue);
        return this;
    }

    public RecurringTaskBuilder withPriority(String priority) throws IllegalValueException {
        this.task.setPriority(priority);
        return this;
    }

    public TestRecurringTask build() {
        return this.task;
    }

    public RecurringTaskBuilder withFavorite(boolean isFavorite) throws IllegalValueException {
        this.task.setFavorite(isFavorite);
        return this;
    }

    public RecurringTaskBuilder withFinished(boolean isFinished) throws IllegalValueException {
        this.task.setFinished(isFinished);
        return this;
    }
    public RecurringTaskBuilder withMode(RecurringMode mode) throws IllegalValueException {
        this.task.setMode(mode);
        return this;
    }
    public RecurringTaskBuilder withRecurring(boolean isRecurring) throws IllegalValueException {
        this.task.setRecurring(isRecurring);
        return this;
    }
}
```
###### /java/seedu/address/testutil/TestEvent.java
``` java
package seedu.address.testutil;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.task.ReadOnlyEvent;
import seedu.address.model.task.TaskDate;
import seedu.address.model.task.TaskTime;

/**
 * A mutable event object. For testing only.
 */
public class TestEvent extends TestTask implements ReadOnlyEvent {

    private TaskDate startDate;
    private TaskTime startTime;

    public TestEvent() {}

    /**
     * Creates a copy of {@code eventToCopy}.
     */
    public TestEvent(TestEvent eventToCopy) {
        super(eventToCopy);
        this.startDate = eventToCopy.getStartDate();
        this.startTime = eventToCopy.getStartTime();
    }

    public void setStartDate(String date) throws IllegalValueException {
        assert date != null;
        this.startDate = new TaskDate(date);
    }

    public TaskDate getStartDate() {
        return startDate;
    }

    public void setStartTime(String time) throws IllegalValueException {
        assert time != null;
        this.startTime = new TaskTime(time);
    }

    public TaskTime getStartTime() {
        return startTime;
    }

    @Override
    public String toString() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getName());
        if (getStartDate() != null) {
            builder.append("  Start Date:");
            builder.append(getStartDate());
        }
        if (getStartTime() != null) {
            builder.append("  Start Time:");
            builder.append(getStartTime());
        }
        if (getDate() != null) {
            builder.append("  Due Date:");
            builder.append(getDate());
        }
        if (getTime() != null) {
            builder.append("  Due Time:");
            builder.append(getTime());
        }
        if (getDescription() != null) {
            builder.append("  Description:");
            builder.append(getDescription());
        }
        if (getTag() != null) {
            builder.append("  List:");
            builder.append(getTag());
        }
        if (getVenue() != null) {
            builder.append("  Venue:");
            builder.append(getVenue());
        }
        assert getPriority() != null;
        builder.append("  Priority:");
        builder.append(getPriority());
        if (isFavorite()) {
            builder.append(" favorite");
        }
        if (isFinished()) {
            builder.append(" finished");
        }
        return builder.toString();
    }

    public String getAddCommand() {
        StringBuilder sb = new StringBuilder();
        sb.append(super.getAddCommand());
        sb.append("start/" + this.getStartDate().getValue() + " ");
        sb.append("startT/" + this.getStartTime().getValue() + " ");
        return sb.toString();
    }
}
```
###### /java/seedu/address/testutil/TestTask.java
``` java
    public void setFinished(boolean isFinished) {
        if (isFinished) {
            this.isFinished = FinishProperty.FINISHED;
        } else {
            this.isFinished = FinishProperty.UNFINISHED;
        }
    }

    public void setEvent(boolean isEvent) {
        if (isEvent) {
            this.isEvent = EventProperty.EVENT;
        } else {
            this.isEvent = EventProperty.NON_EVENT;
        }
    }

    public void setRecurring(boolean isRecurring) {
        if (isRecurring) {
            this.isRecurring = RecurringProperty.RECURRING;
        } else {
            this.isRecurring = RecurringProperty.NON_RECURRING;
        }
    }

    @Override
    public String getFavoriteText() {
        if (isFavorite) {
            return "Favorite";
        } else {
            return "";
        }
    }

    @Override
    public String getFinishedText() {
        if (isFinished == FinishProperty.FINISHED) {
            return "Finished";
        } else {
            return "Unfinished";
        }
    }

    @Override
    public String toString() {
        return getAsText();
    }

    public String getAddCommand() {
        StringBuilder sb = new StringBuilder();
        sb.append("add " + this.getName().toString() + " ");
        sb.append("due/" + this.getDate().getValue() + " ");
        sb.append("dueT/" + this.getTime().getValue() + " ");
        sb.append("d/" + this.getDescription().getValue() + " ");
        sb.append("#" + this.getTag().getName() + " ");
        sb.append("@" + this.getVenue().getValue() + " ");
        sb.append("p/" + this.getPriority().getValue() + " ");
        if (this.isFavorite()) {
            sb.append("*f" + " ");
        }
        return sb.toString();
    }
```
###### /java/seedu/address/testutil/TypicalRecurringTasks.java
``` java
package seedu.address.testutil;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.TaskManager;
import seedu.address.model.task.ReadOnlyRecurringTask.RecurringMode;
import seedu.address.model.task.Task;
import seedu.address.model.task.TaskDate;
import seedu.address.model.task.UniqueTaskList;

public class TypicalRecurringTasks {
    public TestRecurringTask homework, homework2, gym, gym2, gym3, cs2103;
    private RecurringMode mode1 = RecurringMode.DAY;
    private RecurringMode mode2 = RecurringMode.WEEK;
    private RecurringMode mode3 = RecurringMode.MONTH;

    public TypicalRecurringTasks() {
        try {
            TaskDate date1 = new TaskDate("tmr");
            homework = new RecurringTaskBuilder().withName("homework").withDate(date1.toString()).withTime(
                    "20:00").withDescription("Crazy but useful mod")
                    .withTag("personal").withVenue("gym").withPriority("2").withFavorite(true).withRecurring(true)
                    .withMode(mode1).withFinished(false).build();
            homework2 = new RecurringTaskBuilder().withName("homework").withDate(date1.toString()).withTime(
                    "16:00").withDescription("Crazy but useful mod").
                    withTag("school").withVenue("icube").withPriority("1").withFavorite(true).withRecurring(true)
                    .withMode(mode1)
                    .withFinished(false).build();
            gym = new RecurringTaskBuilder().withName("gym").withDate("20/12/2017").withTime(
                    "20:00").withDescription("50min workout").
                    withTag("personal").withVenue("gym").withPriority("2").withFavorite(true)
                    .withFinished(false).withRecurring(true).withMode(mode2).build();
            //gym2 and gym3 are built for findCommandTest
            gym2 = new RecurringTaskBuilder().withName("gym").withDate("20/12/2017").withTime(
                    "15:00").withDescription("50min workout").
                    withTag("personal").withVenue("gym").withPriority("2").withFavorite(true)
                    .withFinished(false).withRecurring(true).withMode(mode1).build();
            gym3 = new RecurringTaskBuilder().withName("gym").withDate("20/12/2017").withTime(
                    "16:00").withDescription("50min workout").
                    withTag("personal").withVenue("gym").withPriority("2").withFavorite(true)
                    .withFinished(false).withRecurring(true).withMode(mode3).build();
            cs2103 = new RecurringTaskBuilder().withName("cs2103").withDate("01/02").withTime(
                    "16:00").withDescription("Crazy but useful mod").
                    withTag("school").withVenue("icube").withPriority("1").withFavorite(true).withRecurring(true)
                    .withMode(mode3)
                    .withFinished(false).build();
        } catch (IllegalValueException e) {
            e.printStackTrace();
            assert false : "not possible";
        }
    }

    public static void loadTaskManagerWithSampleData(TaskManager tm) {
        for (TestTask task : new TypicalRecurringTasks().getTypicalRecurringTasks()) {
            try {
                tm.addTask(new Task(task));
            } catch (UniqueTaskList.DuplicateTaskException e) {
                assert false : "not possible";
            }
        }
    }

    public TestTask[] getTypicalRecurringTasks() {
        TestTask[] tasks = {homework, homework2, gym, gym2, gym3, cs2103};
        List<TestTask> listOfTasks = asList(tasks);
        listOfTasks = sort(listOfTasks);
        return listOfTasks.toArray(new TestTask[listOfTasks.size()]);
    }

    private <T> List<T> asList(T[] objs) {
        List<T> list = new ArrayList<>();
        for (T obj : objs) {
            list.add(obj);
        }
        return list;
    }

    private static List<TestTask> sort(List<TestTask> list) {
        Collections.sort(list, (TestTask t1, TestTask t2) -> t1.getTag().compareTo(t2.getTag()));
        Collections.sort(list, (TestTask t1, TestTask t2) -> t1.getName().compareTo(t2.getName()));
        Collections.sort(list, (TestTask t1, TestTask t2) -> t1.getTime().compareTo(t2.getTime()));
        Collections.sort(list, (TestTask t1, TestTask t2) -> -t1.getPriority().compareTo(t2.getPriority()));
        Collections.sort(list, (TestTask t1, TestTask t2) -> t1.getDate().compareTo(t2.getDate()));
        return list;
    }

    public TaskManager getTypicalTaskManager() {
        TaskManager tm = TaskManager.getStub();
        loadTaskManagerWithSampleData(tm);
        return tm;
    }
}
```
###### /java/seedu/address/testutil/TypicalTestEvents.java
``` java
package seedu.address.testutil;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.TaskManager;
import seedu.address.model.task.Task;
import seedu.address.model.task.UniqueTaskList;

public class TypicalTestEvents {
    public TestEvent gym, gym2, gym3, cs2103, study, assignment, date, date2, date3, date4, meeting,
        familyDinner, travel, shopping, shopping2;

    public TypicalTestEvents() {
        try {
            gym = new EventBuilder().withName("gym").withDate("20/12/2017").withTime(
                    "20:00").withDescription("50min workout").withStartDate("20/11/2017").withStartTime("19:00").
                    withTag("personal").withVenue("gym").withPriority("2").withFavorite(true)
                    .withFinished(false).withEvent(true).build();
            //gym2 and gym3 are built for findCommandTest
            gym2 = new EventBuilder().withName("gym").withDate("21/12/2017").withTime(
                    "20:00").withDescription("50min workout").withStartDate("20/11/2017").withStartTime("").
                    withTag("personal").withVenue("gym").withPriority("2").withFavorite(false)
                    .withFinished(false).withEvent(true).build();
            gym3 = new EventBuilder().withName("gym").withDate("22/12/2017").withTime(
                    "20:00").withDescription("50min workout").withStartDate("20/11/2017").withStartTime("").
                    withTag("personal").withVenue("gym").withPriority("2").withFavorite(false)
                    .withFinished(false).withEvent(true).build();
            cs2103 = new EventBuilder().withName("cs2103").withDate("01/02").withTime(
                    "16:00").withDescription("Crazy but useful mod").
                    withTag("school").withVenue("icube").withPriority("1").withFavorite(true)
                    .withStartDate("20/12/2017").withStartTime("19:00").withFinished(false).withEvent(true).build();
            study = new EventBuilder().withName("study").withDate("21/03").withTime(
                    "15:34").withDescription("Study for MTE").
                    withTag("school").withVenue("Central lib").withPriority("2").withFavorite(true)
                    .withStartDate("20/12/2017").withStartTime("19:00").withFinished(false).withEvent(true).build();
            assignment = new EventBuilder().withName("assignment").withDate("10/12/2017").withTime(
                    "10:00").withDescription("IE2150").
                    withTag("study").withVenue("Utown").withPriority("2").withFavorite(true)
                    .withStartDate("02/12/2017").withStartTime("19:00").withFinished(false).withEvent(true).build();
            //The test tasks below are for duplicate task testing
            date  = new EventBuilder().withName("date").withDate("14/02/2018").withTime(
                    "12:00").withDescription("Most important day").withFinished(false).
                    withTag("personal").withVenue("Gardens by the bay").withPriority("3")
                    .withStartDate("11/02/2018").withStartTime("08:00").withFavorite(false).withEvent(true).build();
            date2  = new EventBuilder().withName("date").withDate("14/02/2020").withTime(
                    "12:00").withDescription("Most important day").withFinished(false).
                    withTag("personal").withVenue("Gardens by the bay").withPriority("3")
                    .withStartDate("tmr").withStartTime("19:00").withFavorite(false).withEvent(true).build();
            date3  = new EventBuilder().withName("date").withDate("14/02/2018").withTime(
                    "12:00").withDescription("Most important day").withFinished(false).
                    withTag("personal").withVenue("Gardens by the bay").withPriority("3")
                    .withStartDate("11/02/2018").withStartTime("09:00").withFavorite(false).withEvent(true).build();
            date4  = new EventBuilder().withName("date").withDate("14/02/2018").withTime(
                    "12:00").withDescription("Most important day").
                    withTag("private").withVenue("Gardens by the bay").withPriority("3").withFinished(false)
                    .withStartDate("11/02/2018").withStartTime("08:00").withFavorite(false).withEvent(true).build();
          //The test tasks above are for duplicate task testing
            meeting = new EventBuilder().withName("meeting").withDate("27/04/2017").withTime(
                    "12:00").withDescription("Meeting old friends").
                    withTag("school").withVenue("PGP").withPriority("2").withFavorite(false)
                    .withStartDate("25/04/2017").withStartTime("19:00").withFinished(false).withEvent(true).build();
            familyDinner = new EventBuilder().withName("family dinner").withDate("1/1").withTime(
                    "20:00").withDescription("Meeting families").
                    withTag("family").withVenue("home").withPriority("important").withFavorite(true)
                    .withStartDate("20/12/2017").withStartTime("19:00").withFinished(false).withEvent(true).build();
            travel = new EventBuilder().withName("travel").withDate("1/01/2018").withTime(
                    "").withDescription("To Africa").
                    withTag("personal").withVenue("Africa").withPriority("important").withFinished(false)
                    .withStartDate("20/12/2017").withStartTime("").withFavorite(true).withEvent(true).build();
            //shopping violates start date constraint
            shopping = new EventBuilder().withName("shopping").withDate("1/01/2018").withTime(
                    "").withDescription("Shopping in Airport").
                    withTag("personal").withVenue("Airport").withPriority("3").withFavorite(true)
                    .withStartDate("20/12/2018").withStartTime("").withFinished(false).withEvent(true).build();
        } catch (IllegalValueException e) {
            throw new IllegalStateException("Unable to build task");
        }
    }

    public static void loadTaskManagerWithSampleData(TaskManager tm) {
        for (TestEvent task : new TypicalTestEvents().getTypicalEvents()) {
            try {
                tm.addTask(new Task(task));
            } catch (UniqueTaskList.DuplicateTaskException e) {
                assert false : "not possible";
            }
        }
    }

    public TestEvent[] getTypicalEvents() {
        TestEvent[] events = {gym, gym2, gym3, cs2103, study, assignment, date};
        List<TestEvent> listOfEvents = asList(events);
        listOfEvents = sort(listOfEvents);
        return listOfEvents.toArray(new TestEvent[listOfEvents.size()]);
    }

    private <T> List<T> asList(T[] objs) {
        List<T> list = new ArrayList<>();
        for (T obj : objs) {
            list.add(obj);
        }
        return list;
    }

    private static List<TestEvent> sort(List<TestEvent> list) {
        Collections.sort(list, (TestEvent t1, TestEvent t2) -> t1.getTag().compareTo(t2.getTag()));
        Collections.sort(list, (TestEvent t1, TestEvent t2) -> t1.getName().compareTo(t2.getName()));
        Collections.sort(list, (TestEvent t1, TestEvent t2) -> t1.getTime().compareTo(t2.getTime()));
        Collections.sort(list, (TestEvent t1, TestEvent t2) -> -t1.getPriority().compareTo(t2.getPriority()));
        Collections.sort(list, (TestEvent t1, TestEvent t2) -> t1.getDate().compareTo(t2.getDate()));
        return list;
    }

    public TaskManager getTypicalTaskManager() {
        TaskManager tm = TaskManager.getStub();
        loadTaskManagerWithSampleData(tm);
        return tm;
    }
}
```
###### /java/seedu/address/testutil/TypicalTestTasks.java
``` java
package seedu.address.testutil;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.TaskManager;
import seedu.address.model.task.Task;
import seedu.address.model.task.TaskDate;
import seedu.address.model.task.UniqueTaskList;

public class TypicalTestTasks {
    public TestTask homework, homework2, gym, gym2, gym3, cs2103, study, assignment,
        date, date2, date3, date4, meeting, familyDinner, travel, shopping, shopping2;

    public TypicalTestTasks() {
        try {
            TaskDate date1 = new TaskDate("tmr");
            homework = new TaskBuilder().withName("homework").withDate(date1.toString()).withTime(
                    "20:00").withDescription("50min workout").
                    withTag("personal").withVenue("gym").withPriority("2").withFavorite(true)
                    .withFinished(false).build();
            homework2 = new TaskBuilder().withName("homework2").withDate(date1.toString()).withTime(
                    "16:00").withDescription("Crazy but useful mod").
                    withTag("school").withVenue("icube").withPriority("1").withFavorite(true)
                    .withFinished(false).build();
            gym = new TaskBuilder().withName("gym").withDate("20/12/2017").withTime(
                    "20:00").withDescription("50min workout").
                    withTag("personal").withVenue("gym").withPriority("2").withFavorite(true)
                    .withFinished(false).build();
            //gym2 and gym3 are built for findCommandTest
            gym2 = new TaskBuilder().withName("gym").withDate("21/12/2017").withTime(
                    "20:00").withDescription("50min workout").
                    withTag("personal").withVenue("gym").withPriority("2").withFavorite(false)
                    .withFinished(false).build();
            gym3 = new TaskBuilder().withName("gym").withDate("22/12/2017").withTime(
                    "20:00").withDescription("50min workout").
                    withTag("personal").withVenue("gym").withPriority("2").withFavorite(false)
                    .withFinished(false).build();
            cs2103 = new TaskBuilder().withName("cs2103").withDate("01/02").withTime(
                    "16:00").withDescription("Crazy but useful mod").
                    withTag("school").withVenue("icube").withPriority("1").withFavorite(true)
                    .withFinished(false).build();
            study = new TaskBuilder().withName("study").withDate("21/03").withTime(
                    "15:34").withDescription("Study for MTE").
                    withTag("school").withVenue("Central lib").withPriority("2").withFavorite(true)
                    .withFinished(false).build();
            assignment = new TaskBuilder().withName("assignment").withDate("10/12/2017").withTime(
                    "10:00").withDescription("IE2150").
                    withTag("study").withVenue("Utown").withPriority("2").withFavorite(true)
                    .withFinished(false).build();
            //The test tasks below are for duplicate task testing
            date  = new TaskBuilder().withName("date").withDate("14/02/2018").withTime(
                    "12:00").withDescription("Most important day").
                    withTag("personal").withVenue("Gardens by the bay").withPriority("3")
                    .withFinished(false).withFavorite(false).build();
            date2  = new TaskBuilder().withName("date").withDate("14/02/2020").withTime(
                    "12:00").withDescription("Most important day").
                    withTag("private").withVenue("Gardens by the bay").withPriority("3")
                    .withFinished(false).withFavorite(false).build();
            date3  = new TaskBuilder().withName("date").withDate("15/04/2017").withTime(
                    "12:00").withDescription("Most important day").
                    withTag("personal").withVenue("Gardens by the bay").withPriority("3")
                    .withFinished(false).withFavorite(false).build();
            date4  = new TaskBuilder().withName("date").withDate("14/04/2017").withTime(
                    "13:00").withDescription("Most important day").
                    withTag("personal").withVenue("Gardens by the bay").withPriority("3")
                    .withFinished(false).withFavorite(false).build();
          //The test tasks above are for duplicate task testing
            meeting = new TaskBuilder().withName("meeting").withDate("27/04").withTime(
                    "12:00").withDescription("Meeting old friends").
                    withTag("school").withVenue("PGP").withPriority("2").withFavorite(false)
                    .withFinished(false).build();
            familyDinner = new TaskBuilder().withName("family dinner").withDate("1/1").withTime(
                    "20:00").withDescription("Meeting families").
                    withTag("family").withVenue("home").withPriority("important").withFavorite(true)
                    .withFinished(false).build();
            travel = new TaskBuilder().withName("travel").withDate("1/01").withTime(
                    "21:00").withDescription("To Africa").
                    withTag("personal").withVenue("Africa").withPriority("important")
                    .withFinished(false).withFavorite(true).build();
            shopping = new TaskBuilder().withName("shopping").withDate("1/01").withTime(
                    "21:00").withDescription("Shopping in Airport").
                    withTag("personal").withVenue("Airport").withPriority("3").withFavorite(true)
                    .withFinished(false).build();
            //floating task test
            shopping2 = new TaskBuilder().withName("shopping").withDate("26/04").withTime("")
                    .withDescription("").withTag("Inbox").withVenue("").withPriority("2")
                    .withFinished(false).withFavorite(false).build();
        } catch (IllegalValueException e) {
            e.printStackTrace();
            assert false : "not possible";
        }
    }

    public static void loadTaskManagerWithSampleData(TaskManager tm) {
        for (TestTask task : new TypicalTestTasks().getTypicalTasks()) {
            try {
                tm.addTask(new Task(task));
            } catch (UniqueTaskList.DuplicateTaskException e) {
                assert false : "not possible";
            }
        }
    }

    public TestTask[] getTypicalTasks() {
        TestTask[] tasks = {gym, gym2, gym3, cs2103, study, assignment, date};
        List<TestTask> listOfTasks = asList(tasks);
        listOfTasks = sort(listOfTasks);
        return listOfTasks.toArray(new TestTask[listOfTasks.size()]);
    }

    private <T> List<T> asList(T[] objs) {
        List<T> list = new ArrayList<>();
        for (T obj : objs) {
            list.add(obj);
        }
        return list;
    }

    private static List<TestTask> sort(List<TestTask> list) {
        Collections.sort(list, (TestTask t1, TestTask t2) -> t1.getTag().compareTo(t2.getTag()));
        Collections.sort(list, (TestTask t1, TestTask t2) -> t1.getName().compareTo(t2.getName()));
        Collections.sort(list, (TestTask t1, TestTask t2) -> t1.getTime().compareTo(t2.getTime()));
        Collections.sort(list, (TestTask t1, TestTask t2) -> -t1.getPriority().compareTo(t2.getPriority()));
        Collections.sort(list, (TestTask t1, TestTask t2) -> t1.getDate().compareTo(t2.getDate()));
        return list;
    }

    public TaskManager getTypicalTaskManager() {
        TaskManager tm = TaskManager.getStub();
        loadTaskManagerWithSampleData(tm);
        return tm;
    }
}
```
