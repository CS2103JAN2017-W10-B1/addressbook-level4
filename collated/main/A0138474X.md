# A0138474X
###### /java/seedu/address/logic/commands/AbleUndoCommand.java
``` java
package seedu.address.logic.commands;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.exceptions.CommandException;

/**
 * Represents a command with hidden internal logic and the ability to be executed.
 */
public abstract class AbleUndoCommand extends Command {

    public static final String UNDO_COMMAND_WORD = "undo";

    public static final String COMMAND_SUFFIX = " command";

    public static final String MESSAGE_UNDO_TASK_SUCCESS = "Undo last command successful";

    public abstract CommandResult executeUndo(String message) throws CommandException;

    public abstract Command getUndoCommand() throws IllegalValueException;

    public abstract String getUndoCommandWord();
}

```
###### /java/seedu/address/logic/commands/AddCommand.java
``` java
package seedu.address.logic.commands;

import seedu.address.commons.core.EventsCenter;
import seedu.address.commons.events.ui.JumpToListRequestEvent;
import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.model.tag.Tag;
import seedu.address.model.task.Description;
import seedu.address.model.task.Event;
import seedu.address.model.task.Name;
import seedu.address.model.task.Priority;
import seedu.address.model.task.ReadOnlyRecurringTask.RecurringMode;
import seedu.address.model.task.ReadOnlyTask;
import seedu.address.model.task.RecurringEvent;
import seedu.address.model.task.RecurringTask;
import seedu.address.model.task.Task;
import seedu.address.model.task.TaskDate;
import seedu.address.model.task.TaskTime;
import seedu.address.model.task.UniqueTaskList;
import seedu.address.model.task.Venue;

/**
 * Adds a task/event/recurring task to Dueue.
 */
public class AddCommand extends AbleUndoCommand {

    public static final String COMMAND_WORD = "add";
    public static final String COMMAND_ADD = COMMAND_WORD + COMMAND_SUFFIX;

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a task to Dueue. \n"
            + "Parameters: NAME [due/DUE_DATE] [dueT/DUE_TIME] [start/START_DATE] [startT/START_TIME]\n"
            + "[#LISTNAME] [d/DESCRIPTION] [@VENUE] [p/PRIORITY_LEVEL] [*f] [f/REPEAT_PERIOD] \n"
            + "Examples: " + COMMAND_WORD
            + " \nTrip to Taiwan due/24/6/2017 start/tmr startT/16:00"
            + " dueT/18:00 p/3 *f\n"
            + COMMAND_WORD
            + " CS2103T Tutorial #CS2103 d/Finish asap p/important\n"
            + COMMAND_WORD
            + " CS2103 Demo f/weekly #CS2103 d/Exhausting module @SoC p/3\n";

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the Dueue";

    private final Task toAdd;
    private boolean isSuccess;
    private boolean isDeleteAllOcurrence = true;

    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */

    public AddCommand(String name, String date, String startDate, String time, String startTime,
            String tag, String description, String venue, String priority, String frequency,
            boolean isFavourite, boolean isEvent, boolean isRecurring)
            throws IllegalValueException {
        //TODO: avoid long parameter list
        if (isEvent) {
            if (isRecurring) {
                RecurringMode mode = getRecurringMode(frequency);
                this.toAdd = buildEvent(name, date, startDate, time, startTime,
                        tag, description, venue, priority, isFavourite, mode);
            } else {
                this.toAdd = buildEvent(name, date, startDate, time, startTime,
                    tag, description, venue, priority, isFavourite);
            }
        } else {
            if (isRecurring) {
                RecurringMode mode = getRecurringMode(frequency);
                this.toAdd = buildTask(name, date, time, tag, description,
                        venue, priority, isFavourite, mode);
            } else {
                this.toAdd = buildTask(name, date, time, tag, description,
                        venue, priority, isFavourite);
            }
        }
        this.isSuccess = false;
    }

    private Event buildEvent(String name, String date, String startDate, String time,
            String startTime, String tag, String description, String venue,
            String priority, boolean isFavourite)
                    throws IllegalValueException {
        if (!startDate.isEmpty()) {
            return new Event(
                    new Name(name),
                    new TaskDate(startDate),
                    new TaskTime (startTime),
                    new TaskDate(date),
                    new TaskTime(time),
                    new Description(description),
                    new Tag(tag),
                    new Venue(venue),
                    new Priority(priority),
                    isFavourite
            );
        } else {
            return new Event(
                    new Name(name),
                    new TaskDate(date),
                    new TaskTime (startTime),
                    new TaskTime(time),
                    new Description(description),
                    new Tag(tag),
                    new Venue(venue),
                    new Priority(priority),
                    isFavourite
                );
        }
    }

    private Event buildEvent(String name, String date, String startDate, String time,
            String startTime, String tag, String description, String venue,
            String priority, boolean isFavourite, RecurringMode mode)
                    throws IllegalValueException {
        if (mode == null) {
            return buildEvent(name, date, startDate, time, startTime, tag,
                    description, venue, priority, isFavourite);
        } else {
            if (!startDate.isEmpty()) {
                return new RecurringEvent(
                        new Name(name),
                        new TaskDate(startDate),
                        new TaskTime (startTime),
                        new TaskDate(date),
                        new TaskTime(time),
                        new Description(description),
                        new Tag(tag),
                        new Venue(venue),
                        new Priority(priority),
                        isFavourite,
                        mode
                );
            } else {
                return new RecurringEvent(
                        new Name(name),
                        new TaskDate(date),
                        new TaskTime (startTime),
                        new TaskTime(time),
                        new Description(description),
                        new Tag(tag),
                        new Venue(venue),
                        new Priority(priority),
                        isFavourite,
                        mode
                    );
            }
        }
    }

    private Task buildTask(String name, String date, String time,
            String tag, String description, String venue,
            String priority, boolean isFavourite)
                    throws IllegalValueException {
        return new Task(
                new Name(name),
                new TaskDate(date),
                new TaskTime(time),
                new Description(description),
                new Tag(tag),
                new Venue(venue),
                new Priority(priority),
                isFavourite
                );
    }

    private Task buildTask(String name, String date, String time,
            String tag, String description, String venue,
            String priority, boolean isFavourite, RecurringMode mode)
                    throws IllegalValueException {
        if (mode == null) {
            return buildTask(name, date, time, tag,
                    description, venue, priority, isFavourite);
        } else {
            return new RecurringTask(
                    new Name(name),
                    new TaskDate(date),
                    new TaskTime(time),
                    new Description(description),
                    new Tag(tag),
                    new Venue(venue),
                    new Priority(priority),
                    isFavourite,
                    mode
                    );
        }
    }

    private RecurringMode getRecurringMode(String ocurring) {
        if (ocurring.matches(RecurringTask.PERIOD_DAY_REGEX)) {
            return RecurringMode.DAY;
        } else if (ocurring.matches(RecurringTask.PERIOD_WEEK_REGEX)) {
            return RecurringMode.WEEK;
        } else if (ocurring.matches(RecurringTask.PERIOD_MONTH_REGEX)) {
            return RecurringMode.MONTH;
        }
        return null;
    }

    public AddCommand(ReadOnlyTask task, boolean isDeleteAllOcurrence) {
        this.toAdd = (Task) task;
        this.isDeleteAllOcurrence = isDeleteAllOcurrence;
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            model.addTask(toAdd);
            this.isSuccess = true;
            int taskIndex = model.getFilteredTaskList().indexOf(toAdd);
            EventsCenter.getInstance().post(new JumpToListRequestEvent(taskIndex));
            return new CommandResult(
                    CommandFormatter.undoFormatter(
                            String.format(MESSAGE_SUCCESS, toAdd.getName()), COMMAND_ADD));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            this.isSuccess = false;
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
    }

    public Task getTask() {
        return toAdd;
    }

    @Override
    public boolean isUndoable() {
        return true;
    }

    @Override
    public CommandResult executeUndo(String message) throws CommandException {
        assert model != null;
        try {
            model.addTask(toAdd);
            this.isSuccess = true;
            return new CommandResult(CommandFormatter.undoMessageFormatter(message, COMMAND_ADD));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
    }

    @Override
    public Command getUndoCommand() {
        if (isSuccess) {
            return new DeleteCommand(getTask(), isDeleteAllOcurrence);
        } else {
            return new IncorrectCommand(null);
        }
    }

    @Override
    public String getUndoCommandWord() {
        return DeleteCommand.COMMAND_WORD + COMMAND_SUFFIX;
    }

}
```
###### /java/seedu/address/logic/commands/ClearCommand.java
``` java
package seedu.address.logic.commands;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.model.TaskManager;

/**
 * Clears Dueue.
 */
public class ClearCommand extends AbleUndoCommand {

    public static final String COMMAND_WORD = "clear";
    public static final String COMMAND_CLEAR = "clear command";
    public static final String MESSAGE_SUCCESS = "Dueue has been cleared!";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Clear all tasks in Dueue \n"
            + "Parameters: Nil\n"
            + "Example: " + COMMAND_WORD;

    private TaskManager tasks;

    @Override
    public CommandResult execute() {
        assert model != null;
        tasks = TaskManager.getStub();
        tasks.resetData(model.getTaskManager());
        model.resetData(TaskManager.getStub());
        return new CommandResult(CommandFormatter.undoFormatter(MESSAGE_SUCCESS, COMMAND_CLEAR));
    }

    @Override
    public boolean isUndoable() {
        return true;
    }

    @Override
    public CommandResult executeUndo(String message) throws CommandException {
        assert model != null;
        TaskManager tasks = TaskManager.getStub();
        tasks.resetData(model.getTaskManager());
        model.resetData(this.tasks);
        this.tasks = tasks;
        return new CommandResult(CommandFormatter.undoMessageFormatter(message, COMMAND_CLEAR));
    }

    @Override
    public Command getUndoCommand() throws IllegalValueException {
        return this;
    }

    @Override
    public String getUndoCommandWord() {
        return COMMAND_WORD + COMMAND_SUFFIX;
    }

}
```
###### /java/seedu/address/logic/commands/DeleteCommand.java
``` java
package seedu.address.logic.commands;

import seedu.address.commons.core.Messages;
import seedu.address.commons.core.UnmodifiableObservableList;
import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.model.task.ReadOnlyTask;
import seedu.address.model.task.RecurringTask;
import seedu.address.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.address.model.task.UniqueTaskList.TaskNotFoundException;


/**
 * Deletes a task identified using it's last displayed index from the Dueue.
 */
public class DeleteCommand extends AbleUndoCommand {

    public static final String COMMAND_WORD = "delete";
    public static final String COMMAND_DELETE = "delete command";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1 [all]";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted task: %1$s";

    public final int targetIndex;

    private ReadOnlyTask task;
    private ReadOnlyTask replaceTask;

    private boolean isSuccess;
    private boolean isDeleteAllOcurrence;

    public DeleteCommand(int targetIndex, boolean isDeleteAllOcurrence) {
        this.targetIndex = targetIndex;
        this.isDeleteAllOcurrence = isDeleteAllOcurrence;
        this.task = null;
        this.isSuccess = false;
    }

    public DeleteCommand(ReadOnlyTask task, boolean isDeleteAllOcurrence) {
        this.targetIndex = 0;
        this.isDeleteAllOcurrence = isDeleteAllOcurrence;
        this.task = task;
    }


    @Override
    public CommandResult execute() throws CommandException {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToDelete = lastShownList.get(targetIndex - 1);

        try {
            if (taskToDelete.isRecurring() && !isDeleteAllOcurrence) {
                try {
                    this.task = new RecurringTask(taskToDelete);
                    ((RecurringTask) taskToDelete).finishOnce();
                    this.replaceTask = new RecurringTask(taskToDelete);
                    isSuccess = true;
                    model.updateTask(targetIndex - 1, taskToDelete);
                } catch (DuplicateTaskException e) {
                    e.printStackTrace();
                }
            } else {
                model.deleteTask(taskToDelete);
                this.task = taskToDelete;
                this.isSuccess = true;
            }
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }

        return new CommandResult(
                CommandFormatter.undoFormatter(
                        String.format(MESSAGE_DELETE_TASK_SUCCESS, taskToDelete), COMMAND_DELETE));
    }


    @Override
    public boolean isUndoable() {
        return true;
    }

    @Override
    public CommandResult executeUndo(String message) throws CommandException {

        try {
            if (task.isRecurring() && !isDeleteAllOcurrence) {
                try {
                    RecurringTask task = new RecurringTask(this.task);
                    ((RecurringTask) task).finishOnce();
                    this.replaceTask = new RecurringTask(task);
                    isSuccess = true;
                    model.deleteTask(this.task);
                    model.addTask(task);
                } catch (DuplicateTaskException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                } catch (IllegalValueException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            } else {
                model.deleteTask(this.task);
                this.isSuccess = true;
            }
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }
        return new CommandResult(CommandFormatter.undoMessageFormatter(message, COMMAND_DELETE));
    }

    @Override
    public Command getUndoCommand() {
        if (isSuccess) {
            if (task.isRecurring() && !isDeleteAllOcurrence) {
                try {
                    model.deleteTask(replaceTask);
                } catch (TaskNotFoundException e) {
                    assert false : "this task cannot be invalid";
                }
            }
            return new AddCommand(task, isDeleteAllOcurrence);
        } else {
            return new IncorrectCommand(null);
        }
    }

    @Override
    public String getUndoCommandWord() {
        return AddCommand.COMMAND_WORD + COMMAND_SUFFIX;
    }
}
```
###### /java/seedu/address/logic/commands/EditCommand.java
``` java
package seedu.address.logic.commands;

import java.util.List;
import java.util.Optional;

import seedu.address.commons.core.EventsCenter;
import seedu.address.commons.core.Messages;
import seedu.address.commons.events.ui.JumpToListRequestEvent;
import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.commons.util.CollectionUtil;
import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.model.tag.Tag;
import seedu.address.model.task.Description;
import seedu.address.model.task.Event;
import seedu.address.model.task.Name;
import seedu.address.model.task.Priority;
import seedu.address.model.task.ReadOnlyEvent;
import seedu.address.model.task.ReadOnlyRecurringTask.RecurringMode;
import seedu.address.model.task.ReadOnlyTask;
import seedu.address.model.task.ReadOnlyTask.FinishProperty;
import seedu.address.model.task.RecurringTask;
import seedu.address.model.task.Task;
import seedu.address.model.task.TaskDate;
import seedu.address.model.task.TaskTime;
import seedu.address.model.task.UniqueTaskList;
import seedu.address.model.task.UniqueTaskList.TaskNotFoundException;
import seedu.address.model.task.Venue;


/**
 * Edits the details of an existing task in the Dueue.
 */
public class EditCommand extends AbleUndoCommand {

    public static final String COMMAND_WORD = "edit";

    public static final String COMMAND_EDIT = "edit command";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Edits the details of the task identified "
            + "by the index given.\n"
            + "Parameters: INDEX [n/TASK_NAME]\n [due/DUE_DATE] [dueT/DUE_TIME]"
            + "[start/START_DATE] [startT/STAR_TTIME] [#LIST_NAME] "
            + "[d/DESCRIPTION] [@VENUE] [p/PRIORITY_LEVEL] [*f/*u]\n"
            + "Example: " + COMMAND_WORD + " 1 due/17/3/2017 #CS2103T";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited task: %1$s";
    public static final String MESSAGE_NOT_EDITED = "At least one field to edit must be provided.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";

    protected final int filteredTaskListIndex;
    protected final EditTaskDescriptor editTaskDescriptor;
    protected ReadOnlyTask task;
    protected Task oldTask;
    protected boolean isSuccess;

    /**
     * @param filteredPersonListIndex the index of the task in the filtered task list to edit
     * @param editPersonDescriptor details to edit the task with
     */
    public EditCommand(int filteredTaskListIndex, EditTaskDescriptor editTaskDescriptor) {
        assert filteredTaskListIndex > 0;
        assert editTaskDescriptor != null;

        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex - 1;

        this.editTaskDescriptor = new EditTaskDescriptor(editTaskDescriptor);
        this.isSuccess = false;
    }

    public EditCommand(ReadOnlyTask task, Task oldTask) {
        this.task = task;
        this.oldTask = oldTask;
        this.filteredTaskListIndex = 0;
        this.editTaskDescriptor = null;
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToEdit = lastShownList.get(filteredTaskListIndex);
        oldTask = createTask(taskToEdit);

        try {
            Task editedTask = createEditedTask(taskToEdit, editTaskDescriptor);
            model.updateTask(filteredTaskListIndex, editedTask);
            isSuccess = true;
            task = editedTask;
            int taskIndex = model.getFilteredTaskList().indexOf(editedTask);
            EventsCenter.getInstance().post(new JumpToListRequestEvent(taskIndex));
            model.updateFilteredListToShowAllUnfinishedTasks();
            return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, editedTask.getName()));
        } catch (UniqueTaskList.DuplicateTaskException dpe) {
            isSuccess = false;
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        } catch (IllegalValueException e) {
            throw new CommandException(e.getMessage());
        }
    }

    protected Task createTask(ReadOnlyTask task) {
        Task newTask = null;
        if (task.isEvent()) {
            try {
                newTask = new Event(task.getName(), ((Event) task).getStartDate(),
                        ((Event) task).getStartTime(), task.getDate(), task.getTime(), task.getDescription(),
                        task.getTag(), task.getVenue(), task.getPriority(), task.isFavorite(),
                        FinishProperty.UNFINISHED);
            } catch (IllegalValueException e) {
                e.printStackTrace();
            }
        } else if (task.isRecurring()) {
            newTask = new RecurringTask(task.getName(), task.getDate(), task.getTime(), task.getDescription(),
                        task.getTag(), task.getVenue(), task.getPriority(), task.isFavorite(),
                        ((RecurringTask) task).getMode());
        } else {
            newTask = new Task(task.getName(), task.getDate(), task.getTime(), task.getDescription(),
                    task.getTag(), task.getVenue(), task.getPriority(), task.isFavorite(),
                    FinishProperty.UNFINISHED);
        }
        return newTask;
    }

    /**
     * Creates and returns a {@code Person} with the details of {@code taskToEdit}
     * edited with {@code editPersonDescriptor}.
     * @throws IllegalValueException
     */
    protected static Task createEditedTask(ReadOnlyTask taskToEdit,
            EditTaskDescriptor editTaskDescriptor) throws IllegalValueException {
        assert taskToEdit != null;

        Name updatedName = editTaskDescriptor.getName().orElseGet(taskToEdit::getName);
        TaskDate updatedDueDate = editTaskDescriptor.getDue().orElseGet(taskToEdit::getDate);
        TaskTime updatedDueTime = editTaskDescriptor.getDueTime().orElseGet(taskToEdit::getTime);
        Description updatedDescription = editTaskDescriptor.getDescription().orElseGet(taskToEdit::getDescription);
        Tag updatedTag = editTaskDescriptor.getTag().orElseGet(taskToEdit::getTag);
        Venue updatedVenue = editTaskDescriptor.getVenue().orElseGet(taskToEdit::getVenue);
        Priority updatedPriority = editTaskDescriptor.getPriority().orElseGet(taskToEdit::getPriority);
        FinishProperty isFinished = taskToEdit.getFinished();
        boolean isFavourite;
        if (editTaskDescriptor.getIsFavouriteEdited()) {
            isFavourite = editTaskDescriptor.getFavourite();
        } else {
            isFavourite = taskToEdit.isFavorite();
        }
        if (taskToEdit.isRecurring() || editTaskDescriptor.getRecurringMode() != null) {
            RecurringMode mode;
            if (editTaskDescriptor.getRecurringMode() != null) {
                mode = editTaskDescriptor.getRecurringMode();
            } else {
                mode = ((RecurringTask) taskToEdit).getMode();
            }
            return new RecurringTask(updatedName, updatedDueDate, updatedDueTime,
                    updatedDescription, updatedTag, updatedVenue, updatedPriority, isFavourite, mode);
        } else if (editTaskDescriptor.updatedEvent(editTaskDescriptor.getStart()) || taskToEdit.isEvent()) {
            if (taskToEdit.isEvent() && !(editTaskDescriptor.getStart().isPresent() &&
                    editTaskDescriptor.getStart().get().getValue().isEmpty())) {
                TaskDate updatedStartDate = editTaskDescriptor.getStart()
                        .orElseGet(((ReadOnlyEvent) taskToEdit)::getStartDate);
                TaskTime updatedStartTime = editTaskDescriptor.getStartTime()
                        .orElseGet(((ReadOnlyEvent) taskToEdit)::getStartTime);
                return new Event(updatedName, updatedStartDate, updatedStartTime, updatedDueDate, updatedDueTime,
                        updatedDescription, updatedTag, updatedVenue, updatedPriority, isFavourite, isFinished);
            } else if (!taskToEdit.isEvent() && (editTaskDescriptor.getStart().isPresent() &&
                    !editTaskDescriptor.getStart().get().getValue().isEmpty())) {
                TaskDate updatedStartDate = editTaskDescriptor.getStart().orElse(new TaskDate(""));
                TaskTime updatedStartTime = editTaskDescriptor.getStartTime().orElse(new TaskTime(""));
                return new Event (updatedName, updatedStartDate, updatedStartTime, updatedDueDate, updatedDueTime,
                        updatedDescription, updatedTag, updatedVenue, updatedPriority, isFavourite, isFinished);
            } else {
                return new Task(updatedName, updatedDueDate, updatedDueTime, updatedDescription,
                        updatedTag, updatedVenue, updatedPriority, isFavourite, isFinished);
            }
        } else {
            return new Task(updatedName, updatedDueDate, updatedDueTime, updatedDescription,
                    updatedTag, updatedVenue, updatedPriority, isFavourite, isFinished);
        }
    }

    /**
     * Stores the details to edit the task with. Each non-empty field value will replace the
     * corresponding field value of the task.
     */
    public static class EditTaskDescriptor {
        private Optional<Name> name = Optional.empty();
        private Optional<TaskDate> due = Optional.empty();
        private Optional<TaskTime> dueTime = Optional.empty();
        private Optional<TaskDate> start = Optional.empty();
        private Optional<TaskTime> startTime = Optional.empty();
        private Optional<Description> description = Optional.empty();
        private Optional<Tag> tag = Optional.empty();
        private Optional<Venue> venue = Optional.empty();
        private Optional<Priority> priority = Optional.empty();
        private RecurringMode recurringMode;
        private boolean isFavourite;

        private boolean isFavouriteEdited;

        public EditTaskDescriptor() {}

        public EditTaskDescriptor(EditTaskDescriptor toCopy) {
            this.name = toCopy.getName();
            this.due = toCopy.getDue();
            this.dueTime = toCopy.getDueTime();
            this.start = toCopy.getStart();
            this.startTime = toCopy.getStartTime();
            this.description = toCopy.getDescription();
            this.tag = toCopy.getTag();
            this.venue = toCopy.getVenue();
            this.priority = toCopy.getPriority();
            this.isFavourite = toCopy.getFavourite();
            this.isFavouriteEdited = toCopy.getIsFavouriteEdited();
            this.recurringMode = toCopy.getRecurringMode();
        }

        /**
         * Returns true if at least one field is edited.
         */
        public boolean isAnyFieldEdited() {
            return CollectionUtil.isAnyPresent(
                    this.name, this.due, this.dueTime, this.start, this.startTime,
                    this.description, this.tag, this.venue, this.priority) ||
                    this.isFavouriteEdited || (this.recurringMode != null);
        }

        public void setName(Optional<Name> name) {
            assert name != null;
            this.name = name;
        }

        public Optional<Name> getName() {
            return name;
        }

        public void setDue(Optional<TaskDate> due) {
            assert due != null;
            this.due = due;
        }

        public void setStart(Optional<TaskDate> start) {
            assert start != null;
            this.start = start;
        }

        public Optional<TaskDate> getDue() {
            return due;
        }

        public Optional<TaskDate> getStart() {
            return start;
        }

        public void setDueTime(Optional<TaskTime> dueTime) {
            assert dueTime != null;
            this.dueTime = dueTime;
        }

        public void setStartTime(Optional<TaskTime> startTime) {
            assert startTime != null;
            this.startTime = startTime;
        }

        public Optional<TaskTime> getDueTime() {
            return dueTime;
        }

        public Optional<TaskTime> getStartTime() {
            return startTime;
        }

        public void setDescription(Optional<Description> description) {
            assert description != null;
            this.description = description;
        }

        public Optional<Description> getDescription() {
            return description;
        }

        public void setTag(Optional<Tag> tag) {
            assert tag != null;
            this.tag = tag;
        }

        public Optional<Tag> getTag() {
            return tag;
        }

        public void setVenue(Optional<Venue> venue) {
            assert venue != null;
            this.venue = venue;
        }

        public Optional<Venue> getVenue() {
            return venue;
        }

        public void setPriority(Optional<Priority> priority) {
            assert priority != null;
            this.priority = priority;
        }

        public Optional<Priority> getPriority() {
            return priority;
        }

        public void setIsFavourite(boolean isFavourite) {
            if (isFavourite) {
                this.isFavouriteEdited = true;
                this.isFavourite = true;
            }
        }

        protected boolean getFavourite() {
            return this.isFavourite;
        }

        protected boolean getIsFavouriteEdited() {
            return this.isFavouriteEdited;
        }

        public void setIsUnfavourite (boolean isUnFavourite) {
            if (isUnFavourite) {
                this.isFavouriteEdited = true;
                this.isFavourite = false;
            }
        }

        public boolean updatedEvent(Optional<TaskDate> start) {
            return start.isPresent();
        }

```
###### /java/seedu/address/logic/commands/FinishCommand.java
``` java
package seedu.address.logic.commands;

import java.util.List;

import seedu.address.commons.core.Messages;
import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.model.tag.Tag;
import seedu.address.model.task.Description;
import seedu.address.model.task.Event;
import seedu.address.model.task.Name;
import seedu.address.model.task.Priority;
import seedu.address.model.task.ReadOnlyTask;
import seedu.address.model.task.ReadOnlyTask.FinishProperty;
import seedu.address.model.task.RecurringEvent;
import seedu.address.model.task.RecurringTask;
import seedu.address.model.task.Task;
import seedu.address.model.task.TaskDate;
import seedu.address.model.task.TaskTime;
import seedu.address.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.address.model.task.UniqueTaskList.TaskNotFoundException;
import seedu.address.model.task.Venue;

/**
 * Finishes an unfinished task/event/recurring task in Dueue.
 */
public class FinishCommand extends AbleUndoCommand {

    public static final String COMMAND_WORD = "finish";

    public static final String COMMAND_FINISH = "finish command";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Marks the task identified by the index number used in the last task listing as finished.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_FINISH_TASK_SUCCESS = "Mark finished task: %1$s";
    public static final String MESSAGE_FINISH_TASK_MARKED = "Task had already been finished";
    public static final String MESSAGE_WRONG_TASK_INDEX = "This task already exists in the task manager.";

    public final int targetIndex;
    private boolean isSuccess;
    private boolean isDeleted;
    private Task task;
    private Task replaceTask;

    public FinishCommand(int targetIndex) {
        this.targetIndex = targetIndex;
        this.isSuccess = false;
        this.isDeleted = false;
    }


    @Override
    public CommandResult execute() throws CommandException {

        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToMark = lastShownList.get(targetIndex - 1);

        ReadOnlyTask editedTask = null;

        if (taskToMark.isFinished()) {
            throw new CommandException(MESSAGE_FINISH_TASK_MARKED);
        } else if (taskToMark.isRecurring()) {
            try {
                if (taskToMark.isEvent()) {
                    this.task = new RecurringEvent(taskToMark);
                    editedTask = new RecurringEvent(taskToMark);
                    ((RecurringEvent) editedTask).finishOnce();
                    this.replaceTask = new RecurringEvent(editedTask);
                } else {
                    this.task = new RecurringTask(taskToMark);
                    editedTask = new RecurringTask(taskToMark);
                    ((RecurringTask) editedTask).finishOnce();
                    this.replaceTask = new RecurringTask(editedTask);
                }
            } catch (IllegalValueException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        } else {
            Name updatedName = taskToMark.getName();
            TaskDate updatedDueDate = taskToMark.getDate();
            TaskTime updatedDueTime = taskToMark.getTime();
            Description updatedDescription = taskToMark.getDescription();
            Tag updatedTag = taskToMark.getTag();
            Venue updatedVenue = taskToMark.getVenue();
            Priority updatedPriority = taskToMark.getPriority();
            boolean updatedFavorite = taskToMark.isFavorite();
            FinishProperty updatedFinish = FinishProperty.FINISHED;

            if (taskToMark.isEvent()) {
                TaskDate updatedStartDate = ((Event) taskToMark).getStartDate();
                TaskTime updatedStartTime = ((Event) taskToMark).getStartTime();
                try {
                    this.task = new Event(taskToMark);
                    editedTask = new Event(updatedName, updatedStartDate, updatedStartTime,
                            updatedDueDate, updatedDueTime, updatedDescription, updatedTag,
                            updatedVenue, updatedPriority, updatedFavorite, updatedFinish);
                    this.replaceTask = new Event(editedTask);
                } catch (IllegalValueException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            } else {
                this.task = new Task(taskToMark);
                editedTask  = new Task(
                        updatedName, updatedDueDate, updatedDueTime, updatedDescription,
                        updatedTag, updatedVenue, updatedPriority, updatedFavorite, updatedFinish);
                this.replaceTask = new Task(editedTask);
            }
        }

        try {
            model.updateTask(targetIndex - 1, editedTask);
            isSuccess = true;
        } catch (DuplicateTaskException e) {
            this.isSuccess = false;
            try {
                model.deleteTask(taskToMark);
                isSuccess = true;
                isDeleted = true;
            } catch (TaskNotFoundException e1) {
                assert false : "The target person cannot be missing";
            }
        }

        return new CommandResult(String.format(MESSAGE_FINISH_TASK_SUCCESS, taskToMark));
    }

    @Override
    public boolean isUndoable() {
        return true;
    }


    @Override
    public CommandResult executeUndo(String message) throws CommandException {
        if (!isDeleted) {
            try {
                model.deleteTask(replaceTask);
            } catch (TaskNotFoundException e) {
                assert false : "The target task cannot be missing";
            }
        }
        try {
            model.addTask(task);
            isDeleted = false;
            if (task.isEvent()) {
                try {
                    Task temp = new Event(task);
                    this.task = new Event(replaceTask);
                    this.replaceTask = new Event(temp);
                } catch (IllegalValueException e) {
                    assert false : "The event must be valid";
                }
            } else if (task.isRecurring()) {
                Task temp = new RecurringTask(task);
                this.task = new RecurringTask(replaceTask);
                this.replaceTask = new RecurringTask(temp);
            } else {
                Task temp = new Task(task);
                this.task = new Task(replaceTask);
                this.replaceTask = new Task(temp);
            }
        } catch (DuplicateTaskException e) {
            assert false : "There must not be duplicated task";
        }
        model.updateFilteredListToShowAllUnfinishedTasks();
        this.isSuccess = true;
        return new CommandResult(CommandFormatter.undoMessageFormatter(message, getUndoCommandWord()));
    }


    @Override
    public Command getUndoCommand() throws IllegalValueException {
        if (isSuccess) {
            return this;
        } else {
            return new IncorrectCommand(null);
        }
    }

    @Override
    public String getUndoCommandWord() {
        return COMMAND_WORD + COMMAND_SUFFIX;
    }

}

```
###### /java/seedu/address/logic/commands/ListCommand.java
``` java
package seedu.address.logic.commands;

import java.util.HashSet;
import java.util.Set;

/**
 * Lists all unfinished tasks in Dueue or in a specified list.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";

    public static final String MESSAGE_LIST_SUCCESS = "Listed unfinished tasks";
    public static final String MESSAGE_LIST_DOES_NOT_EXIST = "Given list name does not exist";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": List tasks as per the parameters\n"
            + "the specified listname and displays them as a list with index numbers.\n"
            + "Parameters: [all/favorite/finished] [LIST_NAME]\n"
            + "Example: " + COMMAND_WORD + "\n"
            + COMMAND_WORD + " all study\n"
            + COMMAND_WORD + " finished\n";

    private final Set<String> keywords;

    public ListCommand(Set<String> keywords) {
        assert !keywords.isEmpty();
        this.keywords = keywords;
    }

    public ListCommand() {
        keywords = new HashSet<String>();
    }

    @Override
    public CommandResult execute() {
        assert keywords != null;
        if (keywords.isEmpty()) {
            model.updateFilteredListToShowAllUnfinishedTasks();
            LOGGER.info(getClass() + " listed all unfinished tasks");
            return new CommandResult(MESSAGE_LIST_SUCCESS);
        } else if (!model.isListExist(keywords)) {
            LOGGER.info(getClass() + " all the listnames given are not found");
            return new CommandResult(MESSAGE_LIST_DOES_NOT_EXIST);
        } else {
            model.updateFilteredTaskListGivenListName(keywords);
            LOGGER.info(getClass() + " listed all unfinished tasks in the given lists");
            return new CommandResult(CommandFormatter.listFormatter(MESSAGE_LIST_SUCCESS, keywords));
        }
    }

```
###### /java/seedu/address/logic/commands/ListCommand.java
``` java
    @Override
    public boolean isUndoable() {
        return false;
    }
}
```
###### /java/seedu/address/logic/commands/RedoCommand.java
``` java
package seedu.address.logic.commands;

import java.util.Stack;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.exceptions.CommandException;

/**
 * Redo the previous undone command in Dueue.
 */
public class RedoCommand extends AbleUndoCommand {

    public static final String COMMAND_WORD = "redo";

    public static final String MESSAGE_SUCCESS = "Redo last task successfully.";

    public static final String MESSAGE_UNSUCCESS = "No task to redo";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": List tasks as per the parameters\n"
            + "the specified listname/list index and displays them as a list with index numbers.\n"
            + "Parameters: [LISTNAME/LISTINDEX]\n"
            + "Example: " + COMMAND_WORD + " CS2103";

    private AbleUndoCommand undoCommand;
    private boolean canUndo = false;

    public RedoCommand(Stack<AbleUndoCommand> undoCommandList) {
        do {
            if (!undoCommandList.isEmpty()) {
                try {
                    this.undoCommand = (AbleUndoCommand) undoCommandList.pop().getUndoCommand();
                } catch (IllegalValueException e) {
                    e.printStackTrace();
                }
                if (!this.undoCommand.COMMAND_WORD.equals(IncorrectCommand.COMMAND_WORD)) {
                    this.canUndo = false;
                } else {
                    this.canUndo = true;
                }
            }
        } while(canUndo);

    }

    @Override
    public CommandResult execute() throws CommandException {
        if (this.undoCommand == null) {
            throw new CommandException(MESSAGE_UNSUCCESS);
        } else {
            this.undoCommand.setData(model);
            return this.undoCommand.executeUndo(MESSAGE_SUCCESS);
        }
    }

    @Override
    public boolean isUndoable() {
        return true;
    }

    @Override
    public CommandResult executeUndo(String message) throws CommandException {
        return null;
    }

    @Override
    public Command getUndoCommand() throws IllegalValueException {
        return this.undoCommand.getUndoCommand();
    }

    @Override
    public String getUndoCommandWord() {
        return COMMAND_WORD + COMMAND_SUFFIX;
    }

}

```
###### /java/seedu/address/logic/commands/UndoCommand.java
``` java
package seedu.address.logic.commands;

import java.util.Stack;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.exceptions.CommandException;

/**
 * Undo the previous undoable command in Dueue.
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_SUCCESS = "Undo last task successfully.";

    public static final String MESSAGE_UNSUCCESS = "No task to undo";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": List tasks as per the parameters\n"
            + "the specified listname/list index and displays them as a list with index numbers.\n"
            + "Parameters: [LISTNAME/LISTINDEX]\n"
            + "Example: " + COMMAND_WORD + " CS2103";

    private AbleUndoCommand undoCommand;
    private boolean canUndo = false;
    private Stack<AbleUndoCommand> undoCommandList;

    public UndoCommand(Stack<AbleUndoCommand> commandList, Stack<AbleUndoCommand> undoCommandList) {
        do {
            if (!commandList.isEmpty()) {
                try {
                    if (this.undoCommand.COMMAND_WORD.equals(RedoCommand.COMMAND_WORD)) {
                        undoCommandList.clear();
                    }
                    this.undoCommand = (AbleUndoCommand) commandList.pop().getUndoCommand();
                    this.undoCommandList = undoCommandList;
                } catch (IllegalValueException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
                if (!this.undoCommand.COMMAND_WORD.equals(IncorrectCommand.COMMAND_WORD)) {
                    this.canUndo = false;
                } else {
                    this.canUndo = true;
                }
            }
        } while(canUndo);
    }

    @Override
    public CommandResult execute() throws CommandException {
        if (this.undoCommand == null) {
            throw new CommandException(MESSAGE_UNSUCCESS);
        } else {
            this.undoCommand.setData(model);
            this.undoCommandList.push(this.undoCommand);
            return this.undoCommand.executeUndo(
                    CommandFormatter.undoMessageFormatter(MESSAGE_SUCCESS, this.undoCommand));
        }
    }

    @Override
    public boolean isUndoable() {
        return false;
    }
}
```
###### /java/seedu/address/logic/LogicManager.java
``` java
package seedu.address.logic;

import java.util.Stack;
import java.util.logging.Logger;

import javafx.collections.ObservableList;
import seedu.address.commons.core.ComponentManager;
import seedu.address.commons.core.LogsCenter;
import seedu.address.logic.commands.AbleUndoCommand;
import seedu.address.logic.commands.Command;
import seedu.address.logic.commands.CommandResult;
import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.logic.parser.Parser;
import seedu.address.model.Model;
import seedu.address.model.tag.Tag;
import seedu.address.model.task.ReadOnlyTask;
import seedu.address.storage.Storage;

/**
 * The main LogicManager of the app.
 */
public class LogicManager extends ComponentManager implements Logic {
    private final Logger logger = LogsCenter.getLogger(LogicManager.class);

    private final Model model;
    private final Parser parser;
    private final Stack<AbleUndoCommand> commandList;
    private final Stack<AbleUndoCommand> redoCommandList;

    public LogicManager(Model model, Storage storage) throws CommandException {
        this.model = model;
        this.parser = new Parser();
        this.commandList = new Stack<AbleUndoCommand>();
        this.redoCommandList = new Stack<AbleUndoCommand>();
        execute("list");
    }

    @Override
    public CommandResult execute(String commandText) throws CommandException {
        logger.info("----------------[USER COMMAND][" + commandText + "]");
        Command command = parser.parseCommand(commandText, commandList, redoCommandList);
        command.setData(model);
        if (command.isUndoable()) {
            commandList.push((AbleUndoCommand) command);
        }
        logger.info(command.getClass() + " handles current command");
        return command.execute();
    }

    @Override
    public ObservableList<ReadOnlyTask> getFilteredTaskList() {
        return model.getFilteredTaskList();
    }

    @Override
    public ObservableList<Tag> getFilteredTagList() {
        return model.getFilteredTagList();
    }
}
```
###### /java/seedu/address/logic/parser/AddCommandParser.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.parser.CliSyntax.PREFIX_DATE;
import static seedu.address.logic.parser.CliSyntax.PREFIX_DESCRIPTION;
import static seedu.address.logic.parser.CliSyntax.PREFIX_FAVOURITE;
import static seedu.address.logic.parser.CliSyntax.PREFIX_FREQUENCY;
import static seedu.address.logic.parser.CliSyntax.PREFIX_PRIORITY;
import static seedu.address.logic.parser.CliSyntax.PREFIX_START;
import static seedu.address.logic.parser.CliSyntax.PREFIX_STARTTIME;
import static seedu.address.logic.parser.CliSyntax.PREFIX_TAG;
import static seedu.address.logic.parser.CliSyntax.PREFIX_TIME;
import static seedu.address.logic.parser.CliSyntax.PREFIX_VENUE;

import java.util.NoSuchElementException;
import java.util.Optional;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.AddCommand;
import seedu.address.logic.commands.Command;
import seedu.address.logic.commands.IncorrectCommand;

/**
 * Parses input arguments and creates a new AddCommand object
 */
public class AddCommandParser {

    private static AddCommandParser theOne;

    private AddCommandParser() {
    }

    public static AddCommandParser getInstance() {
        if (theOne == null) {
            theOne = new AddCommandParser();
        }
        return theOne;
    }
    /**
     * Parses the given {@code String} of arguments in the context of the AddCommand
     * and returns an AddCommand object for execution.
     */
    public static Command parse(String args) {
        if (args == null) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
        ArgumentTokenizer argsTokenizer =
                new ArgumentTokenizer(PREFIX_DATE, PREFIX_TIME, PREFIX_TAG, PREFIX_DESCRIPTION,
                        PREFIX_VENUE, PREFIX_PRIORITY, PREFIX_FAVOURITE, PREFIX_START,
                        PREFIX_STARTTIME, PREFIX_FREQUENCY);
        argsTokenizer.tokenize(args);
        try {
            String name = argsTokenizer.getPreamble().get();
            String date = checkString(argsTokenizer.getValue(PREFIX_DATE));
            String startDate = checkString(argsTokenizer.getValue(PREFIX_START));
            String time = checkString(argsTokenizer.getValue(PREFIX_TIME));
            String startTime = checkString(argsTokenizer.getValue(PREFIX_STARTTIME));
            String tag = checkString(argsTokenizer.getValue(PREFIX_TAG));
            String description = checkString(argsTokenizer.getValue(PREFIX_DESCRIPTION));
            String venue = checkString(argsTokenizer.getValue(PREFIX_VENUE));
            String priority = checkString(argsTokenizer.getValue(PREFIX_PRIORITY));
            String frequency = checkString(argsTokenizer.getValue(PREFIX_FREQUENCY));
            boolean isEvent = checkStart(startDate) || checkStart(startTime);
            boolean isFavourite = checkPresent(argsTokenizer.getValue(PREFIX_FAVOURITE));
            boolean isRecurring = !frequency.isEmpty();
            return new AddCommand(name, date, startDate, time, startTime, tag,
                    description, venue, priority, frequency, isFavourite, isEvent, isRecurring);
        } catch (NoSuchElementException ive) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    private static boolean checkStart(String start) {
        return !start.isEmpty();
    }

    private static boolean checkPresent(Optional<String> args) {
        return args.isPresent();
    }

    private static String checkString(Optional<String> args) {
        return args.orElse("");
    }

}
```
###### /java/seedu/address/logic/parser/CliSyntax.java
``` java
package seedu.address.logic.parser;

import java.util.regex.Pattern;

import seedu.address.logic.parser.ArgumentTokenizer.Prefix;

/**
 * Contains Command Line Interface (CLI) syntax definitions common to multiple commands
 */
public class CliSyntax {

    /* Prefix definitions */
    public static final Prefix PREFIX_NAME = new Prefix("n/");
    public static final Prefix PREFIX_DATE = new Prefix("due/");
    public static final Prefix PREFIX_TIME = new Prefix("dueT/");
    public static final Prefix PREFIX_TAG = new Prefix("#");
    public static final Prefix PREFIX_DESCRIPTION = new Prefix("d/");
    public static final Prefix PREFIX_VENUE = new Prefix("@");
    public static final Prefix PREFIX_PRIORITY = new Prefix("p/");
    public static final Prefix PREFIX_FAVOURITE = new Prefix("*f");
    public static final Prefix PREFIX_UNFAVOURITE = new Prefix("*u");
    public static final Prefix PREFIX_START = new Prefix("start/");
    public static final Prefix PREFIX_STARTTIME = new Prefix("startT/");
    public static final Prefix PREFIX_FREQUENCY = new Prefix("f/");
    public static final Prefix PREFIX_ONCE = new Prefix("once/");
    public static final Prefix PREFIX_ALL = new Prefix("all");

    /* Patterns definitions */
    public static final Pattern KEYWORDS_ARGS_FORMAT =
            Pattern.compile("(?<keywords>\\S+(?:\\s+\\S+)*)"); // one or more keywords separated by whitespace

    /* Patterns definitions */
    public static final Pattern KEYWORDS_ARGS_FORMAT_LIST =
            Pattern.compile("(?<keywords>\\S+(?:\\s+\\S+)*)"); // one or more keywords separated by whitespace

}
```
###### /java/seedu/address/logic/parser/DeleteCommandParser.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.parser.CliSyntax.PREFIX_ALL;

import java.util.Optional;

import seedu.address.logic.commands.Command;
import seedu.address.logic.commands.DeleteCommand;
import seedu.address.logic.commands.IncorrectCommand;

/**
 * Parses input arguments and creates a new DeleteCommand object
 */
public class DeleteCommandParser {

    private static DeleteCommandParser theOne;

    private DeleteCommandParser() {
    }

    public static DeleteCommandParser getInstance() {
        if (theOne == null) {
            theOne = new DeleteCommandParser();
        }
        return theOne;
    }

    /**
     * Parses the given {@code String} of arguments in the context of the DeleteCommand
     * and returns an DeleteCommand object for execution.
     */
    public static Command parse(String args) {
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_ALL);
        argsTokenizer.tokenize(args);

        if (!argsTokenizer.getPreamble().isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }
        String stringIndex = argsTokenizer.getPreamble().get();
        Optional<Integer> index = ParserUtil.parseIndex(stringIndex);
        Optional<String> isDeleteAll = argsTokenizer.getValue(PREFIX_ALL);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }

        return new DeleteCommand(index.get(), isDeleteAll.isPresent());
    }

}
```
###### /java/seedu/address/logic/parser/EditCommandParser.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.parser.CliSyntax.PREFIX_DATE;
import static seedu.address.logic.parser.CliSyntax.PREFIX_DESCRIPTION;
import static seedu.address.logic.parser.CliSyntax.PREFIX_FAVOURITE;
import static seedu.address.logic.parser.CliSyntax.PREFIX_FREQUENCY;
import static seedu.address.logic.parser.CliSyntax.PREFIX_NAME;
import static seedu.address.logic.parser.CliSyntax.PREFIX_ONCE;
import static seedu.address.logic.parser.CliSyntax.PREFIX_PRIORITY;
import static seedu.address.logic.parser.CliSyntax.PREFIX_START;
import static seedu.address.logic.parser.CliSyntax.PREFIX_STARTTIME;
import static seedu.address.logic.parser.CliSyntax.PREFIX_TAG;
import static seedu.address.logic.parser.CliSyntax.PREFIX_TIME;
import static seedu.address.logic.parser.CliSyntax.PREFIX_UNFAVOURITE;
import static seedu.address.logic.parser.CliSyntax.PREFIX_VENUE;

import java.util.List;
import java.util.Optional;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.Command;
import seedu.address.logic.commands.EditCommand;
import seedu.address.logic.commands.EditCommand.EditTaskDescriptor;
import seedu.address.logic.commands.EditNextCommand;
import seedu.address.logic.commands.IncorrectCommand;

/**
 * Parses input arguments and creates a new EditCommand object
 */
public class EditCommandParser {

    private static EditCommandParser theOne;

    private EditCommandParser() {
    }

    public static EditCommandParser getInstance() {
        if (theOne == null) {
            theOne = new EditCommandParser();
        }
        return theOne;
    }

    /**
     * Parses the given {@code String} of arguments in the context of the EditCommand
     * and returns an EditCommand object for execution.
     */
    public static Command parse(String args) {
        assert args != null;
        ArgumentTokenizer argsTokenizer =
                new ArgumentTokenizer(PREFIX_NAME, PREFIX_DATE, PREFIX_TIME, PREFIX_TAG,
                        PREFIX_DESCRIPTION, PREFIX_VENUE, PREFIX_PRIORITY, PREFIX_FAVOURITE,
                        PREFIX_UNFAVOURITE, PREFIX_START, PREFIX_STARTTIME, PREFIX_FREQUENCY, PREFIX_ONCE);
        argsTokenizer.tokenize(args);
        List<Optional<String>> preambleFields = ParserUtil.splitPreamble(argsTokenizer.getPreamble().orElse(""), 2);

        Optional<Integer> index = preambleFields.get(0).flatMap(ParserUtil::parseIndex);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        EditTaskDescriptor editTaskDescriptor = new EditTaskDescriptor();
        try {
            editTaskDescriptor.setDue(ParserUtil.parseDate(argsTokenizer.getValue(PREFIX_DATE)));
            editTaskDescriptor.setStart(ParserUtil.parseDate(argsTokenizer.getValue(PREFIX_START)));
            editTaskDescriptor.setName(ParserUtil.parseName(argsTokenizer.getValue(PREFIX_NAME)));
            editTaskDescriptor.setDueTime(ParserUtil.parseTime(argsTokenizer.getValue(PREFIX_TIME)));
            editTaskDescriptor.setStartTime(ParserUtil.parseTime(argsTokenizer.getValue(PREFIX_STARTTIME)));
            editTaskDescriptor.setTag(ParserUtil.parseTag(argsTokenizer.getValue(PREFIX_TAG)));
            editTaskDescriptor.setDescription(ParserUtil.parseDescription(argsTokenizer.getValue(PREFIX_DESCRIPTION)));
            editTaskDescriptor.setVenue(ParserUtil.parseVenue(argsTokenizer.getValue(PREFIX_VENUE)));
            editTaskDescriptor.setPriority(ParserUtil.parsePriority(argsTokenizer.getValue(PREFIX_PRIORITY)));
            editTaskDescriptor.setIsFavourite(ParserUtil.isFavourite(argsTokenizer.getValue(PREFIX_FAVOURITE)));
            editTaskDescriptor.setIsUnfavourite(ParserUtil.isUnfavourite(argsTokenizer.getValue(PREFIX_UNFAVOURITE)));
            editTaskDescriptor.setRecurringMode(ParserUtil.parseString(argsTokenizer.getValue(PREFIX_FREQUENCY)));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }

        if (!editTaskDescriptor.isAnyFieldEdited()) {
            return new IncorrectCommand(EditCommand.MESSAGE_NOT_EDITED);
        }

        Optional<String> once = argsTokenizer.getValue(PREFIX_ONCE);
        if (once.isPresent() && "t".equals(once.get())) {
            return new EditNextCommand(index.get(), editTaskDescriptor);
        }

        return new EditCommand(index.get(), editTaskDescriptor);
    }

}
```
###### /java/seedu/address/logic/parser/FinishCommandParser.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.Optional;

import seedu.address.logic.commands.Command;
import seedu.address.logic.commands.FinishCommand;
import seedu.address.logic.commands.IncorrectCommand;

/**
 * Parses input arguments and creates a new FinishCommand object
 */
public class FinishCommandParser {

    private static FinishCommandParser theOne;

    private FinishCommandParser() {
    }

    public static FinishCommandParser getInstance() {
        if (theOne == null) {
            theOne = new FinishCommandParser();
        }
        return theOne;
    }

    /**
     * Parses the given {@code String} of arguments in the context of the DeleteCommand
     * and returns an DeleteCommand object for execution.
     */
    public static Command parse(String args) {
        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, FinishCommand.MESSAGE_USAGE));
        }

        return new FinishCommand(index.get());
    }

}
```
###### /java/seedu/address/logic/parser/Parser.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.commons.core.Messages.MESSAGE_UNKNOWN_COMMAND;

import java.util.Stack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.address.logic.commands.AbleUndoCommand;
import seedu.address.logic.commands.AddCommand;
import seedu.address.logic.commands.ClearCommand;
import seedu.address.logic.commands.Command;
import seedu.address.logic.commands.DeleteCommand;
import seedu.address.logic.commands.EditCommand;
import seedu.address.logic.commands.ExitCommand;
import seedu.address.logic.commands.FindCommand;
import seedu.address.logic.commands.FinishCommand;
import seedu.address.logic.commands.HelpCommand;
import seedu.address.logic.commands.IncorrectCommand;
import seedu.address.logic.commands.ListCommand;
import seedu.address.logic.commands.LoadCommand;
import seedu.address.logic.commands.RedoCommand;
import seedu.address.logic.commands.ScrollToCommand;
import seedu.address.logic.commands.UndoCommand;
import seedu.address.logic.commands.ViewNextCommand;

/**
 * Parses user input.
 */
public class Parser {

    /**
     * Used for initial separation of command word and args.
     */
    private static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile("(?<commandWord>\\S+)(?<arguments>.*)");

    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput, Stack<AbleUndoCommand> commandList,
            Stack<AbleUndoCommand> undoCommandList) {
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group("commandWord");
        final String arguments = matcher.group("arguments");
        switch (commandWord) {

        case UndoCommand.COMMAND_WORD:
            return new UndoCommand(commandList, undoCommandList);

        case RedoCommand.COMMAND_WORD:
            return new RedoCommand(undoCommandList);

        case AddCommand.COMMAND_WORD:
            undoCommandList.clear();
            return AddCommandParser.parse(arguments);

        case ExitCommand.COMMAND_WORD:
            return new ExitCommand();

        case EditCommand.COMMAND_WORD:
            undoCommandList.clear();
            return EditCommandParser.parse(arguments);

        case DeleteCommand.COMMAND_WORD:
            undoCommandList.clear();
            return DeleteCommandParser.parse(arguments);

        case FinishCommand.COMMAND_WORD:
            undoCommandList.clear();
            return FinishCommandParser.parse(arguments);

        case ClearCommand.COMMAND_WORD:
            undoCommandList.clear();
            return new ClearCommand();

        case FindCommand.COMMAND_WORD:
            return FindCommandParser.parse(arguments);

        case LoadCommand.COMMAND_WORD:
            return LoadCommandParser.parse(arguments);

        case ListCommand.COMMAND_WORD:
            return ListCommandParser.parse(arguments);

        case ScrollToCommand.COMMAND_WORD:
            return ScrollToCommandParser.parse(arguments);

        case HelpCommand.COMMAND_WORD:
            return HelpCommandParser.parse(arguments);

        case ViewNextCommand.COMMAND_WORD:
            return ViewCommandParser.parse(arguments);

        default:
            return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
        }
    }
}
```
###### /java/seedu/address/logic/parser/ParserUtil.java
``` java
package seedu.address.logic.parser;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.commons.util.StringUtil;
import seedu.address.model.tag.Tag;
import seedu.address.model.task.Description;
import seedu.address.model.task.Name;
import seedu.address.model.task.Priority;
import seedu.address.model.task.TaskDate;
import seedu.address.model.task.TaskTime;
import seedu.address.model.task.Venue;

/**
 * Contains utility methods used for parsing strings in the various *Parser classes
 */
public class ParserUtil {

    private static final Pattern INDEX_ARGS_FORMAT = Pattern.compile("(?<targetIndex>.+)");

    /**
     * Returns the specified index in the {@code command} if it is a positive unsigned integer
     * Returns an {@code Optional.empty()} otherwise.
     */
    public static Optional<Integer> parseIndex(String command) {
        final Matcher matcher = INDEX_ARGS_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String index = matcher.group("targetIndex");
        if (!StringUtil.isUnsignedInteger(index)) {
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(index));

    }

    /**
     * Returns a new Set populated by all elements in the given list of strings
     * Returns an empty set if the given {@code Optional} is empty,
     * or if the list contained in the {@code Optional} is empty
     */
    public static Set<String> toSet(Optional<List<String>> list) {
        List<String> elements = list.orElse(Collections.emptyList());
        return new HashSet<>(elements);
    }

    /**
    * Splits a preamble string into ordered fields.
    * @return A list of size {@code numFields} where the ith element is the ith field value if specified in
    *         the input, {@code Optional.empty()} otherwise.
    */
    public static List<Optional<String>> splitPreamble(String preamble, int numFields) {
        return Arrays.stream(Arrays.copyOf(preamble.split("\\s+", numFields), numFields))
                .map(Optional::ofNullable)
                .collect(Collectors.toList());
    }

    /**
     * Parses a {@code Optional<String> name} into an {@code Optional<Name>} if {@code name} is present.
     */
    public static Optional<String> parseString(Optional<String> name) throws IllegalValueException {
        assert name != null;
        return name.isPresent() ? name : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> name} into an {@code Optional<Name>} if {@code name} is present.
     */
    public static Optional<Name> parseName(Optional<String> name) throws IllegalValueException {
        assert name != null;
        return name.isPresent() ? Optional.of(new Name(name.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> phone} into an {@code Optional<Phone>} if {@code phone} is present.
     */
    public static Optional<TaskDate> parseDate(Optional<String> date) throws IllegalValueException {
        assert date != null;
        return date.isPresent() ? Optional.of(new TaskDate(date.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> address} into an {@code Optional<Address>} if {@code address} is present.
     */
    public static Optional<TaskTime> parseTime(Optional<String> time) throws IllegalValueException {
        assert time != null;
        return time.isPresent() ? Optional.of(new TaskTime(time.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> email} into an {@code Optional<Email>} if {@code email} is present.
     */
    public static Optional<Tag> parseTag(Optional<String> tag) throws IllegalValueException {
        assert tag != null;
        return tag.isPresent() ? Optional.of(new Tag(tag.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> email} into an {@code Optional<Email>} if {@code email} is present.
     */
    public static Optional<Description> parseDescription(Optional<String> description) throws IllegalValueException {
        assert description != null;
        return description.isPresent() ? Optional.of(new Description(description.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> email} into an {@code Optional<Email>} if {@code email} is present.
     */
    public static Optional<Venue> parseVenue(Optional<String> venue) throws IllegalValueException {
        assert venue != null;
        return venue.isPresent() ? Optional.of(new Venue(venue.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> email} into an {@code Optional<Email>} if {@code email} is present.
     */
    public static Optional<Priority> parsePriority(Optional<String> priority) throws IllegalValueException {
        assert priority != null;
        return priority.isPresent() ? Optional.of(new Priority(priority.get())) : Optional.empty();
    }

    public static boolean isFavourite(Optional<String> isFavourite) {
        return isFavourite.isPresent();
    }

    public static boolean isUnfavourite(Optional<String> isUnfavourite) {
        return isUnfavourite.isPresent();
    }
}
```
###### /java/seedu/address/storage/XmlAdaptedTask.java
``` java
package seedu.address.storage;

import javax.xml.bind.annotation.XmlElement;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.tag.Tag;
import seedu.address.model.task.Description;
import seedu.address.model.task.Event;
import seedu.address.model.task.Name;
import seedu.address.model.task.Priority;
import seedu.address.model.task.ReadOnlyEvent;
import seedu.address.model.task.ReadOnlyRecurringTask;
import seedu.address.model.task.ReadOnlyRecurringTask.RecurringMode;
import seedu.address.model.task.ReadOnlyTask;
import seedu.address.model.task.ReadOnlyTask.FinishProperty;
import seedu.address.model.task.RecurringTask;
import seedu.address.model.task.Task;
import seedu.address.model.task.TaskDate;
import seedu.address.model.task.TaskTime;
import seedu.address.model.task.Venue;

/**
 * JAXB-friendly version of the Person.
 */
public class XmlAdaptedTask {

    @XmlElement(required = true)
    protected String name;
    @XmlElement(required = false)
    protected String date;
    @XmlElement(required = false)
    protected String time;
    @XmlElement(required = false)
    protected String tag;
    @XmlElement(required = false)
    protected String description;
    @XmlElement(required = false)
    protected String venue;
    @XmlElement(required = false)
    protected String priority;
    @XmlElement(required = true)
    protected boolean isFavourite;
    @XmlElement(required = true)
    protected FinishProperty isFinished;
    @XmlElement(required = true)
    protected boolean isEvent;
    @XmlElement(required = true)
    private String startDate;
    @XmlElement(required = false)
    private String startTime;
    @XmlElement(required = true)
    protected boolean isRecurring;
    @XmlElement(required = false)
    private String recurringMode;

    /**
     * Constructs an XmlAdaptedPerson.
     * This is the no-arg constructor that is required by JAXB.
     */
    public XmlAdaptedTask() {}


    /**
     * Converts a given Person into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedPerson
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        name = source.getName().fullName;
        date = source.getDate().getValue();
        time = source.getTime().getValue();
        tag = source.getTag().tagName;
        description = source.getDescription().getValue();
        venue = source.getVenue().getValue();
        priority = source.getPriority().getValue();
        isFavourite = source.isFavorite();
        isFinished = source.getFinished();
        isEvent = source.isEvent();
        isRecurring = source.isRecurring();
        if (isEvent) {
            startDate = ((ReadOnlyEvent) source).getStartDate().getValue();
            startTime = ((ReadOnlyEvent) source).getStartTime().getValue();
        }
        if (isRecurring) {
            recurringMode = ((ReadOnlyRecurringTask) source).getRecurringPeriod();
        }
    }

    /**
     * Converts this jaxb-friendly adapted person object into the model's Person object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted person
     */
    public Task toModelType() throws IllegalValueException {
        final Name name = new Name(this.name);
        final TaskDate date = new TaskDate(this.date);
        final TaskTime time = new TaskTime(this.time);
        final Description description = new Description(this.description);
        final Tag tag = new Tag(this.tag);
        final Venue venue = new Venue(this.venue);
        final Priority priority = new Priority(this.priority);
        if (this.isEvent) {
            final TaskDate startDate = new TaskDate(this.startDate);
            final TaskTime startTime = new TaskTime(this.startTime);

            return new Event(name, startDate, startTime, date, time, description, tag, venue, priority,
                    isFavourite, isFinished);
        } else if (isRecurring) {
            final RecurringMode recurring;
            if (recurringMode.contains("day")) {
                recurring = RecurringMode.DAY;
            } else if (recurringMode.contains("week")) {
                recurring = RecurringMode.WEEK;
            } else if (recurringMode.contains("month")) {
                recurring = RecurringMode.MONTH;
            } else {
                recurring = null;
            }
            return new RecurringTask(name, date, time, description, tag, venue, priority,
                    isFavourite, isFinished, recurring);
        } else {
            return new Task(name, date, time, description, tag,
                    venue, priority, isFavourite, isFinished);
        }
    }

    public String getTagName() {
        return this.tag;
    }
}
```
###### /java/seedu/address/storage/XmlSerializableTaskManager.java
``` java
package seedu.address.storage;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import seedu.address.commons.core.UnmodifiableObservableList;
import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.ReadOnlyTaskManager;
import seedu.address.model.tag.Tag;
import seedu.address.model.task.ReadOnlyTask;
import seedu.address.model.task.Task;



/**
 * An Immutable TaskManager that is serializable to XML format
 */
@XmlRootElement(name = "taskmanager")
public class XmlSerializableTaskManager implements ReadOnlyTaskManager {

    @XmlElement
    private List<XmlAdaptedTask> tasks;
    @XmlElement
    private List<XmlAdaptedTag> tags;

    /**
     * Creates an empty XmlSerializableTaskManager.
     * This empty constructor is required for marshalling.
     */
    public XmlSerializableTaskManager() {
        tasks = new ArrayList<>();
        tags = new ArrayList<>();
    }

    /**
     * Conversion
     */
    public XmlSerializableTaskManager(ReadOnlyTaskManager src) {
        this();
        tasks.addAll(src.getTaskList().stream().map(XmlAdaptedTask::new).collect(Collectors.toList()));
        tags.addAll(src.getTagList().stream().map(XmlAdaptedTag::new).collect(Collectors.toList()));
    }

    @Override
    public ObservableList<ReadOnlyTask> getTaskList() {
        final ObservableList<Task> task = this.tasks.stream().map(p -> {
            try {
                if (p.isEvent == true) {
                    //TODO: What to do here???
                }
                return p.toModelType();
            } catch (IllegalValueException e) {
                e.printStackTrace();
                //TODO: better error handling
                return null;
            }
        }).collect(Collectors.toCollection(FXCollections::observableArrayList));
        return new UnmodifiableObservableList<>(task);
    }

    @Override
    public ObservableList<Tag> getTagList() {
        final ObservableList<Tag> tags = this.tags.stream().map(t -> {
            try {
                return t.toModelType();
            } catch (IllegalValueException e) {
                e.printStackTrace();
                //TODO: better error handling
                return null;
            }
        }).collect(Collectors.toCollection(FXCollections::observableArrayList));
        return new UnmodifiableObservableList<>(tags);
    }

}
```
###### /java/seedu/address/storage/XmlTaskManagerStorage.java
``` java
package seedu.address.storage;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Optional;
import java.util.logging.Logger;

import seedu.address.commons.core.LogsCenter;
import seedu.address.commons.exceptions.DataConversionException;
import seedu.address.commons.util.FileUtil;
import seedu.address.model.ReadOnlyTaskManager;

/**
 * A class to access AddressBook data stored as an xml file on the hard disk.
 */
public class XmlTaskManagerStorage implements TaskManagerStorage {

    private static final Logger logger = LogsCenter.getLogger(XmlTaskManagerStorage.class);

    private String filePath;

    public XmlTaskManagerStorage(String filePath) {
        this.filePath = filePath;
    }

    public String getTaskManagerFilePath() {
        return filePath;
    }

    @Override
    public Optional<ReadOnlyTaskManager> readTaskManager() throws DataConversionException, IOException {
        return readTaskManager(filePath);
    }

    /**
     * Similar to {@link #readAddressBook()}
     * @param filePath location of the data. Cannot be null
     * @throws DataConversionException if the file is not in the correct format.
     * @throws FileNotFoundException
     */
    public Optional<ReadOnlyTaskManager> readTaskManager(String filePath) throws
        DataConversionException, FileNotFoundException {
        assert filePath != null;
        File taskManagerFile = new File(filePath);

        if (!taskManagerFile.exists()) {
            logger.info("TaskManager file "  + taskManagerFile + " not found");
        }
        ReadOnlyTaskManager taskManagerOptional = XmlFileStorage.loadDataFromSaveFile(new File(filePath));

        return Optional.of(taskManagerOptional);
    }

    @Override
    public void saveTaskManager(ReadOnlyTaskManager taskManager) throws IOException {
        saveTaskManager(taskManager, filePath);
    }

    /**
     * Similar to {@link #saveAddressBook(ReadOnlyAddressBook)}
     * @param filePath location of the data. Cannot be null
     */
    public void saveTaskManager(ReadOnlyTaskManager taskManager, String filePath) throws IOException {
        assert taskManager != null;
        assert filePath != null;

        File file = new File(filePath);
        FileUtil.createIfMissing(file);
        XmlFileStorage.saveDataToFile(file, new XmlSerializableTaskManager(taskManager));
    }

}
```
