# A0138474X
###### /java/seedu/address/logic/commands/AbleUndoCommand.java
``` java
package seedu.address.logic.commands;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.exceptions.CommandException;

/**
 * Represents a command with hidden internal logic and the ability to be executed.
 */
public abstract class AbleUndoCommand extends Command {

    public static final String UNDO_COMMAND_WORD = "undo";

    public static final String COMMAND_SUFFIX = " command";

    public static final String MESSAGE_UNDO_TASK_SUCCESS = "Undo last command successful";

    public abstract CommandResult executeUndo(String message) throws CommandException;

    public abstract Command getUndoCommand() throws IllegalValueException;

    public abstract String getUndoCommandWord();

    public abstract String getRedoCommandWord();

}
```
###### /java/seedu/address/logic/commands/AddCommand.java
``` java
package seedu.address.logic.commands;

import seedu.address.commons.core.EventsCenter;
import seedu.address.commons.events.ui.JumpToTaskListRequestEvent;
import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.model.tag.Tag;
import seedu.address.model.task.Description;
import seedu.address.model.task.Event;
import seedu.address.model.task.Name;
import seedu.address.model.task.Priority;
import seedu.address.model.task.ReadOnlyRecurringTask.RecurringMode;
import seedu.address.model.task.ReadOnlyTask;
import seedu.address.model.task.RecurringEvent;
import seedu.address.model.task.RecurringTask;
import seedu.address.model.task.Task;
import seedu.address.model.task.TaskDate;
import seedu.address.model.task.TaskTime;
import seedu.address.model.task.UniqueTaskList;
import seedu.address.model.task.Venue;

/**
 * Adds a task/event/recurring task to Dueue.
 */
public class AddCommand extends AbleUndoCommand {

    public static final String COMMAND_WORD = "add";
    public static final String COMMAND_ADD = COMMAND_WORD + COMMAND_SUFFIX;

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a task to Dueue. \n"
            + "Parameters: NAME [due/DUE_DATE] [dueT/DUE_TIME] [start/START_DATE] [startT/START_TIME]\n"
            + "[#LISTNAME] [d/DESCRIPTION] [@VENUE] [p/PRIORITY_LEVEL] [*f] [f/REPEAT_PERIOD] \n"
            + "Examples: " + COMMAND_WORD
            + " \nTrip to Taiwan due/24/6/2017 start/tmr startT/16:00"
            + " dueT/18:00 p/3 *f\n"
            + COMMAND_WORD
            + " CS2103T Tutorial #CS2103 d/Finish asap p/important\n"
            + COMMAND_WORD
            + " CS2103 Demo f/weekly #CS2103 d/Exhausting module @SoC p/3\n";

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the Dueue";

    private final Task toAdd;
    // indicate whether the command had been executed successfully
    private boolean isSuccess = false;
    // indicate for undoing deleting of occurring Task or Events
    private boolean isDeleteAllOcurrence = true;
    // indicate whether this command is performing undo for another command
    private boolean isUndo = false;

    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */

    public AddCommand(String name, String date, String startDate, String time, String startTime, String tag,
            String description, String venue, String priority, String frequency, boolean isFavourite,
            boolean isEvent, boolean isRecurring) throws IllegalValueException {
        RecurringMode mode = getRecurringMode(frequency);
        if (isEvent && isRecurring) {
            this.toAdd = buildRecurringEvent(name, date, startDate, time, startTime,
                    tag, description, venue, priority, isFavourite, mode);
        } else if (isEvent) {
            this.toAdd = buildEvent(name, date, startDate, time, startTime,
                    tag, description, venue, priority, isFavourite);
        } else if (isRecurring) {
            this.toAdd = buildRecurringTask(name, date, time,
                    tag, description, venue, priority, isFavourite, mode);
        } else {
            this.toAdd = buildTask(name, date, time, tag, description,
                    venue, priority, isFavourite);
        }
    }

    // constructor for undoing a delete command
    public AddCommand(ReadOnlyTask task, boolean isDeleteAllOcurrence) {
        this.toAdd = (Task) task;
        this.isDeleteAllOcurrence = isDeleteAllOcurrence;
        this.isUndo = true;
    }

    //create an event to add to Dueue
    private Event buildEvent(String name, String date, String startDate, String time, String startTime, String tag,
            String description, String venue, String priority, boolean isFavourite) throws IllegalValueException {
        if (!startDate.isEmpty()) {
            return new Event(
                    new Name(name),
                    new TaskDate(startDate),
                    new TaskTime (startTime),
                    new TaskDate(date),
                    new TaskTime(time),
                    new Description(description),
                    new Tag(tag),
                    new Venue(venue),
                    new Priority(priority),
                    isFavourite
                    );
        } else {
            return new Event(
                    new Name(name),
                    new TaskDate(date),
                    new TaskTime (startTime),
                    new TaskTime(time),
                    new Description(description),
                    new Tag(tag),
                    new Venue(venue),
                    new Priority(priority),
                    isFavourite
                    );
        }
    }

    // create a recurring event to add to Dueue
    private Event buildRecurringEvent(String name, String date, String startDate, String time, String startTime,
            String tag, String description, String venue, String priority, boolean isFavourite, RecurringMode mode)
            throws IllegalValueException {
        if (mode == null) {
            return buildEvent(name, date, startDate, time, startTime, tag, description, venue, priority, isFavourite);
        } else {
            if (!startDate.isEmpty()) {
                return new RecurringEvent(
                        new Name(name),
                        new TaskDate(startDate),
                        new TaskTime (startTime),
                        new TaskDate(date),
                        new TaskTime(time),
                        new Description(description),
                        new Tag(tag),
                        new Venue(venue),
                        new Priority(priority),
                        isFavourite,
                        mode
                        );
            } else {
                return new RecurringEvent(
                        new Name(name),
                        new TaskDate(date),
                        new TaskTime (startTime),
                        new TaskTime(time),
                        new Description(description),
                        new Tag(tag),
                        new Venue(venue),
                        new Priority(priority),
                        isFavourite,
                        mode
                        );
            }
        }
    }

    // create a task to add into Dueue
    private Task buildTask(String name, String date, String time, String tag, String description, String venue,
            String priority, boolean isFavourite) throws IllegalValueException {
        return new Task(
                new Name(name),
                new TaskDate(date),
                new TaskTime(time),
                new Description(description),
                new Tag(tag),
                new Venue(venue),
                new Priority(priority),
                isFavourite
                );
    }

    // create a recurring task to add into Dueue
    private Task buildRecurringTask(String name, String date, String time, String tag, String description, String venue,
            String priority, boolean isFavourite, RecurringMode mode) throws IllegalValueException {
        if (mode == null) {
            return buildTask(name, date, time, tag,
                    description, venue, priority, isFavourite);
        } else {
            return new RecurringTask(
                    new Name(name),
                    new TaskDate(date),
                    new TaskTime(time),
                    new Description(description),
                    new Tag(tag),
                    new Venue(venue),
                    new Priority(priority),
                    isFavourite,
                    mode
                    );
        }
    }

    // convert the string to RecurringMode
    private RecurringMode getRecurringMode(String ocurring) {
        if (ocurring.matches(RecurringTask.PERIOD_DAY_REGEX)) {
            return RecurringMode.DAY;
        } else if (ocurring.matches(RecurringTask.PERIOD_WEEK_REGEX)) {
            return RecurringMode.WEEK;
        } else if (ocurring.matches(RecurringTask.PERIOD_MONTH_REGEX)) {
            return RecurringMode.MONTH;
        }
        return null;
    }

    @Override
    public CommandResult execute() throws CommandException {
        return execute(CommandFormatter.undoFormatter(
                String.format(MESSAGE_SUCCESS, toAdd.getName()), COMMAND_ADD));
    }

    public CommandResult execute(String message) throws CommandException {
        assert model != null;
        try {
            model.addTask(toAdd);
            this.isSuccess = true;
            int taskIndex = model.getFilteredTaskList().indexOf(toAdd);
            EventsCenter.getInstance().post(new JumpToTaskListRequestEvent(taskIndex));
            return new CommandResult(message);
        } catch (UniqueTaskList.DuplicateTaskException e) {
            this.isSuccess = false;
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
    }

    @Override
    public boolean isUndoable() {
        return true;
    }

    @Override
    public CommandResult executeUndo(String message) throws CommandException {
        return execute(CommandFormatter.undoMessageFormatter(message, getRedoCommandWord()));
    }

    // return the command that is equivalent to undoing add (DeleteCommand)
    @Override
    public Command getUndoCommand() {
        if (isSuccess) {
            return new DeleteCommand(toAdd, isDeleteAllOcurrence);
        } else {
            return null;
        }
    }

    @Override
    public String getUndoCommandWord() {
        return DeleteCommand.COMMAND_WORD + COMMAND_SUFFIX;
    }

    @Override
    public String getRedoCommandWord() {
        return COMMAND_WORD + COMMAND_SUFFIX;
    }
}
```
###### /java/seedu/address/logic/commands/ClearCommand.java
``` java
package seedu.address.logic.commands;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.model.TaskManager;

/**
 * Clears Dueue.
 */
public class ClearCommand extends AbleUndoCommand {

    public static final String COMMAND_WORD = "clear";
    public static final String COMMAND_CLEAR = "clear command";
    public static final String MESSAGE_SUCCESS = "Dueue has been cleared!";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Clear all tasks in Dueue \n"
            + "Parameters: Nil\n"
            + "Example: " + COMMAND_WORD;

    private TaskManager tasks = TaskManager.getStub();

    @Override
    public CommandResult execute() {
        return execute(MESSAGE_SUCCESS, false);
    }

    public CommandResult execute(String message, Boolean isUndo) {
        assert model != null;
        TaskManager tasks = TaskManager.getStub();
        tasks.resetData(model.getTaskManager());
        model.resetData(this.tasks);
        this.tasks = tasks;
        if (isUndo) {
            return new CommandResult(CommandFormatter.undoMessageFormatter(message, getUndoCommandWord()));
        } else {
            return new CommandResult(CommandFormatter.undoFormatter(message, COMMAND_CLEAR));
        }
    }

    @Override
    public boolean isUndoable() {
        return true;
    }

    @Override
    public CommandResult executeUndo(String message) throws CommandException {
        return execute(message, true);
    }

    @Override
    public Command getUndoCommand() throws IllegalValueException {
        return this;
    }

    @Override
    public String getUndoCommandWord() {
        return COMMAND_WORD + COMMAND_SUFFIX;
    }

    @Override
    public String getRedoCommandWord() {
        return COMMAND_WORD + COMMAND_SUFFIX;
    }
}
```
###### /java/seedu/address/logic/commands/DeleteCommand.java
``` java
package seedu.address.logic.commands;

import seedu.address.commons.core.Messages;
import seedu.address.commons.core.UnmodifiableObservableList;
import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.model.task.ReadOnlyTask;
import seedu.address.model.task.RecurringEvent;
import seedu.address.model.task.RecurringTask;
import seedu.address.model.task.Task;
import seedu.address.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.address.model.task.UniqueTaskList.TaskNotFoundException;


/**
 * Deletes a task identified using it's last displayed index from the Dueue.
 */
public class DeleteCommand extends AbleUndoCommand {

    public static final String COMMAND_WORD = "delete";
    public static final String COMMAND_DELETE = "delete command";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1 [all]";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted task: %1$s";

    public final int targetIndex;

    private ReadOnlyTask task;
    private ReadOnlyTask taskToDelete;
    private ReadOnlyTask replaceTask;
    // indicating whether the command is executed correctly
    private boolean isSuccess = false;
    // indicate to delete all occurrence for occurring task and event
    private boolean isDeleteAllOcurrence;

    public DeleteCommand(int targetIndex, boolean isDeleteAllOcurrence) {
        this.targetIndex = targetIndex;
        this.isDeleteAllOcurrence = isDeleteAllOcurrence;
        this.task = null;
        this.isSuccess = false;
    }

    // constructor for undoing an add command
    public DeleteCommand(ReadOnlyTask task, boolean isDeleteAllOcurrence) {
        this.targetIndex = 0;
        this.isDeleteAllOcurrence = isDeleteAllOcurrence;
        this.taskToDelete = task;
    }


    @Override
    public CommandResult execute() throws CommandException {
        processData();
        return execute(CommandFormatter.undoFormatter(String.format(MESSAGE_DELETE_TASK_SUCCESS, this.taskToDelete)
                , COMMAND_DELETE));
    }

    /*
     * Delete a task
     * If user request to delete a recurring task and did not specify all the recurring task will be finish once
     */
    public CommandResult execute(String message) throws CommandException {
        try {
            if (taskToDelete.isRecurring() && !isDeleteAllOcurrence) {
                try {
                    Task task = (Task) createRecurringTask(taskToDelete);
                    finishOnce(task);
                    this.replaceTask = createRecurringTask(task);
                    isSuccess = true;
                    model.deleteTask(taskToDelete);
                    model.addTask(task);
                    this.task = taskToDelete;
                } catch (DuplicateTaskException e) {
                    e.printStackTrace();
                }
            } else {
                model.deleteTask(taskToDelete);
                this.task = taskToDelete;
                this.isSuccess = true;
            }
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }
        return new CommandResult(message);
    }

    private void finishOnce(ReadOnlyTask deleteTask) {
        if (!deleteTask.isEvent()) {
            ((RecurringTask) deleteTask).finishOnce();
        } else {
            ((RecurringEvent) deleteTask).finishOnce();
        }
    }

    // create a recurring task to be store for undoing the delete
    private ReadOnlyTask createRecurringTask(ReadOnlyTask recurringTask) {
        Task task = null;
        if (recurringTask.isEvent()) {
            try {
                task = new RecurringEvent(recurringTask);
            } catch (IllegalValueException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        } else {
            task =  new RecurringTask(recurringTask);
        }
        return task;
    }

    // get the task to be deleted from the modelManager
    private void processData() throws CommandException {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        taskToDelete = lastShownList.get(targetIndex - 1);
    }

    @Override
    public boolean isUndoable() {
        return true;
    }

    @Override
    public CommandResult executeUndo(String message) throws CommandException {
        return execute(CommandFormatter.undoMessageFormatter(message, COMMAND_WORD + " command"));
    }

    // Get the command that is equivalent to undoing a delete command (AddCommand)
    @Override
    public Command getUndoCommand() {
        if (isSuccess) {
            if (task.isRecurring() && !isDeleteAllOcurrence) {
                try {
                    model.deleteTask(replaceTask);
                } catch (TaskNotFoundException e) {
                    assert false : "this task cannot be invalid";
                }
            }
            return new AddCommand(task, isDeleteAllOcurrence);
        } else {
            return null;
        }
    }

    @Override
    public String getUndoCommandWord() {
        return AddCommand.COMMAND_WORD + COMMAND_SUFFIX;
    }

    @Override
    public String getRedoCommandWord() {
        return COMMAND_WORD + COMMAND_SUFFIX;
    }
}
```
###### /java/seedu/address/logic/commands/EditCommand.java
``` java
package seedu.address.logic.commands;

import java.util.List;

import seedu.address.commons.core.EventsCenter;
import seedu.address.commons.core.Messages;
import seedu.address.commons.events.ui.JumpToTaskListRequestEvent;
import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.model.tag.Tag;
import seedu.address.model.task.Description;
import seedu.address.model.task.Event;
import seedu.address.model.task.Name;
import seedu.address.model.task.Priority;
import seedu.address.model.task.ReadOnlyEvent;
import seedu.address.model.task.ReadOnlyRecurringTask.RecurringMode;
import seedu.address.model.task.ReadOnlyTask;
import seedu.address.model.task.ReadOnlyTask.FinishProperty;
import seedu.address.model.task.RecurringEvent;
import seedu.address.model.task.RecurringTask;
import seedu.address.model.task.Task;
import seedu.address.model.task.TaskDate;
import seedu.address.model.task.TaskTime;
import seedu.address.model.task.UniqueTaskList;
import seedu.address.model.task.UniqueTaskList.TaskNotFoundException;
import seedu.address.model.task.Venue;


/**
 * Edits the details of an existing task in the Dueue.
 */
public class EditCommand extends AbleUndoCommand {

    public static final String COMMAND_WORD = "edit";

    public static final String COMMAND_EDIT = "edit command";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Edits the details of the task identified "
            + "by the index given.\n"
            + "Parameters: INDEX [n/TASK_NAME]\n [due/DUE_DATE] [dueT/DUE_TIME]"
            + "[start/START_DATE] [startT/STAR_TTIME] [#LIST_NAME] "
            + "[d/DESCRIPTION] [@VENUE] [p/PRIORITY_LEVEL] [*f/*u]\n"
            + "Example: " + COMMAND_WORD + " 1 due/17/3/2017 #CS2103T";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited task: %1$s";
    public static final String MESSAGE_NOT_EDITED = "At least one field to edit must be provided.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";

    protected final int filteredTaskListIndex;
    protected final EditTaskDescriptor editTaskDescriptor;
    protected ReadOnlyTask task;
    protected Task oldTask;
    protected boolean isSuccess;
    private boolean isUndo = false;

    /**
     * @param filteredPersonListIndex the index of the task in the filtered task list to edit
     * @param editPersonDescriptor details to edit the task with
     */
    public EditCommand(int filteredTaskListIndex, EditTaskDescriptor editTaskDescriptor) {
        assert filteredTaskListIndex > 0;
        assert editTaskDescriptor != null;

        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex - 1;

        this.editTaskDescriptor = new EditTaskDescriptor(editTaskDescriptor);
        this.isSuccess = false;
    }

    // constructor for undoing edit command
    public EditCommand(ReadOnlyTask task, Task oldTask) {
        this.task = task;
        this.oldTask = oldTask;
        this.filteredTaskListIndex = 0;
        this.editTaskDescriptor = null;
        isUndo = true;
    }

    @Override
    public CommandResult execute() throws CommandException {
        processTask();
        return execute(String.format(MESSAGE_EDIT_TASK_SUCCESS, task.getName()));
    }

    /*
     * update the Task using the index if not undoing a task
     * if undoing a task update by delete and add
     */
    public CommandResult execute(String message) throws CommandException {

        if (!isUndo) {
            try {
                Task editedTask = createEditedTask(task, editTaskDescriptor);
                model.updateTask(filteredTaskListIndex, editedTask);
                isSuccess = true;
                task = editedTask;
                int taskIndex = model.getFilteredTaskList().indexOf(editedTask);
                EventsCenter.getInstance().post(new JumpToTaskListRequestEvent(taskIndex));
            } catch (UniqueTaskList.DuplicateTaskException dpe) {
                isSuccess = false;
                throw new CommandException(MESSAGE_DUPLICATE_TASK);
            } catch (IllegalValueException e) {
                throw new CommandException(e.getMessage());
            }
        } else {
            try {
                model.deleteTask(this.task);
                model.addTask(this.oldTask);
                ReadOnlyTask temp;
                temp = this.task;
                this.task = this.oldTask;
                this.isSuccess = true;
                this.oldTask = (Task) temp;
            } catch (UniqueTaskList.DuplicateTaskException dpe) {
                throw new CommandException(MESSAGE_DUPLICATE_TASK);
            } catch (TaskNotFoundException e) {
                assert false : "The target task cannot be missing";
            }
        }
        model.updateFilteredListToShowAllUnfinishedTasks();
        String displayMessage;
        if (isUndo) {
            displayMessage = CommandFormatter.undoMessageFormatter(message, getUndoCommandWord());
        } else {
            displayMessage = CommandFormatter.undoFormatter(message, COMMAND_EDIT);
        }
        return new CommandResult(displayMessage);
    }

    private void processTask() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        task = lastShownList.get(filteredTaskListIndex);
        oldTask = createTask(task);
    }

    protected Task createTask(ReadOnlyTask task) {
        Task newTask = null;
        if (task.isEvent() && task.isRecurring()) {
            try {
                newTask = new RecurringEvent(task);
            } catch (IllegalValueException e) {
                e.printStackTrace();
            }
        } else if (task.isEvent()) {
            try {
                newTask = new Event(task);
            } catch (IllegalValueException e) {
                e.printStackTrace();
            }
        } else if (task.isRecurring()) {
            newTask = new RecurringTask(task);
        } else {
            newTask = new Task(task);
        }
        return newTask;
    }

    /**
     * Creates and returns a {@code Person} with the details of {@code taskToEdit}
     * edited with {@code editPersonDescriptor}.
     * @throws IllegalValueException
     */
    protected static Task createEditedTask(ReadOnlyTask taskToEdit,
            EditTaskDescriptor editTaskDescriptor) throws IllegalValueException {
        assert taskToEdit != null;

        // get the common detail field
        Name updatedName = editTaskDescriptor.getName().orElseGet(taskToEdit::getName);
        TaskDate updatedDueDate = editTaskDescriptor.getDue().orElseGet(taskToEdit::getDate);
        updatedDueDate = new TaskDate(updatedDueDate.getValue());
        TaskTime updatedDueTime = editTaskDescriptor.getDueTime().orElseGet(taskToEdit::getTime);
        Description updatedDescription = editTaskDescriptor.getDescription().orElseGet(taskToEdit::getDescription);
        Tag updatedTag = editTaskDescriptor.getTag().orElseGet(taskToEdit::getTag);
        Venue updatedVenue = editTaskDescriptor.getVenue().orElseGet(taskToEdit::getVenue);
        Priority updatedPriority = editTaskDescriptor.getPriority().orElseGet(taskToEdit::getPriority);
        FinishProperty isFinished = taskToEdit.getFinished();
        boolean isFavourite;
        // check the fravourite
        if (editTaskDescriptor.getIsFavouriteEdited()) {
            isFavourite = editTaskDescriptor.getFavourite();
        } else {
            isFavourite = taskToEdit.isFavorite();
        }
        // check the RecurringMode
        RecurringMode mode = null;
        if (taskToEdit.isRecurring() || editTaskDescriptor.getRecurringMode() != null) {
            if (editTaskDescriptor.getRecurringMode() != null) {
                mode = editTaskDescriptor.getRecurringMode();
            } else {
                if (taskToEdit.isEvent()) {
                    mode = ((RecurringEvent) taskToEdit).getMode();
                } else {
                    mode = ((RecurringTask) taskToEdit).getMode();
                }
            }
        }
        /*
         *If the Task is an Event or the user specify the startDate or startTime
         *Then get the Event property
         *Else it is a task
         */
        if (editTaskDescriptor.updatedEvent(editTaskDescriptor.getStart()) || taskToEdit.isEvent()) {

            // if the task is an event and the user wants to keep it as an event or the user edit it to become an event
            if (taskToEdit.isEvent() && !(editTaskDescriptor.getStart().isPresent() &&
                    editTaskDescriptor.getStart().get().getValue().isEmpty())) {

                TaskDate updatedStartDate = editTaskDescriptor.getStart()
                        .orElseGet(((ReadOnlyEvent) taskToEdit)::getStartDate);
                TaskTime updatedStartTime = editTaskDescriptor.getStartTime()
                        .orElseGet(((ReadOnlyEvent) taskToEdit)::getStartTime);

                // if the Event is recurring or the user edit it to become recurring
                if (taskToEdit.isRecurring() || editTaskDescriptor.getRecurringMode() != null) {
                    return new RecurringEvent(updatedName, updatedStartDate, updatedStartTime, updatedDueDate,
                            updatedDueTime, updatedDescription, updatedTag, updatedVenue, updatedPriority,
                            isFavourite, isFinished, mode);
                } else {
                    return new Event(updatedName, updatedStartDate, updatedStartTime, updatedDueDate, updatedDueTime,
                            updatedDescription, updatedTag, updatedVenue, updatedPriority, isFavourite, isFinished);
                }

            } else {
                // the user wants to convert a event into a task

                // if the Task is recurring or the user edit it to become recurring
                if (taskToEdit.isRecurring() || editTaskDescriptor.getRecurringMode() != null) {
                    return new RecurringTask(updatedName, updatedDueDate, updatedDueTime, updatedDescription,
                            updatedTag, updatedVenue, updatedPriority, isFavourite, isFinished, mode);
                } else {
                    return new Task(updatedName, updatedDueDate, updatedDueTime, updatedDescription,
                            updatedTag, updatedVenue, updatedPriority, isFavourite, isFinished);
                }
            }
        } else {
            // if the Task is recurring or the user edit it to become recurring
            if ((taskToEdit.isRecurring() || editTaskDescriptor.getRecurringMode() != null) && !taskToEdit.isEvent()) {
                return new RecurringTask(updatedName, updatedDueDate, updatedDueTime,
                        updatedDescription, updatedTag, updatedVenue, updatedPriority, isFavourite, mode);
            } else {
                return new Task(updatedName, updatedDueDate, updatedDueTime, updatedDescription,
                        updatedTag, updatedVenue, updatedPriority, isFavourite, isFinished);
            }
        }
    }

    @Override
    public boolean isUndoable() {
        return true;
    }

    @Override
    public CommandResult executeUndo(String message) throws CommandException {
        return execute(message);
    }

    // get the edit command to undo this edit command
    @Override
    public Command getUndoCommand() {
        if (isSuccess) {
            return new EditCommand(this.task, this.oldTask);
        } else {
            return null;
        }
    }

    @Override
    public String getUndoCommandWord() {
        return COMMAND_WORD + COMMAND_SUFFIX;
    }

    @Override
    public String getRedoCommandWord() {
        return COMMAND_WORD + COMMAND_SUFFIX;
    }
}
```
###### /java/seedu/address/logic/commands/FinishCommand.java
``` java
package seedu.address.logic.commands;

import java.util.List;

import seedu.address.commons.core.Messages;
import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.model.tag.Tag;
import seedu.address.model.task.Description;
import seedu.address.model.task.Event;
import seedu.address.model.task.Name;
import seedu.address.model.task.Priority;
import seedu.address.model.task.ReadOnlyTask;
import seedu.address.model.task.ReadOnlyTask.FinishProperty;
import seedu.address.model.task.RecurringEvent;
import seedu.address.model.task.RecurringTask;
import seedu.address.model.task.Task;
import seedu.address.model.task.TaskDate;
import seedu.address.model.task.TaskTime;
import seedu.address.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.address.model.task.UniqueTaskList.TaskNotFoundException;
import seedu.address.model.task.Venue;

/**
 * Finishes an unfinished task/event/recurring task in Dueue.
 */
public class FinishCommand extends AbleUndoCommand {

    public static final String COMMAND_WORD = "finish";

    public static final String COMMAND_FINISH = "finish command";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Marks the task identified by the index number used in the last task listing as finished.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_FINISH_TASK_SUCCESS = "Mark finished task: %1$s. Good job!";
    public static final String MESSAGE_FINISH_TASK_MARKED = "Oops! This task had already been finished";
    public static final String MESSAGE_WRONG_TASK_INDEX = "Oops! This task already exists in Dueue.";

    public final int targetIndex;
    // indicate whether the finish is successful
    private boolean isSuccess;
    // indicate whether the task is deleted due to the duplicated task
    private boolean isDeleted;
    // the task to be added if undoing
    private Task task;
    // the task to be deleted if undoing or the edited finished task if not undoing
    private Task replaceTask;
    // indicate whether the task is undoing a finish command
    private boolean isUndo;

    public FinishCommand(int targetIndex) {
        this.targetIndex = targetIndex;
        this.isSuccess = false;
        this.isDeleted = false;
    }


    @Override
    public CommandResult execute() throws CommandException {
        processTask();

        return execute(String.format(MESSAGE_FINISH_TASK_SUCCESS, replaceTask.getName()));
    }

    /*
     * update the mark task
     * if the task is not undoing a previous task the task update the model
     * if there is a duplicate task delete the task to replace
     * if undoing update by deleting and adding
     * if the there is a duplicate task then do not delete just add
     */
    public CommandResult execute(String message) throws CommandException {

        if (!isUndo) {
            try {
                model.updateTask(targetIndex - 1, replaceTask);
                isSuccess = true;
            } catch (DuplicateTaskException e) {
                try {
                    model.deleteTask(replaceTask);
                    isSuccess = true;
                    isDeleted = true;
                } catch (TaskNotFoundException e1) {
                    assert false : "The target person cannot be missing";
                }
            }
        } else {
            if (!isDeleted) {
                try {
                    model.deleteTask(replaceTask);
                } catch (TaskNotFoundException e) {
                    assert false : "The target task cannot be missing";
                }
            }
            try {
                model.addTask(task);
                isDeleted = false;
                if (task.isEvent() && task.isRecurring()) {
                    try {
                        Task temp = new RecurringEvent(task);
                        this.task = new RecurringEvent(replaceTask);
                        this.replaceTask = new RecurringEvent(temp);
                    } catch (IllegalValueException e) {
                        assert false : "The event must be valid";
                    }
                } else if (task.isEvent()) {
                    try {
                        Task temp = new Event(task);
                        this.task = new Event(replaceTask);
                        this.replaceTask = new Event(temp);
                    } catch (IllegalValueException e) {
                        assert false : "The event must be valid";
                    }
                } else if (task.isRecurring()) {
                    Task temp = new RecurringTask(task);
                    this.task = new RecurringTask(replaceTask);
                    this.replaceTask = new RecurringTask(temp);
                } else {
                    Task temp = new Task(task);
                    this.task = new Task(replaceTask);
                    this.replaceTask = new Task(temp);
                }
            } catch (DuplicateTaskException e) {
                assert false : "There must not be duplicated task";
            }
            model.updateFilteredListToShowAllUnfinishedTasks();
            this.isSuccess = true;
        }

        return new CommandResult(message);
    }

    // create the mark task
    private void processTask() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToMark = lastShownList.get(targetIndex - 1);

        ReadOnlyTask editedTask = null;

        if (taskToMark.isFinished()) {
            throw new CommandException(MESSAGE_FINISH_TASK_MARKED);
        } else if (taskToMark.isRecurring()) {
            try {
                if (taskToMark.isEvent()) {
                    this.task = new RecurringEvent(taskToMark);
                    editedTask = new RecurringEvent(taskToMark);
                    ((RecurringEvent) editedTask).finishOnce();
                    this.replaceTask = new RecurringEvent(editedTask);
                } else {
                    this.task = new RecurringTask(taskToMark);
                    editedTask = new RecurringTask(taskToMark);
                    ((RecurringTask) editedTask).finishOnce();
                    this.replaceTask = new RecurringTask(editedTask);
                }
            } catch (IllegalValueException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        } else {
            if (taskToMark.isEvent()) {
                try {
                    this.task = new Event(taskToMark);
                    editedTask = new Event(new Name(taskToMark.getName().fullName),
                                 new TaskDate(((Event) taskToMark).getStartDate().getValue()),
                                 new TaskTime(((Event) taskToMark).getStartTime().getValue()),
                                 new TaskDate(taskToMark.getDate().getValue()),
                                 new TaskTime(taskToMark.getTime().getValue()),
                                 new Description(taskToMark.getDescription().getValue()),
                                 new Tag(taskToMark.getTag().tagName),
                                 new Venue(taskToMark.getVenue().getValue()),
                                 new Priority(taskToMark.getPriority().getValue()),
                                 taskToMark.isFavorite(),
                                 FinishProperty.FINISHED);
                    this.replaceTask = new Event(editedTask);
                } catch (IllegalValueException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            } else {
                this.task = new Task(taskToMark);
                try {
                    editedTask  = new Task(
                            new Name(taskToMark.getName().fullName),
                            new TaskDate(taskToMark.getDate().getValue()),
                            new TaskTime(taskToMark.getTime().getValue()),
                            new Description(taskToMark.getDescription().getValue()),
                            new Tag(taskToMark.getTag().tagName),
                            new Venue(taskToMark.getVenue().getValue()),
                            new Priority(taskToMark.getPriority().getValue()),
                            taskToMark.isFavorite(),
                            FinishProperty.FINISHED);
                } catch (IllegalValueException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
                this.replaceTask = new Task(editedTask);
            }
        }

    }


    @Override
    public boolean isUndoable() {
        return true;
    }


    @Override
    public CommandResult executeUndo(String message) throws CommandException {
        return execute(CommandFormatter.undoMessageFormatter(message, getRedoCommandWord()));
    }

    // get the command to undo this command
    @Override
    public Command getUndoCommand() throws IllegalValueException {
        if (isSuccess) {
            isUndo = true;
            return this;
        } else {
            return null;
        }
    }

    @Override
    public String getUndoCommandWord() {
        return COMMAND_WORD + COMMAND_SUFFIX;
    }

    @Override
    public String getRedoCommandWord() {
        return COMMAND_WORD + COMMAND_SUFFIX;
    }
}

```
###### /java/seedu/address/logic/commands/ListCommand.java
``` java
package seedu.address.logic.commands;

import java.util.HashSet;
import java.util.Set;

import seedu.address.commons.core.EventsCenter;
import seedu.address.commons.events.ui.JumpToTagListRequestEvent;
import seedu.address.model.tag.UniqueTagList;

/**
 * Lists all unfinished tasks in Dueue or in a specified list.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";

    public static final String MESSAGE_LIST_SUCCESS = "Unfinished tasks are listed!";
    public static final String MESSAGE_LIST_DOES_NOT_EXIST = "Oops, given list name does not exist.\n"
            + "You may want to refer to the list names in the left column.";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": List tasks as per the parameters\n"
            + "the specified listname and displays them as a list with index numbers.\n"
            + "Parameters: [all/favorite/finished] [LIST_NAME]\n"
            + "Example: " + COMMAND_WORD + "\n"
            + COMMAND_WORD + " all study\n"
            + COMMAND_WORD + " finished\n";

    private final Set<String> keywords;

    public ListCommand(Set<String> keywords) {
        assert !keywords.isEmpty();
        this.keywords = keywords;
    }

    public ListCommand() {
        keywords = new HashSet<String>();
    }

    @Override
    public CommandResult execute() {
        assert keywords != null;
        if (keywords.isEmpty()) {
            model.updateFilteredListToShowAllUnfinishedTasks();
            LOGGER.info(getClass() + " listed all unfinished tasks");
            return new CommandResult(MESSAGE_LIST_SUCCESS);
        } else if (!model.isListExist(keywords)) {
            LOGGER.info(getClass() + " all the listnames given are not found");
            return new CommandResult(MESSAGE_LIST_DOES_NOT_EXIST);
        } else {
            highlightCurrentTagName(keywords);
            model.updateFilteredTaskListGivenListName(keywords);
            LOGGER.info(getClass() + " listed all unfinished tasks in the given lists");
            return new CommandResult(CommandFormatter.listFormatter(MESSAGE_LIST_SUCCESS, keywords));
        }
    }
```
###### /java/seedu/address/logic/commands/ListCommand.java
``` java
    @Override
    public boolean isUndoable() {
        return false;
    }
}
```
###### /java/seedu/address/logic/commands/RedoCommand.java
``` java
package seedu.address.logic.commands;

import java.util.Stack;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.exceptions.CommandException;

/**
 * Redo the previous undone command in Dueue.
 */
public class RedoCommand extends AbleUndoCommand {

    public static final String COMMAND_WORD = "redo";

    public static final String MESSAGE_SUCCESS = "Redo last task successfully.\n"
            + "You can type 'undo' to revert this redo again!";

    public static final String MESSAGE_UNSUCCESS = "No task to redo";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": List tasks as per the parameters\n"
            + "the specified listname/list index and displays them as a list with index numbers.\n"
            + "Parameters: [LISTNAME/LISTINDEX]\n"
            + "Example: " + COMMAND_WORD + " CS2103";

    private AbleUndoCommand undoCommand;
    private boolean canUndo = false;

    public RedoCommand(Stack<AbleUndoCommand> undoCommandList) {
        do {
            if (!undoCommandList.isEmpty()) {
                try {
                    this.undoCommand = (AbleUndoCommand) undoCommandList.pop().getUndoCommand();
                } catch (IllegalValueException e) {
                    e.printStackTrace();
                }
                if (this.undoCommand != null) {
                    this.canUndo = false;
                } else {
                    this.canUndo = true;
                }
            }
        } while(canUndo);

    }

    @Override
    public CommandResult execute() throws CommandException {
        if (this.undoCommand == null) {
            throw new CommandException(MESSAGE_UNSUCCESS);
        } else {
            this.undoCommand.setData(model);
            return this.undoCommand.executeUndo(MESSAGE_SUCCESS);
        }
    }

    @Override
    public boolean isUndoable() {
        return true;
    }

    @Override
    public CommandResult executeUndo(String message) throws CommandException {
        return null;
    }

    @Override
    public Command getUndoCommand() throws IllegalValueException {
        if (this.undoCommand != null) {
            return this.undoCommand.getUndoCommand();
        } else {
            return null;
        }
    }

    @Override
    public String getUndoCommandWord() {
        return COMMAND_WORD + COMMAND_SUFFIX;
    }

    @Override
    public String getRedoCommandWord() {
        return COMMAND_WORD + COMMAND_SUFFIX;
    }
}

```
###### /java/seedu/address/logic/commands/UndoCommand.java
``` java
package seedu.address.logic.commands;

import java.util.Stack;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.exceptions.CommandException;

/**
 * Undo the previous undoable command in Dueue.
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_SUCCESS = "Undo last task successfully.\n"
            + "You can type 'redo' to revert this undo.\n";

    public static final String MESSAGE_UNSUCCESS = "No task to undo";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": List tasks as per the parameters\n"
            + "the specified listname/list index and displays them as a list with index numbers.\n"
            + "Parameters: [LISTNAME/LISTINDEX]\n"
            + "Example: " + COMMAND_WORD + " CS2103";

    private AbleUndoCommand undoCommand;
    private boolean canUndo = false;
    private Stack<AbleUndoCommand> undoCommandList;

    public UndoCommand(Stack<AbleUndoCommand> commandList, Stack<AbleUndoCommand> undoCommandList) {
        do {
            if (!commandList.isEmpty()) {
                try {
                    if (this.undoCommand.COMMAND_WORD.equals(RedoCommand.COMMAND_WORD)) {
                        undoCommandList.clear();
                    }
                    this.undoCommand = (AbleUndoCommand) commandList.pop().getUndoCommand();
                    this.undoCommandList = undoCommandList;
                } catch (IllegalValueException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
                if (this.undoCommand != null) {
                    this.canUndo = false;
                } else {
                    this.canUndo = true;
                }
            }
        } while(canUndo);
    }

    @Override
    public CommandResult execute() throws CommandException {
        if (this.undoCommand == null) {
            throw new CommandException(MESSAGE_UNSUCCESS);
        } else {
            this.undoCommand.setData(model);
            this.undoCommandList.push(this.undoCommand);
            return this.undoCommand.executeUndo(
                    CommandFormatter.undoMessageFormatter(MESSAGE_SUCCESS, this.undoCommand));
        }
    }

    @Override
    public boolean isUndoable() {
        return false;
    }
}
```
###### /java/seedu/address/logic/LogicManager.java
``` java
package seedu.address.logic;

import java.util.Stack;
import java.util.logging.Logger;

import javafx.collections.ObservableList;
import seedu.address.commons.core.ComponentManager;
import seedu.address.commons.core.LogsCenter;
import seedu.address.logic.commands.AbleUndoCommand;
import seedu.address.logic.commands.Command;
import seedu.address.logic.commands.CommandResult;
import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.logic.parser.Parser;
import seedu.address.model.Model;
import seedu.address.model.tag.Tag;
import seedu.address.model.task.ReadOnlyTask;
import seedu.address.storage.Storage;

/**
 * The main LogicManager of the app.
 */
public class LogicManager extends ComponentManager implements Logic {
    private final Logger logger = LogsCenter.getLogger(LogicManager.class);

    private final Model model;
    private final Parser parser;
    private final Stack<AbleUndoCommand> commandList;
    private final Stack<AbleUndoCommand> redoCommandList;

    public LogicManager(Model model, Storage storage) throws CommandException {
        this.model = model;
        this.parser = new Parser();
        this.commandList = new Stack<AbleUndoCommand>();
        this.redoCommandList = new Stack<AbleUndoCommand>();
        execute("list");
    }

    @Override
    public CommandResult execute(String commandText) throws CommandException {
        logger.info("----------------[USER COMMAND][" + commandText + "]");
        Command command = parser.parseCommand(commandText, commandList, redoCommandList);
        command.setData(model);
        if (command.isUndoable()) {
            commandList.push((AbleUndoCommand) command);
        }
        logger.info(command.getClass() + " handles current command");
        return command.execute();
    }

    @Override
    public ObservableList<ReadOnlyTask> getFilteredTaskList() {
        return model.getFilteredTaskList();
    }

    @Override
    public ObservableList<Tag> getFilteredTagList() {
        return model.getFilteredTagList();
    }
}
```
###### /java/seedu/address/logic/parser/AddCommandParser.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.parser.CliSyntax.PREFIX_DATE;
import static seedu.address.logic.parser.CliSyntax.PREFIX_DESCRIPTION;
import static seedu.address.logic.parser.CliSyntax.PREFIX_FAVOURITE;
import static seedu.address.logic.parser.CliSyntax.PREFIX_FREQUENCY;
import static seedu.address.logic.parser.CliSyntax.PREFIX_PRIORITY;
import static seedu.address.logic.parser.CliSyntax.PREFIX_START;
import static seedu.address.logic.parser.CliSyntax.PREFIX_STARTTIME;
import static seedu.address.logic.parser.CliSyntax.PREFIX_TAG;
import static seedu.address.logic.parser.CliSyntax.PREFIX_TIME;
import static seedu.address.logic.parser.CliSyntax.PREFIX_VENUE;

import java.util.NoSuchElementException;
import java.util.Optional;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.AddCommand;
import seedu.address.logic.commands.Command;
import seedu.address.logic.commands.IncorrectCommand;

/**
 * Parses input arguments and creates a new AddCommand object
 */
public class AddCommandParser {

    private static AddCommandParser theOne;

    private AddCommandParser() {
    }

    public static AddCommandParser getInstance() {
        if (theOne == null) {
            theOne = new AddCommandParser();
        }
        return theOne;
    }
    /**
     * Parses the given {@code String} of arguments in the context of the AddCommand
     * and returns an AddCommand object for execution.
     */
    public static Command parse(String args) {
        // check whether the user did not enter an empty add command
        if (args == null) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
        // initialize the ArgumentTokenizer to read in different detail field of the task to be added
        ArgumentTokenizer argsTokenizer =
                new ArgumentTokenizer(PREFIX_DATE, PREFIX_TIME, PREFIX_TAG, PREFIX_DESCRIPTION,
                        PREFIX_VENUE, PREFIX_PRIORITY, PREFIX_FAVOURITE, PREFIX_START,
                        PREFIX_STARTTIME, PREFIX_FREQUENCY);
        argsTokenizer.tokenize(args);
        try {
            // get the different detail field of the task to be added
            String name = argsTokenizer.getPreamble().get();
            String date = checkString(argsTokenizer.getValue(PREFIX_DATE));
            String startDate = checkString(argsTokenizer.getValue(PREFIX_START));
            String time = checkString(argsTokenizer.getValue(PREFIX_TIME));
            String startTime = checkString(argsTokenizer.getValue(PREFIX_STARTTIME));
            String tag = checkString(argsTokenizer.getValue(PREFIX_TAG));
            String description = checkString(argsTokenizer.getValue(PREFIX_DESCRIPTION));
            String venue = checkString(argsTokenizer.getValue(PREFIX_VENUE));
            String priority = checkString(argsTokenizer.getValue(PREFIX_PRIORITY));
            String frequency = checkString(argsTokenizer.getValue(PREFIX_FREQUENCY));
            // check if the user wants to a a special task
            boolean isEvent = checkEvent(startDate, startTime);
            boolean isFavourite = checkFav(argsTokenizer.getValue(PREFIX_FAVOURITE));
            boolean isRecurring = !frequency.isEmpty();
            // pass the detail field of the task to be added to the add command
            return new AddCommand(name, date, startDate, time, startTime, tag,
                    description, venue, priority, frequency, isFavourite, isEvent, isRecurring);
        } catch (NoSuchElementException ive) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    // check if the user wants to add an event by checking if either the start or the startTime is filled
    private static boolean checkEvent(String start, String startTime) {
        return !start.isEmpty() || !startTime.isEmpty();
    }

    // check if the user add in a favorite task by checking whether the favorite(*f) indication is present
    private static boolean checkFav(Optional<String> args) {
        return args.isPresent();
    }

    // check if the string is present if not give it an empty string
    private static String checkString(Optional<String> args) {
        return args.orElse("");
    }

}
```
###### /java/seedu/address/logic/parser/CliSyntax.java
``` java
package seedu.address.logic.parser;

import java.util.regex.Pattern;

import seedu.address.logic.parser.ArgumentTokenizer.Prefix;

/**
 * Contains Command Line Interface (CLI) syntax definitions common to multiple commands
 */
public class CliSyntax {

    /* Prefix definitions */
    public static final Prefix PREFIX_NAME = new Prefix("n/");
    public static final Prefix PREFIX_DATE = new Prefix("due/");
    public static final Prefix PREFIX_TIME = new Prefix("dueT/");
    public static final Prefix PREFIX_TAG = new Prefix("#");
    public static final Prefix PREFIX_DESCRIPTION = new Prefix("d/");
    public static final Prefix PREFIX_VENUE = new Prefix("@");
    public static final Prefix PREFIX_PRIORITY = new Prefix("p/");
    public static final Prefix PREFIX_FAVOURITE = new Prefix("*f");
    public static final Prefix PREFIX_UNFAVOURITE = new Prefix("*u");
    public static final Prefix PREFIX_START = new Prefix("start/");
    public static final Prefix PREFIX_STARTTIME = new Prefix("startT/");
    public static final Prefix PREFIX_FREQUENCY = new Prefix("f/");
    public static final Prefix PREFIX_ONCE = new Prefix("once/");
    public static final Prefix PREFIX_ALL = new Prefix("all");

    /* Patterns definitions */
    public static final Pattern KEYWORDS_ARGS_FORMAT =
            Pattern.compile("(?<keywords>\\S+(?:\\s+\\S+)*)"); // one or more keywords separated by whitespace

    /* Patterns definitions */
    public static final Pattern KEYWORDS_ARGS_FORMAT_LIST =
            Pattern.compile("(?<keywords>\\S+(?:\\s+\\S+)*)"); // one or more keywords separated by whitespace

}
```
###### /java/seedu/address/logic/parser/DeleteCommandParser.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.parser.CliSyntax.PREFIX_ALL;

import java.util.Optional;

import seedu.address.logic.commands.Command;
import seedu.address.logic.commands.DeleteCommand;
import seedu.address.logic.commands.IncorrectCommand;

/**
 * Parses input arguments and creates a new DeleteCommand object
 */
public class DeleteCommandParser {

    private static DeleteCommandParser theOne;

    private DeleteCommandParser() {
    }

    public static DeleteCommandParser getInstance() {
        if (theOne == null) {
            theOne = new DeleteCommandParser();
        }
        return theOne;
    }

    /**
     * Parses the given {@code String} of arguments in the context of the DeleteCommand
     * and returns an DeleteCommand object for execution.
     */
    public static Command parse(String args) {
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_ALL);
        argsTokenizer.tokenize(args);

        if (!argsTokenizer.getPreamble().isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }
        String stringIndex = argsTokenizer.getPreamble().get();
        Optional<Integer> index = ParserUtil.parseIndex(stringIndex);
        Optional<String> isDeleteAll = argsTokenizer.getValue(PREFIX_ALL);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }

        return new DeleteCommand(index.get(), isDeleteAll.isPresent());
    }

}
```
###### /java/seedu/address/logic/parser/EditCommandParser.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.logic.parser.CliSyntax.PREFIX_DATE;
import static seedu.address.logic.parser.CliSyntax.PREFIX_DESCRIPTION;
import static seedu.address.logic.parser.CliSyntax.PREFIX_FAVOURITE;
import static seedu.address.logic.parser.CliSyntax.PREFIX_FREQUENCY;
import static seedu.address.logic.parser.CliSyntax.PREFIX_NAME;
import static seedu.address.logic.parser.CliSyntax.PREFIX_ONCE;
import static seedu.address.logic.parser.CliSyntax.PREFIX_PRIORITY;
import static seedu.address.logic.parser.CliSyntax.PREFIX_START;
import static seedu.address.logic.parser.CliSyntax.PREFIX_STARTTIME;
import static seedu.address.logic.parser.CliSyntax.PREFIX_TAG;
import static seedu.address.logic.parser.CliSyntax.PREFIX_TIME;
import static seedu.address.logic.parser.CliSyntax.PREFIX_UNFAVOURITE;
import static seedu.address.logic.parser.CliSyntax.PREFIX_VENUE;

import java.util.List;
import java.util.Optional;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.Command;
import seedu.address.logic.commands.EditCommand;
import seedu.address.logic.commands.EditNextCommand;
import seedu.address.logic.commands.EditTaskDescriptor;
import seedu.address.logic.commands.IncorrectCommand;

/**
 * Parses input arguments and creates a new EditCommand object
 */
public class EditCommandParser {

    private static EditCommandParser theOne;

    private EditCommandParser() {
    }

    public static EditCommandParser getInstance() {
        if (theOne == null) {
            theOne = new EditCommandParser();
        }
        return theOne;
    }

    /**
     * Parses the given {@code String} of arguments in the context of the EditCommand
     * and returns an EditCommand object for execution.
     */
    public static Command parse(String args) {
        assert args != null;
        ArgumentTokenizer argsTokenizer =
                new ArgumentTokenizer(PREFIX_NAME, PREFIX_DATE, PREFIX_TIME, PREFIX_TAG,
                        PREFIX_DESCRIPTION, PREFIX_VENUE, PREFIX_PRIORITY, PREFIX_FAVOURITE,
                        PREFIX_UNFAVOURITE, PREFIX_START, PREFIX_STARTTIME, PREFIX_FREQUENCY, PREFIX_ONCE);
        argsTokenizer.tokenize(args);
        List<Optional<String>> preambleFields = ParserUtil.splitPreamble(argsTokenizer.getPreamble().orElse(""), 2);

        Optional<Integer> index = preambleFields.get(0).flatMap(ParserUtil::parseIndex);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        EditTaskDescriptor editTaskDescriptor = new EditTaskDescriptor();
        try {
            editTaskDescriptor.setDue(ParserUtil.parseDate(argsTokenizer.getValue(PREFIX_DATE)));
            editTaskDescriptor.setStart(ParserUtil.parseDate(argsTokenizer.getValue(PREFIX_START)));
            editTaskDescriptor.setName(ParserUtil.parseName(argsTokenizer.getValue(PREFIX_NAME)));
            editTaskDescriptor.setDueTime(ParserUtil.parseTime(argsTokenizer.getValue(PREFIX_TIME)));
            editTaskDescriptor.setStartTime(ParserUtil.parseTime(argsTokenizer.getValue(PREFIX_STARTTIME)));
            editTaskDescriptor.setTag(ParserUtil.parseTag(argsTokenizer.getValue(PREFIX_TAG)));
            editTaskDescriptor.setDescription(ParserUtil.parseDescription(argsTokenizer.getValue(PREFIX_DESCRIPTION)));
            editTaskDescriptor.setVenue(ParserUtil.parseVenue(argsTokenizer.getValue(PREFIX_VENUE)));
            editTaskDescriptor.setPriority(ParserUtil.parsePriority(argsTokenizer.getValue(PREFIX_PRIORITY)));
            editTaskDescriptor.setIsFavourite(ParserUtil.isFavourite(argsTokenizer.getValue(PREFIX_FAVOURITE)));
            editTaskDescriptor.setIsUnfavourite(ParserUtil.isUnfavourite(argsTokenizer.getValue(PREFIX_UNFAVOURITE)));
            editTaskDescriptor.setRecurringMode(ParserUtil.parseString(argsTokenizer.getValue(PREFIX_FREQUENCY)));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }

        if (!editTaskDescriptor.isAnyFieldEdited()) {
            return new IncorrectCommand(EditCommand.MESSAGE_NOT_EDITED);
        }

        Optional<String> once = argsTokenizer.getValue(PREFIX_ONCE);
        if (once.isPresent() && "t".equals(once.get())) {
            return new EditNextCommand(index.get(), editTaskDescriptor);
        }

        return new EditCommand(index.get(), editTaskDescriptor);
    }

}
```
###### /java/seedu/address/logic/parser/FinishCommandParser.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.Optional;

import seedu.address.logic.commands.Command;
import seedu.address.logic.commands.FinishCommand;
import seedu.address.logic.commands.IncorrectCommand;

/**
 * Parses input arguments and creates a new FinishCommand object
 */
public class FinishCommandParser {

    private static FinishCommandParser theOne;

    private FinishCommandParser() {
    }

    public static FinishCommandParser getInstance() {
        if (theOne == null) {
            theOne = new FinishCommandParser();
        }
        return theOne;
    }

    /**
     * Parses the given {@code String} of arguments in the context of the DeleteCommand
     * and returns an DeleteCommand object for execution.
     */
    public static Command parse(String args) {
        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, FinishCommand.MESSAGE_USAGE));
        }

        return new FinishCommand(index.get());
    }

}
```
###### /java/seedu/address/logic/parser/Parser.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.address.commons.core.Messages.MESSAGE_UNKNOWN_COMMAND;

import java.util.Stack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.address.logic.commands.AbleUndoCommand;
import seedu.address.logic.commands.AddCommand;
import seedu.address.logic.commands.ClearCommand;
import seedu.address.logic.commands.Command;
import seedu.address.logic.commands.DeleteCommand;
import seedu.address.logic.commands.EditCommand;
import seedu.address.logic.commands.ExitCommand;
import seedu.address.logic.commands.FindCommand;
import seedu.address.logic.commands.FinishCommand;
import seedu.address.logic.commands.HelpCommand;
import seedu.address.logic.commands.IncorrectCommand;
import seedu.address.logic.commands.ListCommand;
import seedu.address.logic.commands.LoadCommand;
import seedu.address.logic.commands.RedoCommand;
import seedu.address.logic.commands.ScrollToCommand;
import seedu.address.logic.commands.UndoCommand;
import seedu.address.logic.commands.ViewNextCommand;

/**
 * Parses user input.
 */
public class Parser {

    /**
     * Used for initial separation of command word and args.
     */
    private static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile("(?<commandWord>\\S+)(?<arguments>.*)");

    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput, Stack<AbleUndoCommand> commandList,
            Stack<AbleUndoCommand> undoCommandList) {
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group("commandWord");
        final String arguments = matcher.group("arguments");
        switch (commandWord) {

        case UndoCommand.COMMAND_WORD:
            return new UndoCommand(commandList, undoCommandList);

        case RedoCommand.COMMAND_WORD:
            return new RedoCommand(undoCommandList);

        case AddCommand.COMMAND_WORD:
            undoCommandList.clear();
            return AddCommandParser.parse(arguments);

        case ExitCommand.COMMAND_WORD:
            return new ExitCommand();

        case EditCommand.COMMAND_WORD:
            undoCommandList.clear();
            return EditCommandParser.parse(arguments);

        case DeleteCommand.COMMAND_WORD:
            undoCommandList.clear();
            return DeleteCommandParser.parse(arguments);

        case FinishCommand.COMMAND_WORD:
            undoCommandList.clear();
            return FinishCommandParser.parse(arguments);

        case ClearCommand.COMMAND_WORD:
            undoCommandList.clear();
            return new ClearCommand();

        case FindCommand.COMMAND_WORD:
            return FindCommandParser.parse(arguments);

        case LoadCommand.COMMAND_WORD:
            return LoadCommandParser.parse(arguments);

        case ListCommand.COMMAND_WORD:
            return ListCommandParser.parse(arguments);

        case ScrollToCommand.COMMAND_WORD:
            return ScrollToCommandParser.parse(arguments);

        case HelpCommand.COMMAND_WORD:
            return HelpCommandParser.parse(arguments);

        case ViewNextCommand.COMMAND_WORD:
            return ViewCommandParser.parse(arguments);

        default:
            return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
        }
    }
}
```
###### /java/seedu/address/logic/parser/ParserUtil.java
``` java
package seedu.address.logic.parser;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.commons.util.StringUtil;
import seedu.address.model.tag.Tag;
import seedu.address.model.task.Description;
import seedu.address.model.task.Name;
import seedu.address.model.task.Priority;
import seedu.address.model.task.TaskDate;
import seedu.address.model.task.TaskTime;
import seedu.address.model.task.Venue;

/**
 * Contains utility methods used for parsing strings in the various *Parser classes
 */
public class ParserUtil {

    private static final Pattern INDEX_ARGS_FORMAT = Pattern.compile("(?<targetIndex>.+)");

    /**
     * Returns the specified index in the {@code command} if it is a positive unsigned integer
     * Returns an {@code Optional.empty()} otherwise.
     */
    public static Optional<Integer> parseIndex(String command) {
        final Matcher matcher = INDEX_ARGS_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String index = matcher.group("targetIndex");
        if (!StringUtil.isUnsignedInteger(index)) {
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(index));

    }

    /**
     * Returns a new Set populated by all elements in the given list of strings
     * Returns an empty set if the given {@code Optional} is empty,
     * or if the list contained in the {@code Optional} is empty
     */
    public static Set<String> toSet(Optional<List<String>> list) {
        List<String> elements = list.orElse(Collections.emptyList());
        return new HashSet<>(elements);
    }

    /**
    * Splits a preamble string into ordered fields.
    * @return A list of size {@code numFields} where the ith element is the ith field value if specified in
    *         the input, {@code Optional.empty()} otherwise.
    */
    public static List<Optional<String>> splitPreamble(String preamble, int numFields) {
        return Arrays.stream(Arrays.copyOf(preamble.split("\\s+", numFields), numFields))
                .map(Optional::ofNullable)
                .collect(Collectors.toList());
    }

    /**
     * Parses a {@code Optional<String> name} into an {@code Optional<Name>} if {@code name} is present.
     */
    public static Optional<String> parseString(Optional<String> name) throws IllegalValueException {
        assert name != null;
        return name.isPresent() ? name : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> name} into an {@code Optional<Name>} if {@code name} is present.
     */
    public static Optional<Name> parseName(Optional<String> name) throws IllegalValueException {
        assert name != null;
        return name.isPresent() ? Optional.of(new Name(name.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> phone} into an {@code Optional<Phone>} if {@code phone} is present.
     */
    public static Optional<TaskDate> parseDate(Optional<String> date) throws IllegalValueException {
        assert date != null;
        return date.isPresent() ? Optional.of(new TaskDate(date.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> address} into an {@code Optional<Address>} if {@code address} is present.
     */
    public static Optional<TaskTime> parseTime(Optional<String> time) throws IllegalValueException {
        assert time != null;
        return time.isPresent() ? Optional.of(new TaskTime(time.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> email} into an {@code Optional<Email>} if {@code email} is present.
     */
    public static Optional<Tag> parseTag(Optional<String> tag) throws IllegalValueException {
        assert tag != null;
        return tag.isPresent() ? Optional.of(new Tag(tag.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> email} into an {@code Optional<Email>} if {@code email} is present.
     */
    public static Optional<Description> parseDescription(Optional<String> description) throws IllegalValueException {
        assert description != null;
        return description.isPresent() ? Optional.of(new Description(description.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> email} into an {@code Optional<Email>} if {@code email} is present.
     */
    public static Optional<Venue> parseVenue(Optional<String> venue) throws IllegalValueException {
        assert venue != null;
        return venue.isPresent() ? Optional.of(new Venue(venue.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> email} into an {@code Optional<Email>} if {@code email} is present.
     */
    public static Optional<Priority> parsePriority(Optional<String> priority) throws IllegalValueException {
        assert priority != null;
        return priority.isPresent() ? Optional.of(new Priority(priority.get())) : Optional.empty();
    }

    public static boolean isFavourite(Optional<String> isFavourite) {
        return isFavourite.isPresent();
    }

    public static boolean isUnfavourite(Optional<String> isUnfavourite) {
        return isUnfavourite.isPresent();
    }
}
```
###### /java/seedu/address/storage/XmlAdaptedTask.java
``` java
package seedu.address.storage;

import javax.xml.bind.annotation.XmlElement;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.tag.Tag;
import seedu.address.model.task.Description;
import seedu.address.model.task.Event;
import seedu.address.model.task.Name;
import seedu.address.model.task.Priority;
import seedu.address.model.task.ReadOnlyEvent;
import seedu.address.model.task.ReadOnlyRecurringTask;
import seedu.address.model.task.ReadOnlyRecurringTask.RecurringMode;
import seedu.address.model.task.ReadOnlyTask;
import seedu.address.model.task.ReadOnlyTask.FinishProperty;
import seedu.address.model.task.RecurringEvent;
import seedu.address.model.task.RecurringTask;
import seedu.address.model.task.Task;
import seedu.address.model.task.TaskDate;
import seedu.address.model.task.TaskTime;
import seedu.address.model.task.Venue;

/**
 * JAXB-friendly version of the Person.
 */
public class XmlAdaptedTask {

    @XmlElement(required = true)
    protected String name;
    @XmlElement(required = false)
    protected String date;
    @XmlElement(required = false)
    protected String time;
    @XmlElement(required = false)
    protected String tag;
    @XmlElement(required = false)
    protected String description;
    @XmlElement(required = false)
    protected String venue;
    @XmlElement(required = false)
    protected String priority;
    @XmlElement(required = true)
    protected boolean isFavourite;
    @XmlElement(required = true)
    protected FinishProperty isFinished;
    @XmlElement(required = true)
    protected boolean isEvent;
    @XmlElement(required = true)
    private String startDate;
    @XmlElement(required = false)
    private String startTime;
    @XmlElement(required = true)
    protected boolean isRecurring;
    @XmlElement(required = false)
    private String recurringMode;

    /**
     * Constructs an XmlAdaptedPerson.
     * This is the no-arg constructor that is required by JAXB.
     */
    public XmlAdaptedTask() {}


    /**
     * Converts a given Person into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedPerson
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        name = source.getName().fullName;
        date = source.getDate().getValue();
        time = source.getTime().getValue();
        tag = source.getTag().tagName;
        description = source.getDescription().getValue();
        venue = source.getVenue().getValue();
        priority = source.getPriority().getValue();
        isFavourite = source.isFavorite();
        isFinished = source.getFinished();
        isEvent = source.isEvent();
        isRecurring = source.isRecurring();
        if (isEvent) {
            startDate = ((ReadOnlyEvent) source).getStartDate().getValue();
            startTime = ((ReadOnlyEvent) source).getStartTime().getValue();
        }
        if (isRecurring) {
            recurringMode = ((ReadOnlyRecurringTask) source).getRecurringPeriod();
        }
    }

    /**
     * Converts this jaxb-friendly adapted person object into the model's Person object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted person
     */
    public Task toModelType() throws IllegalValueException {
        final Name name = new Name(this.name);
        final TaskDate date = new TaskDate(this.date);
        final TaskTime time = new TaskTime(this.time);
        final Description description = new Description(this.description);
        final Tag tag = new Tag(this.tag);
        final Venue venue = new Venue(this.venue);
        final Priority priority = new Priority(this.priority);
        if (this.isEvent) {
            final TaskDate startDate = new TaskDate(this.startDate);
            final TaskTime startTime = new TaskTime(this.startTime);
            if (isRecurring) {
                final RecurringMode recurring = getRecurringMode(this.recurringMode);
                return new RecurringEvent(name, startDate, startTime, date, time, description, tag, venue, priority,
                        isFavourite, isFinished, recurring);
            } else {
                return new Event(name, startDate, startTime, date, time, description, tag, venue, priority,
                        isFavourite, isFinished);
            }
        } else {
            if (isRecurring) {
                final RecurringMode recurring = getRecurringMode(this.recurringMode);
                return new RecurringTask(name, date, time, description, tag, venue, priority,
                        isFavourite, isFinished, recurring);
            } else {
                return new Task(name, date, time, description, tag,
                        venue, priority, isFavourite, isFinished);
            }
        }
    }

    private RecurringMode getRecurringMode(String recurringMode) {
        if (recurringMode.contains("day")) {
            return RecurringMode.DAY;
        } else if (recurringMode.contains("week")) {
            return RecurringMode.WEEK;
        } else if (recurringMode.contains("month")) {
            return RecurringMode.MONTH;
        } else {
            return null;
        }
    }

    public String getTagName() {
        return this.tag;
    }
}
```
###### /java/seedu/address/storage/XmlSerializableTaskManager.java
``` java
package seedu.address.storage;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import seedu.address.commons.core.UnmodifiableObservableList;
import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.ReadOnlyTaskManager;
import seedu.address.model.tag.Tag;
import seedu.address.model.task.ReadOnlyTask;
import seedu.address.model.task.Task;



/**
 * An Immutable TaskManager that is serializable to XML format
 */
@XmlRootElement(name = "taskmanager")
public class XmlSerializableTaskManager implements ReadOnlyTaskManager {

    @XmlElement
    private List<XmlAdaptedTask> tasks;
    @XmlElement
    private List<XmlAdaptedTag> tags;

    /**
     * Creates an empty XmlSerializableTaskManager.
     * This empty constructor is required for marshalling.
     */
    public XmlSerializableTaskManager() {
        tasks = new ArrayList<>();
        tags = new ArrayList<>();
    }

    /**
     * Conversion
     */
    public XmlSerializableTaskManager(ReadOnlyTaskManager src) {
        this();
        tasks.addAll(src.getTaskList().stream().map(XmlAdaptedTask::new).collect(Collectors.toList()));
        tags.addAll(src.getTagList().stream().map(XmlAdaptedTag::new).collect(Collectors.toList()));
    }

    @Override
    public ObservableList<ReadOnlyTask> getTaskList() {
        final ObservableList<Task> task = this.tasks.stream().map(p -> {
            try {
                if (p.isEvent == true) {
                    //TODO: What to do here???
                }
                return p.toModelType();
            } catch (IllegalValueException e) {
                e.printStackTrace();
                //TODO: better error handling
                return null;
            }
        }).collect(Collectors.toCollection(FXCollections::observableArrayList));
        return new UnmodifiableObservableList<>(task);
    }

    @Override
    public ObservableList<Tag> getTagList() {
        final ObservableList<Tag> tags = this.tags.stream().map(t -> {
            try {
                return t.toModelType();
            } catch (IllegalValueException e) {
                e.printStackTrace();
                //TODO: better error handling
                return null;
            }
        }).collect(Collectors.toCollection(FXCollections::observableArrayList));
        return new UnmodifiableObservableList<>(tags);
    }

}
```
###### /java/seedu/address/storage/XmlTaskManagerStorage.java
``` java
package seedu.address.storage;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Optional;
import java.util.logging.Logger;

import seedu.address.commons.core.LogsCenter;
import seedu.address.commons.exceptions.DataConversionException;
import seedu.address.commons.util.FileUtil;
import seedu.address.model.ReadOnlyTaskManager;

/**
 * A class to access AddressBook data stored as an xml file on the hard disk.
 */
public class XmlTaskManagerStorage implements TaskManagerStorage {

    private static final Logger logger = LogsCenter.getLogger(XmlTaskManagerStorage.class);

    private String filePath;
    private static XmlTaskManagerStorage xmlStorage;

    protected XmlTaskManagerStorage(String filePath) {
        this.filePath = filePath;
    }

    static XmlTaskManagerStorage getInstance(String filePath) {
        if (xmlStorage == null) {
            return xmlStorage = new XmlTaskManagerStorage(filePath);
        } else {
            xmlStorage.changeFilePath(filePath);
            return xmlStorage;
        }
    }

    public String getTaskManagerFilePath() {
        return filePath;
    }

    public void changeFilePath(String filePath) {
        this.filePath = filePath;
    }

    @Override
    public Optional<ReadOnlyTaskManager> readTaskManager() throws DataConversionException, IOException {
        return readTaskManager(filePath);
    }

    /**
     * Similar to {@link #readAddressBook()}
     * @param filePath location of the data. Cannot be null
     * @throws DataConversionException if the file is not in the correct format.
     * @throws FileNotFoundException
     */
    public Optional<ReadOnlyTaskManager> readTaskManager(String filePath) throws
        DataConversionException, FileNotFoundException {
        assert filePath != null;
        File taskManagerFile = new File(filePath);

        if (!taskManagerFile.exists()) {
            logger.info("TaskManager file "  + taskManagerFile + " not found");
        }
        ReadOnlyTaskManager taskManagerOptional = XmlFileStorage.loadDataFromSaveFile(new File(filePath));

        return Optional.of(taskManagerOptional);
    }

    @Override
    public void saveTaskManager(ReadOnlyTaskManager taskManager) throws IOException {
        saveTaskManager(taskManager, filePath);
    }

    /**
     * Similar to {@link #saveAddressBook(ReadOnlyAddressBook)}
     * @param filePath location of the data. Cannot be null
     */
    public void saveTaskManager(ReadOnlyTaskManager taskManager, String filePath) throws IOException {
        assert taskManager != null;
        assert filePath != null;

        File file = new File(filePath);
        FileUtil.createIfMissing(file);
        XmlFileStorage.saveDataToFile(file, new XmlSerializableTaskManager(taskManager));
    }

}
```
