# A0143409J
###### /java/seedu/address/logic/commands/CommandFormatter.java
``` java
/*
 * A formatter class doing formatting for all commands output messages
 */
package seedu.address.logic.commands;

import java.util.Iterator;
import java.util.Set;

/*
 *  A formatter class to help other command classes to format strings.
 */
public class CommandFormatter {

    private static final String LIST_SEPARATOR = ", ";
    private static final String LAST_TASK = "last task";
    private static final String UNDO_FRIENDLY = "%s\nYou can undo the %s by typing 'undo'";

    private CommandFormatter() {};

    public static String listFormatter(String message, Set<String> keywords) {
        String formatted = message + " in list ";
        for (Iterator<String> it = keywords.iterator(); it.hasNext(); ) {
            formatted += it.next();
            if (it.hasNext()) {
                formatted += LIST_SEPARATOR;
            }
        }
        return formatted;
    }

    public static String undoFormatter(String message, String commandWord) {
        return String.format(UNDO_FRIENDLY, message, commandWord);
    }

    public static String undoMessageFormatter(String message, String commandWord) {
        return message.replace(LAST_TASK, commandWord);
    }

    public static String undoMessageFormatter(String message, AbleUndoCommand command) {
        String commandWord = command.getUndoCommandWord();
        return undoMessageFormatter(message, commandWord);
    }

    public static String viewCommandFeedBackMessageFormatter(
            String numberOfDays, String messageViewSuccess,
            String messageViewSuccessToday, String messageViewSuccessTmr) {
        if ("0".equals(numberOfDays)) {
            return String.format(messageViewSuccessToday, numberOfDays);
        } else if ("1".equals(numberOfDays)) {
            return String.format(messageViewSuccessTmr, numberOfDays);
        } else {
            return  String.format(messageViewSuccess, numberOfDays);
        }
    }

}
```
###### /java/seedu/address/logic/commands/EditNextCommand.java
``` java
    private ReadOnlyTask finishedOnceTask;

    /**
     * Create editNext command using an index for specific task and description for the edited task
     */
    public EditNextCommand(int filteredTaskListIndex, EditTaskDescriptor editTaskDescriptor) {
        super(filteredTaskListIndex, editTaskDescriptor);
        finishedOnceTask = null;
    }

    public EditNextCommand(ReadOnlyTask task, Task oldTask, ReadOnlyTask finishedOnceTask) {
        super(task, oldTask);
        this.finishedOnceTask = finishedOnceTask;
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToEdit = lastShownList.get(filteredTaskListIndex);
        if (!(taskToEdit instanceof ReadOnlyRecurringTask)) {
            throw new CommandException("The task to edit once should be a recurring task.");
        }
        ReadOnlyTask editTask = lastShownList.get(filteredTaskListIndex);

        try {
            if (editTask.isEvent()) {
                oldTask = new RecurringEvent(editTask);
            } else {
                oldTask = new RecurringTask(editTask);
            }
            Task newTask = createEditedTask(taskToEdit, editTaskDescriptor);
            newTask.setRecurringProperty(RecurringProperty.NON_RECURRING);
            if (newTask.isEvent()) {
                task = new Event(newTask);
            } else {
                task = new Task(newTask);
            }
            if (taskToEdit.isEvent()) {
                ((RecurringEvent) taskToEdit).finishOnce();
                finishedOnceTask = new RecurringEvent(taskToEdit);
            } else {
                ((RecurringTask) taskToEdit).finishOnce();
                finishedOnceTask = new RecurringTask(taskToEdit);
            }
            model.updateTask(filteredTaskListIndex, taskToEdit);
            model.addTask((Task) task);
            this.isSuccess = true;
        } catch (IllegalValueException e) {
            throw new CommandException(e.getMessage());
        }

        model.updateFilteredListToShowAllUnfinishedTasks();
        return new CommandResult(CommandFormatter.undoFormatter(
                String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit.getName()), COMMAND_EDIT));
    }

    @Override
    public boolean isUndoable() {
        return true;
    }

    @Override
    public CommandResult undo(String message) throws CommandException {
        assert model != null;
        try {
            if (finishedOnceTask != null) {
                model.deleteTask(task);
                model.addTask(oldTask);
                model.deleteTask(finishedOnceTask);
                Task temp = (Task) task;
                this.task = oldTask;
                this.oldTask = temp;
                this.finishedOnceTask = null;
                this.isSuccess = true;
            } else {
                Task temp;
                if (oldTask.isEvent()) {
                    temp = new Event(oldTask);
                } else {
                    temp = new Task(oldTask);
                }
                model.addTask(oldTask);
                if (task.isEvent()) {
                    oldTask = new RecurringEvent(task);
                } else {
                    oldTask = new RecurringTask(task);
                }
                if (task.isEvent()) {
                    ((RecurringEvent) task).finishOnce();
                    finishedOnceTask = new RecurringEvent(task);
                } else {
                    ((RecurringTask) task).finishOnce();
                    finishedOnceTask = new RecurringTask(task);
                }
                model.deleteTask(task);
                model.addTask((Task) finishedOnceTask);
                this.task = temp;
                this.isSuccess = true;
            }
        } catch (TaskNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (DuplicateTaskException e) {
            e.printStackTrace();
        } catch (IllegalValueException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        model.updateFilteredListToShowAllUnfinishedTasks();
        isSuccess = true;
        return new CommandResult(CommandFormatter.undoMessageFormatter(message, getUndoCommandWord()));
    }

    @Override
    public Command getUndoCommand() {
        if (isSuccess) {
            //TODO
            return new EditNextCommand(task, oldTask, finishedOnceTask);
        } else {
            return null;
        }
    }

}
```
###### /java/seedu/address/logic/commands/HelpCommand.java
``` java
package seedu.address.logic.commands;

/**
 * Format full help instructions for every command for display.
 */
public class HelpCommand extends Command {

    public static final String COMMAND_WORD = "help";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Shows program usage instructions.\n"
            + "Example: " + COMMAND_WORD;

    public static final String SHOWING_HELP_MESSAGE = "Please add command keyword after help.\n"
            + "The basic command words are as follows:\n"
            + "Add, clear, delete, edit, find, finish, list, scroll, view, undo and redo.\n"
            + "Example: help add";

    private String usageMessage;

    /**
     * Creates a HelpCommand using one command .
     */

    public HelpCommand(String helpMessage) {
        super();
        usageMessage = helpMessage;
    }

    public HelpCommand() {
        super();
    }

    @Override
    public CommandResult execute() {
        if (usageMessage == null) {
            return new CommandResult(SHOWING_HELP_MESSAGE);
        } else {
            return new CommandResult(usageMessage);
        }
    }

    @Override
    public boolean isUndoable() {
        return false;
    }
}
```
###### /java/seedu/address/logic/commands/ListAllCommand.java
``` java
package seedu.address.logic.commands;

import static seedu.address.logic.commands.ListCommand.MESSAGE_LIST_DOES_NOT_EXIST;

import java.util.HashSet;
import java.util.Set;

import seedu.address.commons.core.EventsCenter;
import seedu.address.commons.events.ui.JumpToTagListRequestEvent;
import seedu.address.model.TaskManager;

/**
 * Lists all tasks (finished and unfinished) in Dueue or in a specified list.
 */
public class ListAllCommand extends Command {

    public static final String COMMAND_WORD = "list";

    public static final String MESSAGE_LIST_ALL_SUCCESS = "All tasks are listed!";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": List tasks as per the parameters\n"
            + "the specified listname and displays them as a list with index numbers.\n"
            + "Parameters: [all/favorite/finished] [LIST_NAME]\n"
            + "Example: " + COMMAND_WORD + "\n"
            + COMMAND_WORD + " all study\n"
            + COMMAND_WORD + " finished\n"
            + COMMAND_WORD + "study work\n";

    private final Set<String> keywords;

    public ListAllCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    public ListAllCommand() {
        keywords = new HashSet<String>();
    }

    @Override
    public CommandResult execute() {
        assert keywords != null;
        if (keywords.isEmpty()) {
            model.updateFilteredListToShowAllTasks();
            LOGGER.info(getClass() + "listed all tasks");
            return new CommandResult(MESSAGE_LIST_ALL_SUCCESS);
        } else if (model.isListExist(keywords)) {
            highlightCurrentTagName(keywords);
            model.updateFilteredTaskListGivenListNameAll(keywords);
            LOGGER.info(getClass() + "listed all tasks in the given lists");
            return new CommandResult(CommandFormatter.listFormatter(MESSAGE_LIST_ALL_SUCCESS, keywords));
        } else {
            LOGGER.info(getClass() + "all the listnames given are not found");
            return new CommandResult(MESSAGE_LIST_DOES_NOT_EXIST);
        }
    }
```
###### /java/seedu/address/logic/commands/ListFavoriteCommand.java
``` java
package seedu.address.logic.commands;

import static seedu.address.logic.commands.ListCommand.MESSAGE_LIST_DOES_NOT_EXIST;

import java.util.HashSet;
import java.util.Set;

import seedu.address.commons.core.EventsCenter;
import seedu.address.commons.events.ui.JumpToTagListRequestEvent;
import seedu.address.model.TaskManager;

/**
 * Lists all favorite unfinished tasks in Dueue or in a specified list.
 */
public class ListFavoriteCommand extends Command {

    public static final String LIST_ALL = "all";
    public static final String LIST_FINISHED = "finished";
    public static final String LIST_FAVORITE = "favorite";

    public static final String MESSAGE_LIST_FAVORITE_SUCCESS = "Favorite tasks are listed!";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": List tasks as per the parameters\n"
            + "the specified listname and displays them as a list with index numbers.\n"
            + "Parameters: [all/favorite/finished] [LIST_NAME]\n"
            + "Example: " + COMMAND_WORD + "\n"
            + COMMAND_WORD + " all study\n"
            + COMMAND_WORD + " finished\n"
            + COMMAND_WORD + "study work\n";

    private final Set<String> keywords;

    public ListFavoriteCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    public ListFavoriteCommand() {
        keywords = new HashSet<String>();
    }

    @Override
    public CommandResult execute() {
        assert keywords != null;
        if (keywords.isEmpty()) {
            model.updateFilteredListToShowAllFavoriteTasks();
            LOGGER.info(getClass() + " listed all favorite tasks");
            return new CommandResult(MESSAGE_LIST_FAVORITE_SUCCESS);
        } else if (model.isListExist(keywords)) {
            highlightCurrentTagName(keywords);
            model.updateFilteredTaskListGivenListNameAllFavorite(keywords);
            LOGGER.info(getClass() + " listed all favorite tasks in the given lists");
            return new CommandResult(CommandFormatter.listFormatter(MESSAGE_LIST_FAVORITE_SUCCESS, keywords));
        } else {
            LOGGER.info(getClass() + " all the listnames given are not found");
            return new CommandResult(MESSAGE_LIST_DOES_NOT_EXIST);
        }
    }
```
###### /java/seedu/address/logic/commands/ListFinishedCommand.java
``` java
package seedu.address.logic.commands;

import static seedu.address.logic.commands.ListCommand.MESSAGE_LIST_DOES_NOT_EXIST;

import java.util.HashSet;
import java.util.Set;

import seedu.address.commons.core.EventsCenter;
import seedu.address.commons.events.ui.JumpToTagListRequestEvent;
import seedu.address.model.TaskManager;

/**
 * Lists all finished tasks in Dueue or in a specified list.
 */
public class ListFinishedCommand extends Command {

    public static final String COMMAND_WORD = "list";

    public static final String MESSAGE_LIST_FINISHED_SUCCESS = "Finished tasks are listed! Well done!\n";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": List tasks as per the parameters\n"
            + "the specified listname and displays them as a list with index numbers.\n"
            + "Parameters: [all/favorite/finished] [LIST_NAME]\n"
            + "Example: " + COMMAND_WORD + "\n"
            + COMMAND_WORD + " all study\n"
            + COMMAND_WORD + " finished\n"
            + COMMAND_WORD + "study work\n";

    private final Set<String> keywords;

    public ListFinishedCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    public ListFinishedCommand() {
        keywords = new HashSet<String>();
    }

    @Override
    public CommandResult execute() {
        assert keywords != null;
        if (keywords.isEmpty()) {
            model.updateFilteredListToShowAllFinishedTasks();
            LOGGER.info(getClass() + " listed all finished tasks");
            return new CommandResult(MESSAGE_LIST_FINISHED_SUCCESS);
        } else if (model.isListExist(keywords)) {
            highlightCurrentTagName(keywords);
            model.updateFilteredTaskListGivenListNameFinished(keywords);
            LOGGER.info(getClass() + " listed all finished tasks in the given lists");
            return new CommandResult(CommandFormatter.listFormatter(MESSAGE_LIST_FINISHED_SUCCESS, keywords));
        } else {
            LOGGER.info(getClass() + " all the listnames given are not found");
            return new CommandResult(MESSAGE_LIST_DOES_NOT_EXIST);
        }
    }
```
###### /java/seedu/address/logic/commands/ViewOnCommand.java
``` java
package seedu.address.logic.commands;

import java.util.Calendar;
import java.util.TimeZone;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.task.TaskDate;

/**
 * List tasks due on a specified date in Dueue.
 */
public class ViewOnCommand extends Command {

    public static final String COMMAND_WORD = "view";

    public static final String MESSAGE_SUCCESS = "View all tasks due on %s days later\n";
    public static final String MESSAGE_SUCCESS_TODAY = "View all tasks due today\n";
    public static final String MESSAGE_SUCCESS_TMR = "View all tasks due on tomorrow\n";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": List tasks due on "
            + "the specified date and displays them as a list with index numbers.\n"
            + "Parameters: on/[number of days from today/date]\n"
            + "Example: " + COMMAND_WORD + " on/tmr\n";
    public static final String MESSAGE_NONNEGATIVE = "The number of days in the future cannot be negative.\n";

    private final String numberOfDays;

    public ViewOnCommand(int numberDays) throws IllegalValueException {
        if (numberDays < 0) {
            throw new IllegalValueException(MESSAGE_NONNEGATIVE);
        }
        numberOfDays = String.valueOf(numberDays);
    }

    public ViewOnCommand(TaskDate date) throws IllegalValueException {
        Calendar today = Calendar.getInstance(TimeZone.getTimeZone("Asia/Singapore"));
        TaskDate todayDate = new TaskDate(TaskDate.getDateString(today));
        int numberDays = date.compareToDay(todayDate);
        if (numberDays < 0) {
            throw new IllegalValueException(MESSAGE_NONNEGATIVE);
        }
        numberOfDays = String.valueOf(date.compareToDay(todayDate));
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskListGivenDaysToDueOn(numberOfDays);
        LOGGER.info(getClass() + " listed all tasks on " + numberOfDays);
        String messageDisplay = CommandFormatter.viewCommandFeedBackMessageFormatter(
                numberOfDays, MESSAGE_SUCCESS, MESSAGE_SUCCESS_TODAY, MESSAGE_SUCCESS_TMR);
        return new CommandResult(messageDisplay);
    }

    @Override
    public boolean isUndoable() {
        return false;
    }
}
```
###### /java/seedu/address/logic/parser/HelpCommandParser.java
``` java
package seedu.address.logic.parser;

import seedu.address.logic.commands.AddCommand;
import seedu.address.logic.commands.ClearCommand;
import seedu.address.logic.commands.Command;
import seedu.address.logic.commands.DeleteCommand;
import seedu.address.logic.commands.EditCommand;
import seedu.address.logic.commands.ExitCommand;
import seedu.address.logic.commands.FindCommand;
import seedu.address.logic.commands.FinishCommand;
import seedu.address.logic.commands.HelpCommand;
import seedu.address.logic.commands.ListCommand;
import seedu.address.logic.commands.LoadCommand;
import seedu.address.logic.commands.ScrollToCommand;
import seedu.address.logic.commands.ViewNextCommand;
import seedu.address.logic.commands.ViewOnCommand;

/**
 * Parses input arguments and creates a new HelpCommand object
 */
public class HelpCommandParser {

    private static HelpCommandParser theOne;

    private HelpCommandParser() {
    }

    public static HelpCommandParser getInstance() {
        if (theOne == null) {
            theOne = new HelpCommandParser();
        }
        return theOne;
    }

    /**
     * Parses the given {String} of arguments in the context of the HelpCommand
     * and returns a HelpCommand object for execution.
     */
    public Command parse(String args) {
        if (args == null) {
            return new HelpCommand();
        }
        // keywords delimited by whitespace
        final String commandWord = args.trim();
        final String helpMessage = parseCommand(commandWord);
        if (helpMessage == null) {
            return new HelpCommand();
        } else {
            return new HelpCommand(helpMessage);
        }
    }

    /**
     * Parses the given {String} of command in the context of the HelpCommand
     * and returns the help message of the corresponding command.
     *
     * Considering to make it more generic together with the similar part in Parser.
     */
    private static String parseCommand(String commandWord) {
        switch (commandWord) {
        case AddCommand.COMMAND_WORD:
            return AddCommand.MESSAGE_USAGE;

        case EditCommand.COMMAND_WORD:
            return EditCommand.MESSAGE_USAGE;

        case DeleteCommand.COMMAND_WORD:
            return DeleteCommand.MESSAGE_USAGE;

        case ClearCommand.COMMAND_WORD:
            return ClearCommand.MESSAGE_USAGE;

        case FindCommand.COMMAND_WORD:
            return FindCommand.MESSAGE_USAGE;

        case ListCommand.COMMAND_WORD:
            return ListCommand.MESSAGE_USAGE;

        case LoadCommand.COMMAND_WORD:
            return LoadCommand.MESSAGE_USAGE;

        case ExitCommand.COMMAND_WORD:
            return ExitCommand.MESSAGE_USAGE;

        case HelpCommand.COMMAND_WORD:
            return HelpCommand.MESSAGE_USAGE;

        case FinishCommand.COMMAND_WORD:
            return FinishCommand.MESSAGE_USAGE;

        case ScrollToCommand.COMMAND_WORD:
            return ScrollToCommand.MESSAGE_USAGE;

        case ViewNextCommand.COMMAND_WORD:
            return ViewNextCommand.MESSAGE_USAGE + "\n" + ViewOnCommand.MESSAGE_USAGE;

        default:
            return null;
        }
    }
}
```
###### /java/seedu/address/logic/parser/ListCommandParser.java
``` java
package seedu.address.logic.parser;

import static seedu.address.logic.parser.CliSyntax.KEYWORDS_ARGS_FORMAT_LIST;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Matcher;

import seedu.address.logic.commands.Command;
import seedu.address.logic.commands.ListAllCommand;
import seedu.address.logic.commands.ListCommand;
import seedu.address.logic.commands.ListFavoriteCommand;
import seedu.address.logic.commands.ListFinishedCommand;

/**
 * Parses input arguments and creates a new ListCommand/ListAllCommand/ListFinishedCommand/ListFavoriteCommand object
 */
public class ListCommandParser {

    private static final String LIST_SEPARATOR = "\\s+";
    public static final String LIST_ALL = "all";
    public static final String LIST_FINISHED = "finished";
    public static final String LIST_FAVORITE = "favorite";

    private static ListCommandParser theOne;

    private ListCommandParser() {
    }

    public static ListCommandParser getInstance() {
        if (theOne == null) {
            theOne = new ListCommandParser();
        }
        return theOne;
    }

    /**
     * Parses the given {@code String} of arguments in the context of the ListCommand
     * and returns a ListCommand/ListAllCommand/ListFinishedCommand/ListFavoriteCommand object for execution.
     */
    public Command parse(String args) {
        if (args == null) {
            return new ListCommand();
        }

        // if do not match any pattern, show all the unfinished task
        final Matcher matcher = KEYWORDS_ARGS_FORMAT_LIST.matcher(args.trim());
        if (!matcher.matches()) {
            return new ListCommand();
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split(LIST_SEPARATOR);
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));

        // check for the indicator words in the keywords
        if (keywordSet.contains(LIST_ALL)) {
            keywordSet.remove(LIST_ALL);
            return new ListAllCommand(keywordSet);
        } else if (keywordSet.contains(LIST_FINISHED)) {
            keywordSet.remove(LIST_FINISHED);
            return new ListFinishedCommand(keywordSet);
        } else if (keywordSet.contains(LIST_FAVORITE)) {
            keywordSet.remove(LIST_FAVORITE);
            return new ListFavoriteCommand(keywordSet);
        } else {
            return new ListCommand(keywordSet);
        }
    }

}
```
###### /java/seedu/address/logic/parser/ViewCommandParser.java
``` java
package seedu.address.logic.parser;

import static seedu.address.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.Command;
import seedu.address.logic.commands.IncorrectCommand;
import seedu.address.logic.commands.ViewNextCommand;
import seedu.address.logic.commands.ViewOnCommand;
import seedu.address.model.task.TaskDate;

/**
 * Parses input arguments and creates a new ViewNextCommand/ViewOnCommand object
 */
public class ViewCommandParser {

    private static ViewCommandParser theOne;
    public static final String MESSAGE_NONNEGATIVE = "The number of days in the future cannot be negative.\n";

    private ViewCommandParser() {}

    public static ViewCommandParser getInstance() {
        if (theOne == null) {
            theOne = new ViewCommandParser();
        }
        return theOne;
    }

    /**
     * Parses the given {@code String} of arguments in the context of the ViewNextCommand
     * and returns an ViewNextCommand object for execution.
     * @throws IllegalValueException
     */
    public Command parse(String args) {
        if (args == null || args.equals("")) {
            return parseNoParamGiven();
        }

        String[] parameters = formatter(args);
        if (parameters[0].equals("next") || parameters[0].equals("by")) {
            return parseViewNext(parameters);
        } else if (parameters[0].equals("on")) {
            return parseViewOn(parameters);
        } else {
            return new IncorrectCommand(String.format(
                MESSAGE_INVALID_COMMAND_FORMAT, ViewNextCommand.MESSAGE_USAGE));
        }
    }

    private static Command parseNoParamGiven() {
        try {
            return new ViewNextCommand(0);
        } catch (IllegalValueException e) {
            return new IncorrectCommand(String.format(
                    MESSAGE_INVALID_COMMAND_FORMAT, ViewNextCommand.MESSAGE_USAGE));
        }
    }

    private static Command parseViewNext(String[] parameters) {
        try {
            if (Integer.valueOf(parameters[1]) < 0) {
                return new IncorrectCommand(String.format(
                        MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_NONNEGATIVE));
            } else {
                return new ViewNextCommand(Integer.valueOf(parameters[1]));
            }
        } catch (NumberFormatException nfe) {
            try {
                TaskDate date = new TaskDate(parameters[1]);
                return new ViewNextCommand(date);
            } catch (IllegalValueException e) {
                return new IncorrectCommand(String.format(
                    MESSAGE_INVALID_COMMAND_FORMAT, ViewNextCommand.MESSAGE_USAGE));
            }
        } catch (IllegalValueException e) {
            return new IncorrectCommand(String.format(
                    MESSAGE_INVALID_COMMAND_FORMAT, ViewNextCommand.MESSAGE_USAGE));
        }
    }

    private static Command parseViewOn(String[] parameters) {
        try {
            if (Integer.valueOf(parameters[1]) < 0) {
                return new IncorrectCommand(String.format(
                        MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_NONNEGATIVE));
            } else {
                return new ViewOnCommand(Integer.valueOf(parameters[1]));
            }
        } catch (NumberFormatException nfe) {
            try {
                TaskDate date = new TaskDate(parameters[1]);
                return new ViewOnCommand(date);
            } catch (IllegalValueException e) {
                return new IncorrectCommand(String.format(
                        MESSAGE_INVALID_COMMAND_FORMAT, ViewOnCommand.MESSAGE_USAGE));
            }
        } catch (IllegalValueException e) {
            return new IncorrectCommand(String.format(
                    MESSAGE_INVALID_COMMAND_FORMAT, ViewOnCommand.MESSAGE_USAGE));
        }
    }

    public static String[] formatter(String args) {
        String argument = args.trim();
        String[] parameters = argument.split("/", 2);
        return parameters;
    }
}
```
###### /java/seedu/address/model/ModelManager.java
``` java
    @Override
    public boolean isListExist(Set<String> listNames) {
        updateFilteredTagList(new PredicateExpression(new NameQualifier(listNames)));
        boolean isListExist = filteredTag.size() > 0;
        updateFilteredTagListToShowAllTags();
        return isListExist;
    }

    //========== Inner classes/interfaces used for filtering =================================================

    interface Expression {
        boolean satisfies(ReadOnlyTask task);
        boolean satisfies(Tag list);
        String toString();
    }

```
###### /java/seedu/address/model/task/Description.java
``` java
    @Override
    public String getDisplayText() {
        if ((" ".equals(value)) || ("".equals(value))) {
            return "";
        } else {
            return value;
        }
    }
}
```
###### /java/seedu/address/model/task/Name.java
``` java
    @Override
    public String getDisplayText() {
        if ((fullName.equals(" ")) || (fullName.equals(""))) {
            return "";
        } else {
            return fullName;
        }
    }
}
```
###### /java/seedu/address/model/task/ReadOnlyTask.java
``` java
    /*
     * Get the FinishProperty instead of boolean
     */
    FinishProperty getFinished();
    EventProperty getEventProperty();
    RecurringProperty getRecurringProperty();

    /*
     * Ensure there is no null pointer exception when comparing two TaskFields
     */
    default boolean checkEqual(TaskField mine, TaskField other) {
        if (mine == null) {
            return other == null;
        } else {
            return mine.equals(other);
        }
    }
```
###### /java/seedu/address/model/task/TaskDate.java
``` java
    @Override
    public String getDisplayText() {
        if (" ".equals(value) || "".equals(value)) {
            return "";
        } else {
            return "Date: " + value;
        }
    }

    public int compareToDay(TaskDate other) {
        if (value.isEmpty()) {
            if (other.value.isEmpty()) {
                return 0;
            } else {
                return INF;
            }
        } else {
            if (value.isEmpty()) {
                return -INF;
            } else {
                long diff = this.date.getTime() - other.date.getTime();
                return (int) TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS);
            }
        }
    }

```
###### /java/seedu/address/model/task/TaskField.java
``` java
/*
 * A read-only immutable interface for any field of a task.
 */
package seedu.address.model.task;

public interface TaskField {

    public abstract String getDisplayText ();

    public abstract String getValue();

}
```
###### /java/seedu/address/model/task/TaskTime.java
``` java
    @Override
    public String getDisplayText() {
        if (" ".equals(value) || "".equals(value)) {
            return "";
        } else {
            return "Time: " + value;
        }
    }
```
###### /java/seedu/address/model/task/Venue.java
``` java
    @Override
    public String getDisplayText() {
        if (" ".equals(value) || "".equals(value)) {
            return "";
        } else {
            return "Venue: " + value;
        }
    }
}
```
