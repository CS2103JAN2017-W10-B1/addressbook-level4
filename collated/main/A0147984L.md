# A0147984L
###### /java/seedu/address/logic/commands/EditNextCommand.java
``` java
package seedu.address.logic.commands;

import java.util.List;

import seedu.address.commons.core.Messages;
import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.model.task.Event;
import seedu.address.model.task.ReadOnlyRecurringTask;
import seedu.address.model.task.ReadOnlyTask;
import seedu.address.model.task.ReadOnlyTask.RecurringProperty;
import seedu.address.model.task.RecurringEvent;
import seedu.address.model.task.RecurringTask;
import seedu.address.model.task.Task;
import seedu.address.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.address.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Edits the details of an existing recurring task in Dueue.
 */
public class EditNextCommand extends EditCommand {

```
###### /java/seedu/address/logic/commands/EditTaskDescriptor.java
``` java
    public void setRecurringMode(Optional<String> ocurrence) {
        if (ocurrence.isPresent()) {
            String ocurring = ocurrence.orElse("");
            if (ocurring.matches(RecurringTask.PERIOD_DAY_REGEX)) {
                this.recurringMode = RecurringMode.DAY;
            } else if (ocurring.matches(RecurringTask.PERIOD_WEEK_REGEX)) {
                this.recurringMode = RecurringMode.WEEK;
            } else if (ocurring.matches(RecurringTask.PERIOD_MONTH_REGEX)) {
                this.recurringMode = RecurringMode.MONTH;
            }
        } else {
            this.recurringMode = null;
        }
    }

    public RecurringMode getRecurringMode() {
        return this.recurringMode;
    }
```
###### /java/seedu/address/model/Model.java
``` java
    /**
     * Finish the recurring task once
     */
    void finishTaskOnce(ReadOnlyTask recurringTask)
            throws UniqueTaskList.DuplicateTaskException;

    /**
     * Update the recurring task located at {@code filteredTaskListIndex} with {@code editTask}
     */
    void updateTaskOnOccurance(int filteredTaskListIndex, ReadOnlyTask editedTask)
            throws UniqueTaskList.DuplicateTaskException;
```
###### /java/seedu/address/model/Model.java
``` java
    // Task-level filter
    /**
     * Update the filter of the filter task given specific fields
     *
     * @param nameKeywords indicates the name field
     * @param tagKeywords indicates the tag search field
     * @param finishedState indicates the finished search field (ALL/UNFINISHED/FINISHED)
     * @param isFavorite indicates the favorite search field
     * @param dueMode indicates the view mode on due (ON/BY)
     * @param days indicates the days until due
     */
    void updateFilteredTaskList(Set<String> nameKeywords, Set<String> tagKeywords,
            FinishedState finishedState, boolean isFavorite,
            DueMode dueMode, String days);

    /** Updates the filter of the unfinished filtered task list to filter by the given keywords*/
    void updateFilteredTaskList(Set<String> keywords);

    /** Updates the filter of the filtered task list to show all favorite tasks */
    void updateFilteredListToShowAllFavoriteTasks();

    /** Updates the filter of the filtered task list to show all unfinished tasks */
    void updateFilteredListToShowAllUnfinishedTasks();

    /** Updates the filter of the filtered task list to show all tasks */
    void updateFilteredListToShowAllTasks();

    /** Updates the filter of the filtered task list to show all finished tasks */
    void updateFilteredListToShowAllFinishedTasks();

    /** Updates the filter of the filtered task list to filter by the given keywords*/
    void updateFilteredTaskListFinished(Set<String> keywords);

    /** Updates the filter of the filtered task list to filter by the given keywords*/
    void updateFilteredTaskListAll(Set<String> keywords);

    /** Updates the filter of the filtered task list to filter by the given keywords*/
    void updateFilteredTaskListFavorite(Set<String> keywords);

    /** Updates the filter of the unfinished filtered task list to filter by the given list name*/
    void updateFilteredTaskListGivenListName(Set<String> keywords);

    /** Updates the filter of the filtered task list to filter by the given list name*/
    void updateFilteredTaskListGivenListNameAll(Set<String> keywords);

    /** Updates the filter of the finished filtered task list to filter by the given list name*/
    void updateFilteredTaskListGivenListNameFinished(Set<String> keywords);

    /** Updates the filter of the favorite filtered task list to filter by the given list name*/
    void updateFilteredTaskListGivenListNameAllFavorite(Set<String> keywords);

    /** Updates the filter of the filtered task list to filter by the days to due*/
    void updateFilteredTaskListGivenDaysToDueBy(String days);

    /** Updates the filter of the filtered task list to filter on the days to due*/
    void updateFilteredTaskListGivenDaysToDueOn(String days);

    // Tag-level filter

    /** Updates the filter of the filtered tag list to show all tasks */
    void updateFilteredTagListToShowAllTags();

    /** Check whether the list name exist*/
    boolean isListExist(Set<String> listNames);

}
```
###### /java/seedu/address/model/ModelManager.java
``` java
    @Override
    public void finishTaskOnce(ReadOnlyTask recurringTask)
            throws DuplicateTaskException {
        assert recurringTask != null;

        logger.info("target recurring task is finished");
        taskManager.finishTaskOnce(recurringTask);
        indicateTaskManagerChanged();
    }

    @Override
    public void updateTaskOnOccurance(int filteredTaskListIndex, ReadOnlyTask editedTask)
            throws UniqueTaskList.DuplicateTaskException {
        assert editedTask != null;

        logger.info("the latest occurance of target recurring task is updated");
        int taskManagerIndex = filteredTasks.getSourceIndex(filteredTaskListIndex);
        taskManager.updateTaskOnce(taskManagerIndex, editedTask);
        indicateTaskManagerChanged();
    }
```
###### /java/seedu/address/model/ModelManager.java
``` java
    @Override
    public void updateFilteredTaskList(Set<String> nameKeywords, Set<String> tagKeywords,
            FinishedState finishedState, boolean isFavorite,
            DueMode dueMode, String days) {

        NameQualifier nameQualifier = nameKeywords == null ? null : new NameQualifier(nameKeywords);
        TagQualifier tagQualifier = tagKeywords == null ? null : new TagQualifier(tagKeywords);
        FinishedQualifier finishedQualifier = new FinishedQualifier(finishedState);
        FavoriteQualifier favoriteQualifier = isFavorite ? new FavoriteQualifier() : null;
        DateQualifier dateQualifier = constructDateQualifier(dueMode, days);

        logger.info("the filtered list is returned, with filter: "
                + nameQualifier + "; " + tagQualifier + "; " + finishedQualifier + "; "
                + favoriteQualifier + "; " + dateQualifier + ".");

        updateFilteredTaskList(new PredicateExpression(
                nameQualifier, tagQualifier, finishedQualifier, favoriteQualifier, dateQualifier));
    }

    @Override
    public void updateFilteredTaskList(Set<String> keywords) {
        updateFilteredTaskList(keywords, null, FinishedState.UNFINISHED, false, null, null);
    }

    private void updateFilteredTaskList(Expression expression) {
        filteredTasks.setPredicate(expression::satisfies);
    }

    private DateQualifier constructDateQualifier(DueMode dueMode, String days) {
        if (dueMode == null) {
            return null;
        } else if (dueMode.equals(DueMode.BY)) {
            return new DateQualifierBy(days);
        } else if (dueMode.equals(DueMode.ON)) {
            return new DateQualifierOn(days);
        } else {
            return null;
        }
    }

    @Override
    public void updateFilteredListToShowAllUnfinishedTasks() {
        updateFilteredTaskList(null, null, FinishedState.UNFINISHED, false, null, null);
    }

    @Override
    public void updateFilteredListToShowAllTasks() {
        filteredTasks.setPredicate(null);
    }

    @Override
    public void updateFilteredListToShowAllFinishedTasks() {
        updateFilteredTaskList(null, null, FinishedState.FINISHED, false, null, null);
    }

    @Override
    public void updateFilteredListToShowAllFavoriteTasks() {
        updateFilteredTaskList(null, null, FinishedState.ALL, true, null, null);
    }

    @Override
    public void updateFilteredTaskListFinished(Set<String> keywords) {
        updateFilteredTaskList(keywords, null, FinishedState.FINISHED, false, null, null);
    }

    @Override
    public void updateFilteredTaskListAll(Set<String> keywords) {
        updateFilteredTaskList(keywords, null, FinishedState.ALL, false, null, null);
    }

    @Override
    public void updateFilteredTaskListFavorite(Set<String> keywords) {
        updateFilteredTaskList(keywords, null, FinishedState.UNFINISHED, true, null, null);
    }

    @Override
    public void updateFilteredTaskListGivenListName(Set<String> keywords) {
        updateFilteredTaskList(null, keywords, FinishedState.UNFINISHED, false, null, null);
    }

    @Override
    public void updateFilteredTaskListGivenListNameAll(Set<String> keywords) {
        updateFilteredTaskList(null, keywords, FinishedState.ALL, false, null, null);
    }

    @Override
    public void updateFilteredTaskListGivenListNameFinished(Set<String> keywords) {
        updateFilteredTaskList(null, keywords, FinishedState.FINISHED, false, null, null);
    }

    @Override
    public void updateFilteredTaskListGivenListNameAllFavorite(Set<String> keywords) {
        updateFilteredTaskList(null, keywords, FinishedState.ALL, true, null, null);
    }

    @Override
    public void updateFilteredTaskListGivenDaysToDueBy(String days) {
        updateFilteredTaskList(null, null, FinishedState.UNFINISHED, false, DueMode.BY, days);
    }

    @Override
    public void updateFilteredTaskListGivenDaysToDueOn(String days) {
        updateFilteredTaskList(null, null, FinishedState.UNFINISHED, false, DueMode.ON, days);
    }

    //=========== Filtered List Accessors =============================================================
```
###### /java/seedu/address/model/ModelManager.java
``` java
    public UnmodifiableObservableList<Tag> getFilteredTagList() {
        return new UnmodifiableObservableList<>(filteredTag);
    }

    public void updateFilteredTagListToShowAllTags() {
        filteredTag.setPredicate(null);
    }

    private void updateFilteredTagList(Expression expression) {
        filteredTag.setPredicate(expression::satisfies);
    }
```
###### /java/seedu/address/model/ModelManager.java
``` java
    private class PredicateExpression implements Expression {

        private final HashSet<Qualifier> qualifiers;

        PredicateExpression(Qualifier...qualifiers) {
            this.qualifiers = new HashSet<>();
            for (Qualifier qualifier : qualifiers) {
                if (qualifier != null) {
                    this.qualifiers.add(qualifier);
                }
            }
        }

        @Override
        public boolean satisfies(ReadOnlyTask task) {
            return qualifiers.stream().
                    filter(qualifier -> qualifier.run(task)).count()
                    == this.qualifiers.size();
        }

        @Override
        public boolean satisfies(Tag list) {
            return qualifiers.stream().
                    filter(qualifier -> qualifier.run(list)).count()
                    == this.qualifiers.size();
        }

        @Override
        public String toString() {
            String returnString = "";
            for (Qualifier qualifier : this.qualifiers) {
                returnString += qualifier.toString();
            }
            return returnString;
        }
    }
```
###### /java/seedu/address/model/ModelManager.java
``` java
    private class FinishedQualifier implements Qualifier {
        protected FinishedState state;

        FinishedQualifier(FinishedState state) {
            this.state = state;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            if (state.equals(FinishedState.FINISHED)) {
                return task.isFinished();
            } else if (state.equals(FinishedState.UNFINISHED)) {
                return !task.isFinished();
            } else {
                return true;
            }
        }

```
###### /java/seedu/address/model/ModelManager.java
``` java

    private class TagQualifier implements Qualifier {
        protected Set<String> tagKeyWords;

        TagQualifier(Set<String> tagKeyWords) {
            this.tagKeyWords = tagKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return tagKeyWords.stream()
                    .filter(keyword -> StringUtil.containsWordIgnoreCase(task.getTag().getName(), keyword))
                    .findAny()
                    .isPresent();
        }

        @Override
        public boolean run(Tag list) {
            return false;
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", tagKeyWords);
        }
    }

    private abstract class DateQualifier implements Qualifier {
        protected int daysToDue;
        protected Calendar today;

        DateQualifier(String days) {
            this.daysToDue = Integer.parseInt(days);
            initializeToday();
        }

        private void initializeToday() {
            today = Calendar.getInstance(TimeZone.getTimeZone("Asia/Singapore"));
            today.set(Calendar.HOUR_OF_DAY, 0);
            today.set(Calendar.MINUTE, 0);
            today.set(Calendar.SECOND, 0);
            today.set(Calendar.MILLISECOND, 0);
        }

        @Override
        public abstract boolean run(ReadOnlyTask task);

        @Override
        public boolean run(Tag list) {
            return false;
        }

        @Override
        public abstract String toString();
    }

    private class DateQualifierOn extends DateQualifier {

        DateQualifierOn(String days) {
            super(days);
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            long diff = task.getDate().date.getTime() - today.getTime().getTime();
            return daysToDue == TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS);
        }

        @Override
        public String toString() {
            return "daysOnDue=" + daysToDue;
        }
    }

    private class DateQualifierBy extends DateQualifier {

        DateQualifierBy(String days) {
            super(days);
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            long diff = task.getDate().date.getTime() - today.getTime().getTime();
            return (daysToDue >= TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS))
                    &&
                    (0 <= TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS));
        }

        @Override
        public String toString() {
            return "daysToDue=" + daysToDue;
        }
    }
}
```
###### /java/seedu/address/model/tag/Tag.java
``` java
package seedu.address.model.tag;

import seedu.address.commons.exceptions.IllegalValueException;

import seedu.address.model.task.TaskField;

/**
 * Represents a Tag in the address book.
 * Guarantees: immutable; name is valid as declared in {@link #isValidTagName(String)}
 */
public class Tag implements TaskField, Comparable<Tag> {

    public static final String MESSAGE_TAG_CONSTRAINTS_1 = "Tags names should be alphanumeric without space";
    public static final String MESSAGE_TAG_CONSTRAINTS_2 = " is reserved so cannot be used as a tag name";
    public static final String TAG_VALIDATION_REGEX = "\\p{Alnum}+";
    public static final String TAG_RESERVED_NAME =
            "(?i)"
            + "(list)|(finished)|(unfinished)|(favorite)|(favourite)|"
            + "(today)|(tomorrow)|(all)|"
            + "(add)|(delete)|(edit)|(update)|(find)|(help)|(list)|(clear)|(finish)|(scroll)|(load)";
    public static final String DEFAULT_TAG_NAME = "Inbox";
    public String tagName;


    /**
     * Validates given tag name.
     *
     * @throws IllegalValueException if the given tag name string is invalid.
     */
    public Tag(String name) throws IllegalValueException {
        assert name != null;
        String trimmedName = name.trim();
        if (!isValidTagName(trimmedName)) {
            throw new IllegalValueException(MESSAGE_TAG_CONSTRAINTS_1);
        }
        if (isReservedName(trimmedName)) {
            throw new IllegalValueException(trimmedName + MESSAGE_TAG_CONSTRAINTS_2);
        }
        this.tagName = trimmedName.isEmpty() ? DEFAULT_TAG_NAME : trimmedName;
    }

    /**
     * Creates a copy of the given Tag.
     */
    public Tag(Tag source) throws IllegalValueException {
        this(source.getName());
    }

     /**
     * Returns true if a given string is a valid tag name.
     * @throws IllegalValueException
     */
    public static boolean isValidTagName(String test) throws IllegalValueException {
        if (test.isEmpty()) {
            return true;
        }
        return test.matches(TAG_VALIDATION_REGEX);
    }

    public static boolean isReservedName(String test) {
        return test.matches(TAG_RESERVED_NAME);
    }

    public String getName() {
        return this.tagName;
    }
```
###### /java/seedu/address/model/task/Description.java
``` java
package seedu.address.model.task;

import seedu.address.commons.exceptions.IllegalValueException;

/**
 * Represents a Task's description in the task manager.
 * Guarantees: is valid as declared in {@link #isValidDescription(String)}
 */
public class Description implements TaskField, Comparable<Description> {

    public static final String MESSAGE_DESCRIPTION_CONSTRAINTS = "Task description can be in any form.";
    public static final String DESCRIPTION_VALIDATION_REGEX = ".*";

    private final String value;

    /**
     * Validates given task description.
     *
     * @throws IllegalValueException if given description string is invalid.
     */
    public Description(String description) throws IllegalValueException {
        assert description != null;
        String trimmedDescription = description.trim();
        if (!isValidDescription(trimmedDescription)) {
            throw new IllegalValueException(MESSAGE_DESCRIPTION_CONSTRAINTS);
        }
        this.value = trimmedDescription;
    }

    /**
     * Returns true if a given string is a valid task description.
     */
    public static boolean isValidDescription(String test) {
        return test.matches(DESCRIPTION_VALIDATION_REGEX);
    }

    public String getValue() {
        return value;
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Description // instanceof handles nulls
                && this.value.equals(((Description) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

    @Override
    public int compareTo(Description other) {
        return this.value.compareTo(other.value);
    }

```
###### /java/seedu/address/model/task/Event.java
``` java
package seedu.address.model.task;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.tag.Tag;

public class Event extends Task implements ReadOnlyEvent {

    public static final String MESSAGE_EVENT_CONSTRAINT = "End date should be later than start date";
    protected TaskDate startDate;
    protected TaskTime startTime;

    /**
     * Every field must be present and not null.
     * @throws IllegalValueException
     */
    public Event(Name name, TaskDate startDate, TaskTime startTime, TaskDate endDate, TaskTime endTime,
            Description description, Tag tag, Venue venue, Priority priority, boolean isFavorite)
                    throws IllegalValueException {
        super(name, endDate, endTime, description, tag, venue, priority, isFavorite);
        this.isEvent = EventProperty.EVENT;

        if (startDate.compareTo(endDate) > 0) {
            throw new IllegalValueException(MESSAGE_EVENT_CONSTRAINT);
        } else {
            this.startDate = startDate;
            this.startTime = startTime;
        }

        if ((startDate.compareTo(endDate) == 0) && (startTime.compareTo(endTime) > 0)) {
            throw new IllegalValueException(MESSAGE_EVENT_CONSTRAINT);
        } else {
            this.startDate = startDate;
            this.startTime = startTime;
        }
    }

    /**
     *  Constructor of event with flag on isFinshed
     * @throws IllegalValueException
     */
    public Event(Name name, TaskDate startDate, TaskTime startTime, TaskDate endDate, TaskTime endTime,
            Description description, Tag tag, Venue venue,
            Priority priority, boolean isFavorite, FinishProperty isFinished)
                    throws IllegalValueException {
        this(name, startDate, startTime, endDate, endTime, description, tag, venue,  priority, isFavorite);
        this.isFinished = isFinished;
    }

    /**
     *  Constructor of event with only one date given
     * @throws IllegalValueException
     */
    public Event(Name name, TaskDate date, TaskTime startTime, TaskTime endTime,
            Description description, Tag tag, Venue venue, Priority priority, boolean isFavorite)
                    throws IllegalValueException {
        this(name, date, startTime, date, endTime, description, tag, venue,  priority, isFavorite);
    }

    /**
     *  Constructor of event with only one date given, with flag on isFinished
     * @throws IllegalValueException
     */
    public Event(Name name, TaskDate date, TaskTime startTime, TaskTime endTime,
            Description description, Tag tag, Venue venue, Priority priority,
            boolean isFavorite, FinishProperty isFinished)
                    throws IllegalValueException {
        this(name, date, startTime, date, endTime, description, tag, venue,  priority, isFavorite, isFinished);
    }

    /**
     * Creates a copy of the given ReadOnlyTask.
     * @throws IllegalValueException
     */
    public Event(ReadOnlyTask source) throws IllegalValueException {
        super(new Name(source.getName().getValue()), new TaskDate(source.getDate().getValue()),
                new TaskTime(source.getTime().getValue()), new Description(source.getDescription().getValue()),
                new Tag(source.getTag().getValue()), new Venue(source.getVenue().getValue()),
                new Priority(source.getPriority().getValue()), source.isFavorite(), source.getFinished(),
                source.getEventProperty(), source.getRecurringProperty());
        assert this.isEvent();
        this.startDate = new TaskDate(((ReadOnlyEvent) source).getStartDate().getValue());
        this.startTime = new TaskTime(((ReadOnlyEvent) source).getStartTime().getValue());
    }

    @Override
    /**
     * Updates this task with the details of {@code replacement}.
     */
    public void resetData(ReadOnlyTask replacement) {
        assert replacement != null;

        super.resetData(replacement);
        assert this.isEvent();
        try {
            this.setStartDate(new TaskDate(((ReadOnlyEvent) replacement).getStartDate().getValue()));
            this.setStartTime(new TaskTime(((ReadOnlyEvent) replacement).getStartTime().getValue()));
        } catch (IllegalValueException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

    }

    @Override
    public TaskDate getStartDate() {
        return this.startDate;
    }

    public void setStartDate(TaskDate startDate) {
        this.startDate = startDate;
    }

    @Override
    public TaskTime getStartTime() {
        return this.startTime;
    }

    public void setStartTime(TaskTime startTime) {
        this.startTime = startTime;
    }
}

```
###### /java/seedu/address/model/task/Priority.java
``` java
package seedu.address.model.task;

import seedu.address.commons.exceptions.IllegalValueException;

/**
 * Represents a Task's priority in task manager.
 * Guarantees: is valid as declared in {@link #isValidPriority(String)}
 */
public class Priority implements TaskField, Comparable<Priority> {

    public static final String PRIORITY_1 = "1";
    public static final String PRIORITY_2 = "2";
    public static final String PRIORITY_3 = "3";
    public static final String PRIORITY_TRIVIAL = "trivial";
    public static final String PRIORITY_NORMAL = "normal";
    public static final String PRIORITY_IMPORTANT = "important";
    public static final String PRIORITY_EMPTY = "";

    public static final String DEFAULT_PRIORITY = PRIORITY_2;

    public static final String MESSAGE_PRIORITY_CONSTRAINTS = "task priority can only be 1, 2, 3,"
            + "trivial, normal, or important";

    public static final String PRIORITY_VALIDATION_REGEX = PRIORITY_1 + "|" + PRIORITY_2 + "|" + PRIORITY_3;

    private final String value;

    /**
     * Validity given priority.
     *
     * @throws IllegalValueException if given priority string is invalid.
     */
    public Priority(String priority) throws IllegalValueException {
        if (priority == null) {
            this.value = DEFAULT_PRIORITY;
        } else {
            String trimmedPriority = priority.trim();
            String convertedPriority = convert(trimmedPriority);
            if (!isValidPriority(convertedPriority)) {
                throw new IllegalValueException(MESSAGE_PRIORITY_CONSTRAINTS);
            }
            this.value = convertedPriority;
        }
    }

    /**
     * Returns if a given string is a valid priority.
     */
    public static boolean isValidPriority(String test) {
        return test.matches(PRIORITY_VALIDATION_REGEX);
    }

    /**
     * Convert English expressions into digits expressions
     */
    public static String convert(String value) {
        value = value.isEmpty() ? DEFAULT_PRIORITY : value;
        value = value.replaceFirst("(?i)" + PRIORITY_IMPORTANT, PRIORITY_3);
        value = value.replaceFirst("(?i)" + PRIORITY_NORMAL, PRIORITY_2);
        value = value.replaceFirst("(?i)" + PRIORITY_TRIVIAL, PRIORITY_1);
        return value;
    }

    public String getValue() {
        return this.value;
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Priority // instanceof handles nulls
                && this.value.equals(((Priority) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

    @Override
    public int compareTo(Priority other) {
        return Integer.parseInt(this.value)
                -
                Integer.parseInt(other.value);
    }

```
###### /java/seedu/address/model/task/ReadOnlyEvent.java
``` java
package seedu.address.model.task;

public interface ReadOnlyEvent extends ReadOnlyTask {

    TaskDate getStartDate();
    TaskTime getStartTime();

    /**
     * Formats the person as text, showing all contact details.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getName());
        if (getStartDate() != null) {
            builder.append("  Start Date:");
            builder.append(getStartDate());
        }
        if (getStartTime() != null) {
            builder.append("  Start Time:");
            builder.append(getStartTime());
        }
        if (getDate() != null) {
            builder.append("  Due Date:");
            builder.append(getDate());
        }
        if (getTime() != null) {
            builder.append("  Due Time:");
            builder.append(getTime());
        }
        if (getDescription() != null) {
            builder.append("  Description:");
            builder.append(getDescription());
        }
        if (getTag() != null) {
            builder.append("  List:");
            builder.append(getTag());
        }
        if (getVenue() != null) {
            builder.append("  Venue:");
            builder.append(getVenue());
        }
        assert getPriority() != null;
        builder.append("  Priority:");
        builder.append(getPriority());
        if (isFavorite()) {
            builder.append(" favorite");
        }
        if (isFinished()) {
            builder.append(" finished");
        }
        return builder.toString();
    }
}
```
###### /java/seedu/address/model/task/ReadOnlyRecurringTask.java
``` java
package seedu.address.model.task;

public interface ReadOnlyRecurringTask extends ReadOnlyTask {
    public enum RecurringMode {
        DAY, WEEK, MONTH
    }

    void finishOnce();
    String getRecurringPeriod();
    RecurringMode getMode();

    /**
     * Formats the person as text, showing all contact details.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getName());
        if (getDate() != null) {
            builder.append("  Due Date:");
            builder.append(getDate());
        }
        if (getTime() != null) {
            builder.append("  Due Time:");
            builder.append(getTime());
        }
        if (getDescription() != null) {
            builder.append("  Description:");
            builder.append(getDescription());
        }
        if (getTag() != null) {
            builder.append("  List:");
            builder.append(getTag());
        }
        if (getVenue() != null) {
            builder.append("  Venue:");
            builder.append(getVenue());
        }
        assert getPriority() != null;
        builder.append("  Priority:");
        builder.append(getPriority());
        if (isFavorite()) {
            builder.append(" favorite");
        }
        if (isFinished()) {
            builder.append(" finished");
        }
        if (true) {
            builder.append(" " + getRecurringPeriod());
        }
        return builder.toString();
    }
}
```
###### /java/seedu/address/model/task/ReadOnlyTask.java
``` java
package seedu.address.model.task;

import seedu.address.model.tag.Tag;

/**
 * A read-only immutable interface for a Task in the TaskManager.
 * Implementations should guarantee: details are present and not null, field values are validated.
 */
public interface ReadOnlyTask {
    public enum FinishProperty {
        FINISHED, UNFINISHED
    }
    public enum EventProperty {
        EVENT, NON_EVENT
    }
    public enum RecurringProperty {
        RECURRING, NON_RECURRING
    }

    Name getName();
    TaskDate getDate();
    TaskTime getTime();
    Tag getTag();
    Description getDescription();
    Venue getVenue();
    Priority getPriority();
    boolean isFavorite();
    boolean isFinished();
    String getFavoriteText();
    String getFinishedText();
    boolean isEvent();
    boolean isRecurring();

    /**
     * Returns true if both have the same state. (interfaces cannot override equals)
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        if (this.isRecurring() ^ other.isRecurring()) {
            return false;
        }
        if (this.isEvent() ^ other.isEvent()) {
            return false;
        }
        boolean state = other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && checkEqual(this.getName(), other.getName())
                && checkEqual(this.getDate(), other.getDate())
                && checkEqual(this.getTime(), other.getTime())
                && checkEqual(this.getTag(), other.getTag())
                && ((other.getFinished() == null && this.getFinished() == null)
                        || (other.getFinished() != null && other.getFinished().equals(this.getFinished()))));
                    // state checks here onwards
        if (this.isEvent()) {
            state = state && (other instanceof ReadOnlyEvent)
                    && checkEqual(((ReadOnlyEvent) this).getStartDate(), ((ReadOnlyEvent) other).getStartDate())
                    && checkEqual(((ReadOnlyEvent) this).getStartTime(), ((ReadOnlyEvent) other).getStartTime());
                    // state checks here onwards
        }
        if (this.isRecurring() && !this.isEvent()) {
            state = state && (other instanceof ReadOnlyRecurringTask)
                    && ((((ReadOnlyRecurringTask) this).getRecurringPeriod()).equals(
                            ((ReadOnlyRecurringTask) other).getRecurringPeriod()));
        }
        return state;

    }
```
###### /java/seedu/address/model/task/RecurringTask.java
``` java
package seedu.address.model.task;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.tag.Tag;

public class RecurringTask extends Task implements ReadOnlyRecurringTask {

    public static final String PERIOD_DAILY = "every day";
    public static final String PERIOD_WEEKLY = "every week";
    public static final String PERIOD_MONTHLY = "every month";

    public static final String PERIOD_DAY_REGEX = "(?i)((every)?(\\s)*(day))|(daily)";
    public static final String PERIOD_WEEK_REGEX = "(?i)((every)?(\\s)*(week))|(weekly)";
    public static final String PERIOD_MONTH_REGEX = "(?i)((every)?(\\s)*(month))|(monthly)";

    protected RecurringMode mode;

    /**
     * Every field must not be null.
     */
    public RecurringTask(Name name, TaskDate date, TaskTime time, Description description, Tag tag, Venue venue,
            Priority priority, boolean isFavorite, RecurringMode mode) {
        super(name, date, time, description, tag, venue, priority, isFavorite);
        this.isRecurring = RecurringProperty.RECURRING;
        this.mode = mode;
        checkDateForRecurring();
    }

    /**
     * Constructor with flag isFinished
     */
    public RecurringTask(Name name, TaskDate date, TaskTime time, Description description, Tag tag, Venue venue,
            Priority priority, boolean isFavorite, FinishProperty isFinished, RecurringMode mode) {
        this(name, date, time, description, tag, venue, priority, isFavorite, mode);
        this.isFinished = isFinished;
    }

    /**
     * Creates a copy of the given ReadOnlyTask.
     * @throws IllegalValueException
     */
    public RecurringTask(ReadOnlyTask source) {
        super(source.getName(), source.getDate(), source.getTime(), source.getDescription(),
                source.getTag(), source.getVenue(), source.getPriority(),
                source.isFavorite(), source.getFinished(),
                source.getEventProperty(), source.getRecurringProperty());
        assert this.isRecurring == RecurringProperty.RECURRING;
        this.mode = ((ReadOnlyRecurringTask) source).getMode();
        checkDateForRecurring();
    }

    @Override
    /**
     * Updates this task with the details of {@code replacement}.
     */
    public void resetData(ReadOnlyTask replacement) {
        assert replacement != null;

        super.resetData(replacement);
        assert this.isRecurring == RecurringProperty.RECURRING;
        this.mode = ((ReadOnlyRecurringTask) replacement).getMode();
        checkDateForRecurring();
    }

    /**
     * Set date to be day if date is not specified
     */
    private void checkDateForRecurring() {
        if (this.date.getValue().isEmpty()) {
            try {
                this.date = new TaskDate("today");
            } catch (IllegalValueException e) {
                assert false;
            }
        }
    }

    @Override
    public void finishOnce() {
        this.date.addPeriod(mode);
    }

    @Override
    public String getRecurringPeriod() {
        if (mode.equals(RecurringMode.DAY)) {
            return PERIOD_DAILY;
        } else if (mode.equals(RecurringMode.WEEK)) {
            return PERIOD_WEEKLY;
        } else if (mode.equals(RecurringMode.MONTH)) {
            return PERIOD_MONTHLY;
        } else {
            assert false;
            return null;
        }
    }

    public void setRecurringMode(RecurringMode mode) {
        this.mode = mode;
    }

    @Override
    public RecurringMode getMode() {
        return this.mode;
    }
}
```
###### /java/seedu/address/model/task/Task.java
``` java
package seedu.address.model.task;

import java.util.Objects;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.commons.util.CollectionUtil;
import seedu.address.model.tag.Tag;

/**
 * Represents a Task in the address book.
 * Guarantees: details are present and not null, field values are validated.
 */
public class Task implements ReadOnlyTask {

    protected Name name;
    protected TaskDate date;
    protected TaskTime time;
    protected Description description;
    protected Venue venue;
    protected Priority priority;
    protected boolean isFavorite;
    protected FinishProperty isFinished;
    protected Tag tag;
    protected EventProperty isEvent;
    protected RecurringProperty isRecurring;

    /**
     * Every field must not be null.
     */
    public Task(Name name, TaskDate date, TaskTime time, Description description, Tag tag,
            Venue venue, Priority priority, boolean isFavorite) {
        //assert !CollectionUtil.isAnyNull(name, date, time, description, tag, venue, priority, isFavorite);
        assert !CollectionUtil.isAnyNull(name, date, time, description, tag,
                venue, priority, isFavorite);
        this.name = name;
        this.date = date;
        this.time = time;
        this.description = description;
        this.tag = tag;
        this.venue = venue;
        this.priority = priority;
        this.isFavorite = isFavorite;
        this.isFinished = FinishProperty.UNFINISHED;
        this.isEvent = EventProperty.NON_EVENT;
        this.isRecurring = RecurringProperty.NON_RECURRING;
    }

    /**
     * Constructor with flag on isFavorite
     */
    public Task(Name name, TaskDate date, TaskTime time, Description description, Tag tag,
            Venue venue, Priority priority, boolean isFavorite, FinishProperty isFinished) {
        assert !CollectionUtil.isAnyNull(name);
        this.name = name;
        this.date = date;
        this.time = time;
        this.description = description;
        this.tag =  tag;
        this.venue = venue;
        this.priority = priority;
        this.isFavorite = isFavorite;
        this.isFinished = isFinished;
        this.isEvent = EventProperty.NON_EVENT;
        this.isRecurring = RecurringProperty.NON_RECURRING;
    }

    /**
     *  Constructor of task with flag on isFinshed, flag on isEvent, flag on isRecurring
     */
    public Task(Name name, TaskDate date, TaskTime time, Description description, Tag tag,
            Venue venue, Priority priority, boolean isFavorite, FinishProperty isFinished,
            EventProperty isEvent, RecurringProperty isRecurring) {
        assert !CollectionUtil.isAnyNull(name);
        this.name = name;
        this.date = date;
        this.time = time;
        this.description = description;
        this.tag =  tag;
        this.venue = venue;
        this.priority = priority;
        this.isFavorite = isFavorite;
        this.isFinished = isFinished;
        this.isEvent = isEvent;
        this.isRecurring = isRecurring;
    }

    /**
     * Creates a copy of the given ReadOnlyTask.
     * @throws IllegalValueException
     */
    public Task(ReadOnlyTask source) throws IllegalValueException {
        this(new Name(source.getName().getValue()), new TaskDate(source.getDate().getValue()),
                new TaskTime(source.getTime().getValue()), new Description(source.getDescription().getValue()),
                new Tag(source.getTag().getValue()), new Venue(source.getVenue().getValue()),
                new Priority(source.getPriority().getValue()), source.isFavorite(), source.getFinished(),
                source.getEventProperty(), source.getRecurringProperty());
    }

    public void setName(Name name) {
        assert name != null;
        this.name = name;
    }

    @Override
    public Name getName() {
        return name;
    }

    public void setDate(TaskDate date) {
        this.date = date;
    }

    @Override
    public TaskDate getDate() {
        return date;
    }

    public void setTime(TaskTime time) {
        this.time = time;
    }

    @Override
    public TaskTime getTime() {
        return time;
    }

    public void setDescription(Description description) {
        this.description = description;
    }

    @Override
    public Description getDescription() {
        return description;
    }

    @Override
    public Tag getTag() {
        return tag;
    }

    public void setTag(Tag tag) {
        assert tag != null;
        this.tag = tag;
    }

    @Override
    public Venue getVenue() {
        return venue;
    }

    public void setVenue(Venue venue) {
        this.venue = venue;
    }

    @Override
    public Priority getPriority() {
        return priority;
    }

    public void setPriority(Priority priority) {
        this.priority = priority;
    }

    @Override
    public boolean isFavorite() {
        return isFavorite;
    }

    @Override
    public String getFavoriteText() {
        if (isFavorite) {
            return "Favorite \u2764";
        } else {
            return "";
        }
    }

    public void setFavorite(boolean isFavorite) {
        this.isFavorite = isFavorite;
    }

    @Override
    public boolean isFinished() {
        return isFinished == FinishProperty.FINISHED;
    }

    @Override
    public String getFinishedText() {
        if (isFinished()) {
            return "Finished";
        } else {
            return "Unfinished";
        }
    }

    public void setFinish(Boolean isFinished) {
        if (isFinished) {
            this.isFinished = FinishProperty.FINISHED;
        } else {
            this.isFinished = FinishProperty.UNFINISHED;
        }
    }


    /**
     * Updates this task with the details of {@code replacement}.
     */
    public void resetData(ReadOnlyTask replacement) {
        assert replacement != null;

        try {
            this.setName(new Name(replacement.getName().getValue()));
            this.setDate(new TaskDate(replacement.getDate().getValue()));
            this.setTime(new TaskTime(replacement.getTime().getValue()));
            this.setDescription(new Description(replacement.getDescription().getValue()));
            this.setTag(new Tag(replacement.getTag().getValue()));
            this.setVenue(new Venue(replacement.getVenue().getValue()));
            this.setPriority(new Priority(replacement.getPriority().getValue()));
            this.setFavorite(replacement.isFavorite());
            this.setFinish(replacement.isFinished());
            this.setIsEvent(replacement.getEventProperty());
            this.setIsRecurring(replacement.getRecurringProperty());
        } catch (IllegalValueException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    private void setIsEvent(EventProperty isEvent) {
        this.isEvent = isEvent;
    }

    private void setIsRecurring(RecurringProperty isRecurring) {
        this.isRecurring = isRecurring;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                        && this.isSameStateAs((ReadOnlyTask) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, date, time, description, tag, venue, priority, isFavorite, isFinished);
    }

    @Override
    public String toString() {
        return getAsText();
    }

    @Override
    public boolean isEvent() {
        return this.isEvent == EventProperty.EVENT;
    }

    @Override
    public boolean isRecurring() {
        return this.isRecurring == RecurringProperty.RECURRING;
    }

    @Override
    public FinishProperty getFinished() {
        return this.isFinished;
    }

    @Override
    public EventProperty getEventProperty() {
        return this.isEvent;
    }

    public void setRecurringProperty(RecurringProperty isRecurring) {
        this.isRecurring = isRecurring;
    }

    @Override
    public RecurringProperty getRecurringProperty() {
        return this.isRecurring;
    }
}
```
###### /java/seedu/address/model/task/TaskDate.java
``` java
package seedu.address.model.task;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.TimeZone;
import java.util.concurrent.TimeUnit;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.task.ReadOnlyRecurringTask.RecurringMode;

/**
 * Represents a Task's due date in task manager.
 * Guarantees: immutable; is valid as declared in {@link #isValidDate(String)}
 */
public class TaskDate implements TaskField, Comparable<TaskDate> {

    public static final String MESSAGE_DATE_CONSTRAINTS_1 =
            "task due date should be the form dd/mm, dd/mm/yyyy or Monday, tomorrow, etc.";

    public static final String DATE_VALIDATION_REGEX = ".+/.+";
    public static final String DAY_MONTH_SEPARATOR = "/";
    public static final String MONTH_VALIDATION_REGEX_1 = "([13578])|(0[13578])|(1[02])";
    public static final String MONTH_VALIDATION_REGEX_2 = "([469])|(0[469])|(11)";
    public static final String MONTH_VALIDATION_REGEX_3 = "(2)|(02)";
    public static final String MONTH_VALIDATION_REGEX = MONTH_VALIDATION_REGEX_1 + "|"
            + MONTH_VALIDATION_REGEX_2 + "|" + MONTH_VALIDATION_REGEX_3;
    public static final String DAY_VALIDATION_REGEX_1 = "([1-9])|(0[1-9])|(1\\d)|(2\\d)|(3[0-1])";
    public static final String DAY_VALIDATION_REGEX_2 = "([1-9])|(0[1-9])|(1\\d)|(2\\d)|(30)";
    public static final String DAY_VALIDATION_REGEX_3 = "([1-9])|(0[1-9])|(1\\d)|(2[0-8])";
    public static final String DAY_VALIDATION_REGEX_4 = "([1-9])|(0[1-9])|(1\\d)|(2[0-9])";
    public static final String YEAR_VALIDATION_REGEX = "(201[789])|(20[2-9]\\d)";

    public static final String DAY_VALIDATION_MONDAY = "(?i)(monday)|(mon)";
    public static final String DAY_VALIDATION_TUESDAY = "(?i)(tuesday)|(tue)";
    public static final String DAY_VALIDATION_WEDNESDAY = "(?i)(wednesday)|(wed)";
    public static final String DAY_VALIDATION_THURSDAY = "(?i)(thursday)|(thu)|(thur)|(thurs)";
    public static final String DAY_VALIDATION_FRIDAY = "(?i)(friday)|(fri)";
    public static final String DAY_VALIDATION_SATURDAY = "(?i)(saturday)|(sat)";
    public static final String DAY_VALIDATION_SUNDAY = "(?i)(sunday)|(sun)";

    public static final String DAY_VALIDATION_TODAY = "(?i)(today)";
    public static final String DAY_VALIDATION_TOMORROW = "(?i)(tomorrow)|(tmr)";

    public static final SimpleDateFormat FORMATTER = new SimpleDateFormat("dd/MM/yyyy");


    public static final int INF = 1000000000;
    public static final String INF_DATE = "1/1/2100";

    public Calendar today;

    private String value;
    public Date date;
    public boolean isPastDue;

    /**
     * Validates given date.
     *
     * @throws IllegalValueException if given date string is invalid.
     */
    public TaskDate(String date) throws IllegalValueException {
        assert date != null;
        initializeToday();
        String trimmedDate = date.trim();
        if (!isValidDate(trimmedDate)) {
            throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS_1);
        }
        if (isDayInWeek(trimmedDate)) {
            initializeGivenDayInWeek(trimmedDate);
        } else if (isTodayOrTomorrow(trimmedDate)) {
            initializeGivenTodayOrTomorrow(trimmedDate);
        } else {
            initializeGivenDate(trimmedDate);
        }
    }

    private void initializeToday() {
        today = Calendar.getInstance(TimeZone.getTimeZone("Asia/Singapore"));
        today.set(Calendar.HOUR_OF_DAY, 0);
        today.set(Calendar.MINUTE, 0);
        today.set(Calendar.SECOND, 0);
        today.set(Calendar.MILLISECOND, 0);
    }

    /**
     * Returns if a given string is a valid date.
     */
    public static boolean isValidDate(String test) {
        if (test.isEmpty()) {
            return true;
        }
        if (isDayInWeek(test)) {
            return true;
        }
        if (isTodayOrTomorrow(test)) {
            return true;
        }
        if (!test.matches(DATE_VALIDATION_REGEX)) {
            return false;
        }
        String[] dayMonthYear = test.split(DAY_MONTH_SEPARATOR);
        if (dayMonthYear.length > 3) {
            return false;
        }
        String day = dayMonthYear[0];
        String month = dayMonthYear[1];
        String year = dayMonthYear.length == 3 ? dayMonthYear[2] : null;
        return isValidMonth(month) && isValidDay(day, month, year) && isValidYear(year);
    }

    // methods used when given string is a date

    private void initializeGivenDate(String trimmedDate) throws IllegalValueException {
        trimmedDate = addYearField(trimmedDate);
        try {
            this.date = trimmedDate.isEmpty() ?
                    FORMATTER.parse(INF_DATE) :
                    FORMATTER.parse(trimmedDate);
        } catch (ParseException e) {
            throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS_1);
        }
        this.isPastDue = this.date.before(today.getTime());
        this.value = trimmedDate.isEmpty() ? trimmedDate : getDateString(date);
    }

    private String addYearField(String validDate) throws IllegalValueException {
        if (validDate.isEmpty()) {
            return validDate;
        }
        String[] dayMonthYear = validDate.split(DAY_MONTH_SEPARATOR);
        if (dayMonthYear.length == 3) {
            return validDate;
        }
        String day = dayMonthYear[0];
        String month = dayMonthYear[1];
        String year = Integer.toString(today.get(Calendar.YEAR));
        try {
            return parseDate(day, month, year);
        } catch (ParseException e) {
            throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS_1);
        }
    }

    private String parseDate(String day, String month, String year) throws IllegalValueException, ParseException {
        if (!isValidDay(day, month, year)) {
            throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS_1);
        } // need to check because of February 29
        String returnDate = getDateString(year, month, day);
        Date date = FORMATTER.parse(getDateString(year, month, day));
        if (date.before(today.getTime())) {
            year = Integer.toString(today.get(Calendar.YEAR) + 1);
            returnDate = getDateString(year, month, day);
            if (!isValidDay(day, month, year)) {
                throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS_1);
            }
        }
        return returnDate;
    }

    /**
     * Test the combination of given day, month, year is valid
     */
    private static boolean isValidDay(String day, String month, String year) {
        if (month.matches(MONTH_VALIDATION_REGEX_1)) {
            return day.matches(DAY_VALIDATION_REGEX_1);
        } else if (month.matches(MONTH_VALIDATION_REGEX_2)) {
            return day.matches(DAY_VALIDATION_REGEX_2);
        } else if (month.matches(MONTH_VALIDATION_REGEX_3) && !isLeapYear(year)) {
            return day.matches(DAY_VALIDATION_REGEX_3);
        } else if (month.matches(MONTH_VALIDATION_REGEX_3) && isLeapYear(year)) {
            return day.matches(DAY_VALIDATION_REGEX_4);
        }
        return false;
    }

    private static boolean isValidMonth(String test) {
        return test.matches(MONTH_VALIDATION_REGEX);
    }

    private static boolean isValidYear(String test) {
        return test == null || test.matches(YEAR_VALIDATION_REGEX);
    }

    private static boolean isLeapYear(String test) {
        if (test == null) {
            return true;
        }
        int year = Integer.parseInt(test);
        return (year % 400 == 0) || ((year % 100 != 0) && (year % 4 == 0));
    }

    // methods used when given string is today or tomorrow

    private void initializeGivenTodayOrTomorrow(String trimmedDate) {
        Calendar current = Calendar.getInstance();
        current.setTime(today.getTime());
        if (todayOrTomorrow(trimmedDate) == 1) {
            current.add(Calendar.DATE, 1);
        }
        this.isPastDue = false;
        this.date = current.getTime();
        this.value = getDateString(current);
    }

    private static boolean isTodayOrTomorrow(String test) {
        return todayOrTomorrow(test) != -1;
    }

    /**
     * Return the corresponding digit represented by the giving string
     * Return 0 for today, 1 for tomorrow, and -1 for invalid input
     */
    public static int todayOrTomorrow(String test) {
        assert test != null;
        if (test.matches(DAY_VALIDATION_TODAY)) {
            return 0;
        } else if (test.matches(DAY_VALIDATION_TOMORROW)) {
            return 1;
        } else {
            return -1;
        }
    }

    // methods used when given string is day in a week

    private void initializeGivenDayInWeek(String trimmedDate) {
        int day = dayInWeek(trimmedDate);
        int incre = 0;
        Calendar current = Calendar.getInstance();
        current.setTime(today.getTime());
        while ((current.get(Calendar.DAY_OF_WEEK) != day)) {
            current.add(Calendar.DATE, 1);
            incre += 1;
            if (incre >= 7) {
                assert false : "date should not increase more than 7 times";
            }
        }
        this.isPastDue = false;
        this.date = current.getTime();
        this.value = getDateString(current);
    }

    private static boolean isDayInWeek(String test) {
        return (dayInWeek(test) <= 7) && (dayInWeek(test) >= 1);
    }

    /**
     * Return the corresponding digit represented by the order of day in a week of the giving string
     * The first day in a week is Sunday
     * Return -1 for invalid input
     */
    public static int dayInWeek(String test) {
        assert test != null;
        if (test.matches(DAY_VALIDATION_SUNDAY)) {
            return 1;
        } else if (test.matches(DAY_VALIDATION_MONDAY)) {
            return 2;
        } else if (test.matches(DAY_VALIDATION_TUESDAY)) {
            return 3;
        } else if (test.matches(DAY_VALIDATION_WEDNESDAY)) {
            return 4;
        } else if (test.matches(DAY_VALIDATION_THURSDAY)) {
            return 5;
        } else if (test.matches(DAY_VALIDATION_FRIDAY)) {
            return 6;
        } else if (test.matches(DAY_VALIDATION_SATURDAY)) {
            return 7;
        } else {
            return -1;
        }
    }

    // Methods to format date string

    /**
     * Format the date by given calendar instance
     */
    public static String getDateString(Calendar current) {
        return current.get(Calendar.DAY_OF_MONTH) + DAY_MONTH_SEPARATOR
                + (current.get(Calendar.MONTH) + 1) + DAY_MONTH_SEPARATOR
                + current.get(Calendar.YEAR);
    }

    /**
     * Format the date by given date
     */
    public static String getDateString(Date date) {
        Calendar current = Calendar.getInstance();
        current.setTime(date);
        return getDateString(current);
    }

    /**
     * Format the date by given year, month, and day
     */
    public static String getDateString(String year, String month, String day) {
        return day + DAY_MONTH_SEPARATOR
                + month + DAY_MONTH_SEPARATOR
                + year;
    }

// Methods with recurring task

    /**
     * Add a recurring period for date
     */
    public void addPeriod(RecurringMode mode, int times) {
        assert mode != null;
        Calendar todayCalendar = Calendar.getInstance();
        todayCalendar.setTime(this.date);
        if (mode.equals(RecurringMode.DAY)) {
            todayCalendar.add(Calendar.DATE, 1 * times);
        } else if (mode.equals(RecurringMode.WEEK)) {
            todayCalendar.add(Calendar.DATE, 7 * times);
        } else if (mode.equals(RecurringMode.MONTH)) {
            todayCalendar.add(Calendar.MONTH, 1 * times);
        } else {
            assert false;
        }
        this.date = todayCalendar.getTime();
        this.value = getDateString(todayCalendar);
    }

    public void addPeriod(RecurringMode mode) {
        addPeriod(mode, 1);
    }

    public String getValue() {
        return value;
    }

    /** return if the task has past due*/
    public boolean isPastDue() {
        return isPastDue;
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskDate // instanceof handles nulls
                && this.value.equals(((TaskDate) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

    /**
     * Returns the time difference in hours
     * Empty date is always greater compare to non-empty date
     */
    @Override
    public int compareTo(TaskDate other) {
        if (this.value.isEmpty()) {
            if (other.value.isEmpty()) {
                return 0;
            } else {
                return INF;
            }
        } else {
            if (other.value.isEmpty()) {
                return -INF;
            } else {
                long diff = this.date.getTime() - other.date.getTime();
                return (int) TimeUnit.HOURS.convert(diff, TimeUnit.MILLISECONDS);
            }
        }
    }

```
###### /java/seedu/address/model/task/TaskTime.java
``` java
package seedu.address.model.task;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.TimeUnit;

import seedu.address.commons.exceptions.IllegalValueException;

/**
 * Represents a task's due time in the task manager.
 * Guarantees: immutable; is valid as declared in {@link #isValidTime(String)}
 */
public class TaskTime implements TaskField, Comparable<TaskTime> {

    public static final String MESSAGE_TIME_CONSTRAINTS =
            "Task time should be the form hh:mm";

    /*
     * The first character of the time must not be a whitespace,
     * otherwise " " (a blank string) becomes a valid input.
     */
    public static final String HOUR_VALIDATION_REGEX = "(\\d)|(0\\d)|(1\\d)|(2[0-3])";
    public static final String MINUTE_VALIDATION_REGEX = "[0-5][0-9]";
    public static final String TIME_VALIDATION_REGEX = ".*:.*";
    public static final String HOUR_MINUTE_SEPARATOR = ":";

    public static final SimpleDateFormat FORMATTER = new SimpleDateFormat("hh:mm");

    public static final int INF = 1000000000;

    private final String value;
    private final Date time;

    /**
     * Validates given time.
     *
     * @throws IllegalValueException if given time string is invalid.
     */
    public TaskTime(String time) throws IllegalValueException {
        assert time != null;
        if (!isValidTime(time)) {
            throw new IllegalValueException(MESSAGE_TIME_CONSTRAINTS);
        }
        try {
            this.time = time.isEmpty() ? null : FORMATTER.parse(time);
        } catch (ParseException e) {
            throw new IllegalValueException(MESSAGE_TIME_CONSTRAINTS);
        }
        this.value = time;
    }

    /**
     * Returns true if a given string is a valid time.
     */
    public static boolean isValidTime(String test) {
        if (test.isEmpty()) {
            return true;
        }
        if (!test.matches(TIME_VALIDATION_REGEX)) {
            return false;
        }
        String[] hourAndMinute = test.split(HOUR_MINUTE_SEPARATOR);
        String hour = hourAndMinute[0];
        String minute = hourAndMinute[1];
        return isValidHour(hour) && isValidMinute(minute);
    }

    private static boolean isValidHour(String test) {
        return test.matches(HOUR_VALIDATION_REGEX);
    }

    private static boolean isValidMinute(String test) {
        return test.matches(MINUTE_VALIDATION_REGEX);
    }

    public String getValue() {
        return this.value;
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskTime // instanceof handles nulls
                && this.value.equals(((TaskTime) other).value)); // state check
    }

    /**
     * Empty TaskTime is always greater compare to non-empty one
     */
    @Override
    public int compareTo(TaskTime other) {
        if (this.time == null) {
            if (other.time == null) {
                return 0;
            } else {
                return INF;
            }
        } else {
            if (other.time == null) {
                return -INF;
            } else {
                long diff = this.time.getTime() - other.time.getTime();
                return (int) TimeUnit.HOURS.convert(diff, TimeUnit.MILLISECONDS);
            }
        }
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

```
###### /java/seedu/address/model/task/UniqueTaskList.java
``` java
    /**
     * Sort the UniqueTaskList. In the priority of
     * due date > priority > due time > name > tag
     */
    public void sort() {
        Collections.sort(internalList, (Task t1, Task t2) -> t1.getTag().compareTo(t2.getTag()));
        Collections.sort(internalList, (Task t1, Task t2) -> t1.getName().compareTo(t2.getName()));
        Collections.sort(internalList, (Task t1, Task t2) -> t1.getTime().compareTo(t2.getTime()));
        Collections.sort(internalList, (Task t1, Task t2) -> -t1.getPriority().compareTo(t2.getPriority()));
        Collections.sort(internalList, (Task t1, Task t2) -> t1.getDate().compareTo(t2.getDate()));
    }
```
###### /java/seedu/address/model/task/Venue.java
``` java
package seedu.address.model.task;

import seedu.address.commons.exceptions.IllegalValueException;

/**
 * Represents a Task's venue in task manager.
 * Guarantees: immutable; is valid as declared in {@link #isValidVenue(String)}
 */
public class Venue implements TaskField, Comparable<Venue> {

    public static final String MESSAGE_VENUE_CONSTRAINTS =
            "task venue can only contains alphanumerics and #, -, '.";

    // cannot begin with space; can only contains
    public static final String VENUE_VALIDATION_REGEX = "^((\\w)|([-#]))((\\w)|([-#'])|(\\s))*";

    private final String value;

    /**
     * Validity given venue.
     *
     * @throws IllegalValueException if given venue string is invalid.
     */
    public Venue(String venue) throws IllegalValueException {
        assert venue != null;
        String trimmedVenue = venue.trim();
        if (!isValidVenue(trimmedVenue)) {
            throw new IllegalValueException(MESSAGE_VENUE_CONSTRAINTS);
        }
        this.value = trimmedVenue;
    }

    /**
     * Returns if a given string is a valid venue.
     */
    public static boolean isValidVenue(String test) {
        if (test.isEmpty()) {
            return true;
        }
        return test.matches(VENUE_VALIDATION_REGEX);
    }

    public String getValue() {
        return this.value;
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Venue // instanceof handles nulls
                && this.value.equals(((Venue) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

    @Override
    public int compareTo(Venue other) {
        return this.value.compareTo(other.value);
    }

```
###### /java/seedu/address/model/TaskManager.java
``` java
    /**
     * Reset the task manager
     */
    public void clear() {
        this.tasks.clear();
        this.tags.clear();
    }
```
###### /java/seedu/address/model/TaskManager.java
``` java
    /**
     * Updates the task in the list at position {@code index} with {@code editedReadOnlyTask}.
     * {@code TaskManager}'s tag list will be updated with the tags of {@code editedReadOnlyTask}.
     * @throws DuplicateTaskException
     * @see #syncMasterTagListWith(Task)
     *
     * @throws IndexOutOfBoundsException if {@code index} < 0 or >= the size of the list.
     */
    public void updateTask(int index, ReadOnlyTask editedReadOnlyTask)
            throws DuplicateTaskException {
        assert editedReadOnlyTask != null;
        Task editedTask = buildEditedTask(editedReadOnlyTask);

        syncMasterTagListWith(editedTask);
        updateTasksAndTagsWhenUpdating(index, editedTask);
    }

    private void updateTasksAndTagsWhenUpdating(int index, Task editedTask) throws DuplicateTaskException {
        Tag oldTaskTag = tasks.get(index).getTag();
        tasks.updateTask(index, editedTask);
        tasks.sort();
        if (isEmptyTag(oldTaskTag)) {
            tags.remove(oldTaskTag);
        }
        if (isEmptyTag(editedTask.getTag())) {
            tags.remove(editedTask.getTag());
        }
        tags.sort();
    }

    private Task buildEditedTask(ReadOnlyTask editedReadOnlyTask) {
        if (editedReadOnlyTask.isEvent()) {
            try {
                if (editedReadOnlyTask.isRecurring()) {
                    return new RecurringEvent(editedReadOnlyTask);
                } else {
                    return new Event(editedReadOnlyTask);
                }
            } catch (IllegalValueException e) {
                logger.info("IllegalValueException thrown when building"
                        + " event in updating task manager");
            }
        } else {
            if (editedReadOnlyTask.isRecurring()) {
                return new RecurringTask(editedReadOnlyTask);
            } else {
                try {
                    return new Task(editedReadOnlyTask);
                } catch (IllegalValueException e) {
                    logger.info("IllegalValueException thrown when building"
                            + " event in updating task manager");
                }
            }
        }
        return null;
    }

    /**
     * Updates the recurring task in the list at position {@code index} with {@code editedReadOnlyTask}.
     * The recurring task will be postpone for one period,
     * add a new Task will be created
     * @throws DuplicateTaskException
     * @throws IndexOutOfBoundsException if {@code index} < 0 or >= the size of the list.
     */
    public void updateTaskOnce(int index, ReadOnlyTask editedReadOnlyTask)
            throws UniqueTaskList.DuplicateTaskException {
        assert editedReadOnlyTask != null;

        ReadOnlyTask recurringTask = tasks.get(index);
        finishTaskOnce(recurringTask);

        Task editedTask = buildEditedTaskOneTime(editedReadOnlyTask);
        addTask(editedTask);
    }

    private Task buildEditedTaskOneTime(ReadOnlyTask editedReadOnlyTask) {
        Task editedTask = null;
        if (editedReadOnlyTask.isEvent()) {
            try {
                editedTask = new Event(editedReadOnlyTask);
                editedTask.setRecurringProperty(RecurringProperty.NON_RECURRING);
            } catch (IllegalValueException e) {
                logger.info("IllegalValueException thrown when building"
                        + " event in updating task manager");
            }
        } else {
            try {
                editedTask = new Task(editedReadOnlyTask);
            } catch (IllegalValueException e) {
                logger.info("IllegalValueException thrown when building"
                        + " event in updating task manager");
            }
            editedTask.setRecurringProperty(RecurringProperty.NON_RECURRING);
        }
        return editedTask;
    }

    /**
     * Finish the recurring task once
     * @param recurringTask
     * @throws DuplicateTaskException
     */
    public void finishTaskOnce(ReadOnlyTask recurringTask) throws DuplicateTaskException {
        Task current = buildFinishedRecurringTask(recurringTask);
        if (current.isEvent()) {
            ((RecurringEvent) current).finishOnce();
        } else {
            ((RecurringTask) current).finishOnce();
        }
        replaceTask(recurringTask, current);
    }

    private void replaceTask(ReadOnlyTask recurringTask, Task current) throws DuplicateTaskException {
        try {
            removeTask(recurringTask);
            addTask(current);
        } catch (TaskNotFoundException e) {
            logger.info("task is not found");
        }
    }

    private Task buildFinishedRecurringTask(ReadOnlyTask recurringTask) {
        Task current = null;
        try {
            if (recurringTask.isEvent()) {
                current = new RecurringEvent(recurringTask);
            } else {
                current = new RecurringTask(recurringTask);
            }
        } catch (IllegalValueException e1) {
            logger.info("IllegalValueException thrown when building"
                    + " recurring task in updating task manager");
        }
        return current;
    }
```
###### /java/seedu/address/model/TaskManager.java
``` java
    public void addTag(Tag t) throws UniqueTagList.DuplicateTagException {
        tags.add(t);
        logger.info(t + " is addded in task manager");
    }

    public void removeTag(Tag t) {
        tags.remove(t);
        logger.info(t + " is deleted in task manager");
    }


    private boolean isEmptyTag(Tag keyTag) {
        for (Task t : tasks) {
            if (t.getTag().equals(keyTag)) {
                return false;
            }
        }
        return true;
    }
```
###### /java/seedu/address/model/util/SampleDataUtil.java
``` java
    public static Task[] getSampleTasks() {
        try {
            return new Task[] {
                new Task(new Name("pay tuition fee"), new TaskDate("25/3/2017"), new TaskTime(""),
                        new Description("don't forget!!!!"), new Tag(""),
                        new Venue(""), new Priority("3"), false),
                new Task(new Name("cs 2103"), new TaskDate("today"), new TaskTime("9:00"),
                        new Description("demo"), new Tag("study"),
                        new Venue("COM1"), new Priority("3"), true),
                new Event(new Name("cs final"), new TaskDate("4/5"), new TaskTime("15:00"),
                        new TaskTime("17:00"), new Description("cannot bring helpsheet"), new Tag("study"),
                        new Venue("MPSH"), new Priority("3"), true),
                new Task(new Name("clean up room"), new TaskDate("4/5"), new TaskTime("9:00"),
                        new Description("get ready to go home"), new Tag("personal"),
                        new Venue(""), new Priority("1"), false),
                new Task(new Name("Gym"), new TaskDate("12/3"), new TaskTime("11:00"),
                        new Description("50 mins workout"), new Tag("personal"),
                        new Venue("MPSH"), new Priority("2"), true),
                new Task(new Name("study hard"), new TaskDate(""), new TaskTime(""),
                        new Description("goal in my life"), new Tag("study"),
                        new Venue(""), new Priority("3"), true)
            };
        } catch (IllegalValueException e) {
            throw new AssertionError("sample data cannot be invalid", e);
        }
    }

```
