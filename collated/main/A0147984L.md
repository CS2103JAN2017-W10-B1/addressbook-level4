# A0147984L
###### /java/seedu/address/model/Model.java
``` java
    // Task-level filter
    /**
     * Update the filter of the filter task given specific fields
     *
     * @param nameKeywords indicates the name field
     * @param tagKeywords indicates the tag search field
     * @param finishedState indicates the finished search field (ALL/UNFINISHED/FINISHED)
     * @param isFavorite indicates the favorite search field
     * @param dueMode indicates the view mode on due (ON/BY)
     * @param days indicates the days until due
     */
    void updateFilteredTaskList(Set<String> nameKeywords, Set<String> tagKeywords,
            FinishedState finishedState, boolean isFavorite,
            DueMode dueMode, String days);

    /** Updates the filter of the unfinished filtered task list to filter by the given keywords*/
    void updateFilteredTaskList(Set<String> keywords);

    /** Updates the filter of the filtered task list to show all favorite tasks */
    void updateFilteredListToShowAllFavoriteTasks();

    /** Updates the filter of the filtered task list to show all unfinished tasks */
    void updateFilteredListToShowAllUnfinishedTasks();

    /** Updates the filter of the filtered task list to show all tasks */
    void updateFilteredListToShowAllTasks();

    /** Updates the filter of the filtered task list to show all finished tasks */
    void updateFilteredListToShowAllFinishedTasks();

    /** Updates the filter of the filtered task list to filter by the given keywords*/
    void updateFilteredTaskListFinished(Set<String> keywords);

    /** Updates the filter of the filtered task list to filter by the given keywords*/
    void updateFilteredTaskListAll(Set<String> keywords);

    /** Updates the filter of the filtered task list to filter by the given keywords*/
    void updateFilteredTaskListFavorite(Set<String> keywords);

    /** Updates the filter of the unfinished filtered task list to filter by the given list name*/
    void updateFilteredTaskListGivenListName(Set<String> keywords);

    /** Updates the filter of the filtered task list to filter by the given list name*/
    void updateFilteredTaskListGivenListNameAll(Set<String> keywords);

    /** Updates the filter of the finished filtered task list to filter by the given list name*/
    void updateFilteredTaskListGivenListNameFinished(Set<String> keywords);

    /** Updates the filter of the favorite filtered task list to filter by the given list name*/
    void updateFilteredTaskListGivenListNameAllFavorite(Set<String> keywords);

    /** Updates the filter of the filtered task list to filter by the days to due*/
    void updateFilteredTaskListGivenDaysToDueBy(String days);

    /** Updates the filter of the filtered task list to filter on the days to due*/
    void updateFilteredTaskListGivenDaysToDueOn(String days);

    // Tag-level filter

    /** Updates the filter of the filtered tag list to show all tasks */
    void updateFilteredTagListToShowAllTags();

    /** Check whether the list name exist*/
    boolean isListExist(Set<String> listNames);

}
```
###### /java/seedu/address/model/ModelManager.java
``` java
    @Override
    public void updateFilteredTaskList(Set<String> nameKeywords, Set<String> tagKeywords,
            FinishedState finishedState, boolean isFavorite,
            DueMode dueMode, String days) {
        NameQualifier nameQualifier = nameKeywords == null ? null : new NameQualifier(nameKeywords);
        TagQualifier tagQualifier = tagKeywords == null ? null : new TagQualifier(tagKeywords);
        FinishedQualifier finishedQualifier = new FinishedQualifier(finishedState);
        FavoriteQualifier favoriteQualifier = isFavorite ? new FavoriteQualifier() : null;
        DateQualifier dateQualifier;
        if (dueMode == null) {
            dateQualifier = null;
        } else if (dueMode.equals(DueMode.BY)) {
            dateQualifier = new DateQualifierBy(days);
        } else if (dueMode.equals(DueMode.ON)) {
            dateQualifier = new DateQualifierOn(days);
        } else {
            dateQualifier = null;
        }
        updateFilteredTaskList(new PredicateExpression(
                nameQualifier, tagQualifier, finishedQualifier, favoriteQualifier, dateQualifier));
    }

    @Override
    public void updateFilteredTaskList(Set<String> keywords) {
        updateFilteredTaskList(keywords, null, FinishedState.UNFINISHED, false, null, null);
    }

    private void updateFilteredTaskList(Expression expression) {
        filteredTasks.setPredicate(expression::satisfies);
    }

    @Override
    public void updateFilteredListToShowAllUnfinishedTasks() {
        updateFilteredTaskList(null, null, FinishedState.UNFINISHED, false, null, null);
    }

    @Override
    public void updateFilteredListToShowAllTasks() {
        filteredTasks.setPredicate(null);
    }

    @Override
    public void updateFilteredListToShowAllFinishedTasks() {
        updateFilteredTaskList(null, null, FinishedState.FINISHED, false, null, null);
    }

    @Override
    public void updateFilteredListToShowAllFavoriteTasks() {
        updateFilteredTaskList(null, null, FinishedState.ALL, true, null, null);
    }

    @Override
    public void updateFilteredTaskListFinished(Set<String> keywords) {
        updateFilteredTaskList(keywords, null, FinishedState.FINISHED, false, null, null);
    }

    @Override
    public void updateFilteredTaskListAll(Set<String> keywords) {
        updateFilteredTaskList(keywords, null, FinishedState.ALL, false, null, null);
    }

    @Override
    public void updateFilteredTaskListFavorite(Set<String> keywords) {
        updateFilteredTaskList(keywords, null, FinishedState.UNFINISHED, true, null, null);
    }

    @Override
    public void updateFilteredTaskListGivenListName(Set<String> keywords) {
        updateFilteredTaskList(null, keywords, FinishedState.UNFINISHED, false, null, null);
    }

    @Override
    public void updateFilteredTaskListGivenListNameAll(Set<String> keywords) {
        updateFilteredTaskList(null, keywords, FinishedState.ALL, false, null, null);
    }

    @Override
    public void updateFilteredTaskListGivenListNameFinished(Set<String> keywords) {
        updateFilteredTaskList(null, keywords, FinishedState.FINISHED, false, null, null);
    }

    @Override
    public void updateFilteredTaskListGivenListNameAllFavorite(Set<String> keywords) {
        updateFilteredTaskList(null, keywords, FinishedState.ALL, true, null, null);
    }

    @Override
    public void updateFilteredTaskListGivenDaysToDueBy(String days) {
        updateFilteredTaskList(null, null, FinishedState.UNFINISHED, false, DueMode.BY, days);
    }

    @Override
    public void updateFilteredTaskListGivenDaysToDueOn(String days) {
        updateFilteredTaskList(null, null, FinishedState.UNFINISHED, false, DueMode.ON, days);
    }
```
###### /java/seedu/address/model/ModelManager.java
``` java
    public UnmodifiableObservableList<Tag> getFilteredTagList() {
        return new UnmodifiableObservableList<>(filteredTag);
    }

    public void updateFilteredTagListToShowAllTags() {
        filteredTag.setPredicate(null);
    }

    private void updateFilteredTagList(Expression expression) {
        filteredTag.setPredicate(expression::satisfies);
    }

```
###### /java/seedu/address/model/ModelManager.java
``` java
    private class PredicateExpression implements Expression {

        private final HashSet<Qualifier> qualifiers;

        PredicateExpression(Qualifier...qualifiers) {
            this.qualifiers = new HashSet<>();
            for (Qualifier qualifier : qualifiers) {
                if (qualifier != null) {
                    this.qualifiers.add(qualifier);
                }
            }
        }

        @Override
        public boolean satisfies(ReadOnlyTask task) {
            return qualifiers.stream().
                    filter(qualifier -> qualifier.run(task)).count()
                    == this.qualifiers.size();
        }

        @Override
        public boolean satisfies(Tag list) {
            return qualifiers.stream().
                    filter(qualifier -> qualifier.run(list)).count()
                    == this.qualifiers.size();
        }

        @Override
        public String toString() {
            String returnString = "";
            for (Qualifier qualifier : this.qualifiers) {
                returnString += qualifier.toString();
            }
            return returnString;
        }
    }
```
###### /java/seedu/address/model/ModelManager.java
``` java
    private class FinishedQualifier implements Qualifier {
        protected FinishedState state;

        FinishedQualifier(FinishedState state) {
            this.state = state;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            if (state.equals(FinishedState.FINISHED)) {
                return task.isFinished();
            } else if (state.equals(FinishedState.UNFINISHED)) {
                return !task.isFinished();
            } else {
                return true;
            }
        }

```
###### /java/seedu/address/model/ModelManager.java
``` java

    private class TagQualifier implements Qualifier {
        protected Set<String> tagKeyWords;

        TagQualifier(Set<String> tagKeyWords) {
            this.tagKeyWords = tagKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return tagKeyWords.stream()
                    .filter(keyword -> StringUtil.containsWordIgnoreCase(task.getTag().getName(), keyword))
                    .findAny()
                    .isPresent();
        }

        @Override
        public boolean run(Tag list) {
            return false;
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", tagKeyWords);
        }
    }

    private abstract class DateQualifier implements Qualifier {
        protected int daysToDue;
        protected Calendar today;

        DateQualifier(String days) {
            this.daysToDue = Integer.parseInt(days);
            today = Calendar.getInstance(TimeZone.getTimeZone("Asia/Singapore"));
            today.set(Calendar.HOUR_OF_DAY, 0);
            today.set(Calendar.MINUTE, 0);
            today.set(Calendar.SECOND, 0);
            today.set(Calendar.MILLISECOND, 0);
        }

        @Override
        public abstract boolean run(ReadOnlyTask task);

        @Override
        public boolean run(Tag list) {
            return false;
        }

        @Override
        public String toString() {
            return "daysToDue=" + daysToDue;
        }
    }

    private class DateQualifierOn extends DateQualifier {

        DateQualifierOn(String days) {
            super(days);
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            long diff = task.getDate().date.getTime() - today.getTime().getTime();
            return daysToDue == TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS);
        }
    }

    private class DateQualifierBy extends DateQualifier {

        DateQualifierBy(String days) {
            super(days);
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            long diff = task.getDate().date.getTime() - today.getTime().getTime();
            return (daysToDue >= TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS))
                    &&
                    (0 <= TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS));
        }
    }

}
```
###### /java/seedu/address/model/tag/Tag.java
``` java
package seedu.address.model.tag;

import seedu.address.commons.exceptions.IllegalValueException;

import seedu.address.model.task.TaskField;

/**
 * Represents a Tag in the address book.
 * Guarantees: immutable; name is valid as declared in {@link #isValidTagName(String)}
 */
public class Tag implements TaskField, Comparable<Tag> {

    public static final String MESSAGE_TAG_CONSTRAINTS_1 = "Tags names should be alphanumeric without space";
    public static final String MESSAGE_TAG_CONSTRAINTS_2 = " is reserved so cannot be used as a tag name";
    public static final String TAG_VALIDATION_REGEX = "\\p{Alnum}+";
    public static final String TAG_RESERVED_NAME =
            "(?i)"
            + "(list)|(tag)|(task)|(date)|(time)|(venue)|(description)|"
            + "(finished)|(unfinished)|(favorite)|(favourite)|"
            + "(today)|(tomorrow)|(all)|"
            + "(add)|(delete)|(edit)|(update)|(find)|(help)|(list)|(clear)|(finish)|(select)";
    public static final String DEFAULT_TAG_NAME = "Inbox";
    public String tagName;


    /**
     * Validates given tag name.
     *
     * @throws IllegalValueException if the given tag name string is invalid.
     */
    public Tag(String name) throws IllegalValueException {
        assert name != null;
        String trimmedName = name.trim();
        if (!isValidTagName(trimmedName)) {
            throw new IllegalValueException(MESSAGE_TAG_CONSTRAINTS_1);
        }
        if (isReservedName(trimmedName)) {
            throw new IllegalValueException(trimmedName + MESSAGE_TAG_CONSTRAINTS_2);
        }
        this.tagName = trimmedName.isEmpty() ? DEFAULT_TAG_NAME : trimmedName;
    }

    /**
     * Creates a copy of the given Tag.
     */

    public Tag(Tag source) throws IllegalValueException {
        this(source.getName());
    }

     /**
     * Returns true if a given string is a valid tag name.
     * @throws IllegalValueException
     */
    public static boolean isValidTagName(String test) throws IllegalValueException {
        if (test.isEmpty()) {
            return true;
        }
        return test.matches(TAG_VALIDATION_REGEX);
    }

    public static boolean isReservedName(String test) {
        return test.matches(TAG_RESERVED_NAME);
    }

    public String getName() {
        return this.tagName;
    }
```
###### /java/seedu/address/model/task/Description.java
``` java
package seedu.address.model.task;

import seedu.address.commons.exceptions.IllegalValueException;

/**
 * Represents a Task's description in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidDescription(String)}
 */
public class Description implements TaskField, Comparable<Description> {

    public static final String MESSAGE_DESCRIPTION_CONSTRAINTS = "Task description can be in any form.";
    public static final String DESCRIPTION_VALIDATION_REGEX = ".*";

    private final String value;

    /**
     * Validates given description number.
     *
     * @throws IllegalValueException if given description string is invalid.
     */
    public Description(String description) throws IllegalValueException {
        assert description != null;
        String trimmedDescription = description.trim();
        if (!isValidDescription(trimmedDescription)) {
            throw new IllegalValueException(MESSAGE_DESCRIPTION_CONSTRAINTS);
        }
        this.value = trimmedDescription;
    }

    /**
     * Returns true if a given string is a valid person description number.
     */
    public static boolean isValidDescription(String test) {
        return test.matches(DESCRIPTION_VALIDATION_REGEX);
    }

    public String getValue() {
        return value;
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Description // instanceof handles nulls
                && this.value.equals(((Description) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

    @Override
    public int compareTo(Description other) {
        return this.value.compareTo(other.value);
    }

```
###### /java/seedu/address/model/task/Event.java
``` java
package seedu.address.model.task;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.tag.Tag;

public class Event extends Task implements ReadOnlyEvent {

    public static final String MESSAGE_EVENT_CONSTRAINT = "End time should be latter than start time";
    private TaskDate startDate;
    private TaskTime startTime;

    /**
     * Every field must be present and not null.
     * @throws IllegalValueException
     */
    public Event(Name name, TaskDate startDate, TaskTime startTime, TaskDate endDate, TaskTime endTime,
            Description description, Tag tag, Venue venue, Priority priority, boolean isFavorite)
                    throws IllegalValueException {
        super(name, endDate, endTime, description, tag, venue, priority, isFavorite);
        this.isEvent = EventProperty.EVENT;

        if (startDate.compareTo(endDate) > 0) {
            throw new IllegalValueException(MESSAGE_EVENT_CONSTRAINT);
        } else {
            this.startDate = startDate;
            this.startTime = startTime;
        }

        if ((startDate.compareTo(endDate) == 0) && (startTime.compareTo(endTime) > 0)) {
            throw new IllegalValueException(MESSAGE_EVENT_CONSTRAINT);
        } else {
            this.startDate = startDate;
            this.startTime = startTime;
        }
    }

    /**
     *  Constructor of event with flag on isFinshed
     * @throws IllegalValueException
     */
    public Event(Name name, TaskDate startDate, TaskTime startTime, TaskDate endDate, TaskTime endTime,
            Description description, Tag tag, Venue venue,
            Priority priority, boolean isFavorite, FinishProperty isFinished)
                    throws IllegalValueException {
        this(name, startDate, startTime, endDate, endTime, description, tag, venue,  priority, isFavorite);
        this.isFinished = isFinished;
    }

    /**
     *  Constructor of event with only one date given
     * @throws IllegalValueException
     */
    public Event(Name name, TaskDate date, TaskTime startTime, TaskTime endTime,
            Description description, Tag tag, Venue venue, Priority priority, boolean isFavorite)
                    throws IllegalValueException {
        this(name, date, startTime, date, endTime, description, tag, venue,  priority, isFavorite);
    }

    /**
     *  Constructor of event with only one date given, with flag on isFinished
     * @throws IllegalValueException
     */
    public Event(Name name, TaskDate date, TaskTime startTime, TaskTime endTime,
            Description description, Tag tag, Venue venue, Priority priority,
            boolean isFavorite, FinishProperty isFinished)
                    throws IllegalValueException {
        this(name, date, startTime, date, endTime, description, tag, venue,  priority, isFavorite, isFinished);
    }

    /**
     * Creates a copy of the given ReadOnlyTask.
     * @throws IllegalValueException
     */
    public Event(ReadOnlyTask source) throws IllegalValueException {
        this(source.getName(), ((ReadOnlyEvent) source).getStartDate(), ((ReadOnlyEvent) source).getStartTime(),
                source.getDate(), source.getTime(), source.getDescription(), source.getTag(),
                source.getVenue(), source.getPriority(), source.isFavorite(), source.getFinished());
        assert this.isEvent == EventProperty.EVENT;
    }

    @Override
    /**
     * Updates this task with the details of {@code replacement}.
     */
    public void resetData(ReadOnlyTask replacement) {
        assert replacement != null;

        super.resetData(replacement);
        assert this.isEvent == EventProperty.EVENT;
        this.setStartTime(((ReadOnlyEvent) replacement).getStartTime());
        this.setStartDate(((ReadOnlyEvent) replacement).getStartDate());
    }

    @Override
    public TaskDate getStartDate() {
        return this.startDate;
    }

    public void setStartDate(TaskDate startDate) {
        this.startDate = startDate;
    }

    @Override
    public TaskTime getStartTime() {
        return this.startTime;
    }

    public void setStartTime(TaskTime startTime) {
        this.startTime = startTime;
    }
}

```
###### /java/seedu/address/model/task/Priority.java
``` java
package seedu.address.model.task;

import seedu.address.commons.exceptions.IllegalValueException;

/**
 * Represents a Task's priority in task manager.
 * Guarantees: immutable; is valid as declared in {@link #isValidPriority(String)}
 */
public class Priority implements TaskField, Comparable<Priority> {

    public static final String PRIORITY_1 = "1";
    public static final String PRIORITY_2 = "2";
    public static final String PRIORITY_3 = "3";
    public static final String PRIORITY_TRIVIAL = "trivial";
    public static final String PRIORITY_NORMAL = "normal";
    public static final String PRIORITY_IMPORTANT = "important";
    public static final String PRIORITY_EMPTY = "";

    public static final String DEFAULT_PRIORITY = PRIORITY_2;

    public static final String MESSAGE_PRIORITY_CONSTRAINTS = "task priority can only be 1, 2, 3,"
            + "trivial, normal, or important";

    public static final String PRIORITY_VALIDATION_REGEX = PRIORITY_1 + "|" + PRIORITY_2 + "|" + PRIORITY_3;

    private final String value;

    /**
     * Validity given priority.
     *
     * @throws IllegalValueException if given priority string is invalid.
     */
    public Priority(String priority) throws IllegalValueException {
        if (priority == null) {
            this.value = DEFAULT_PRIORITY;
        } else {
            String trimmedPriority = priority.trim();
            String convertedPriority = convert(trimmedPriority);
            if (!isValidPriority(convertedPriority)) {
                throw new IllegalValueException(MESSAGE_PRIORITY_CONSTRAINTS);
            }
            this.value = convertedPriority;
        }
    }

    /**
     * Returns if a given string is a valid priority.
     */
    public static boolean isValidPriority(String test) {
        return test.matches(PRIORITY_VALIDATION_REGEX);
    }

    /**
     * Convert English expressions into digits expressions
     */
    public static String convert(String value) {
        value = value.isEmpty() ? DEFAULT_PRIORITY : value;
        value = value.replaceFirst(PRIORITY_IMPORTANT, PRIORITY_3);
        value = value.replaceFirst("(?i)" + PRIORITY_NORMAL, PRIORITY_2);
        value = value.replaceFirst("(?i)" + PRIORITY_TRIVIAL, PRIORITY_1);
        return value;
    }

    public String getValue() {
        return this.value;
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Priority // instanceof handles nulls
                && this.value.equals(((Priority) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

    @Override
    public int compareTo(Priority other) {
        return Integer.parseInt(this.value)
                -
                Integer.parseInt(other.value);
    }

```
###### /java/seedu/address/model/task/ReadOnlyEvent.java
``` java
package seedu.address.model.task;

public interface ReadOnlyEvent extends ReadOnlyTask {

    TaskDate getStartDate();
    TaskTime getStartTime();

    /**
     * Formats the person as text, showing all contact details.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getName());
        if (getStartDate() != null) {
            builder.append("  Start Date:");
            builder.append(getStartDate());
        }
        if (getStartTime() != null) {
            builder.append("  Start Time:");
            builder.append(getStartTime());
        }
        if (getDate() != null) {
            builder.append("  Due Date:");
            builder.append(getDate());
        }
        if (getTime() != null) {
            builder.append("  Due Time:");
            builder.append(getTime());
        }
        if (getDescription() != null) {
            builder.append("  Description:");
            builder.append(getDescription());
        }
        if (getTag() != null) {
            builder.append("  List:");
            builder.append(getTag());
        }
        if (getVenue() != null) {
            builder.append("  Venue:");
            builder.append(getVenue());
        }
        assert getPriority() != null;
        builder.append("  Priority:");
        builder.append(getPriority());
        if (isFavorite()) {
            builder.append(" favorite");
        }
        if (isFinished()) {
            builder.append(" finished");
        }
        return builder.toString();
    }
}
```
###### /java/seedu/address/model/task/ReadOnlyTask.java
``` java
package seedu.address.model.task;

import seedu.address.model.tag.Tag;

/**
 * A read-only immutable interface for a Task in the TaskManager.
 * Implementations should guarantee: details are present and not null, field values are validated.
 */
public interface ReadOnlyTask {
    public enum FinishProperty {
        FINISHED, UNFINISHED
    }
    public enum EventProperty {
        EVENT, NON_EVENT
    }
    public enum RecurringProperty {
        RECURRING, NON_RECURRING
    }

    Name getName();
    TaskDate getDate();
    TaskTime getTime();
    Tag getTag();
    Description getDescription();
    Venue getVenue();
    Priority getPriority();
    boolean isFavorite();
    boolean isFinished();
    String getFavoriteText();
    String getFinishedText();
    boolean isEvent();
    boolean isRecurring();

    /**
     * Returns true if both have the same state. (interfaces cannot override equals)
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        if (this.isEvent() ^ other.isEvent()) {
            return false;
        } else if (!this.isEvent()) {
            return other == this // short circuit if same object
                    || (other != null // this is first to avoid NPE below
                    && checkEqual(this.getName(), other.getName())
                    && checkEqual(this.getDate(), other.getDate())
                    && checkEqual(this.getTime(), other.getTime())
                    && checkEqual(this.getTag(), other.getTag())
                    && ((other.getFinished() == null && this.getFinished() == null)
                            || (other.getFinished() != null && other.getFinished().equals(this.getFinished()))));
                    // state checks here onwards
        } else {
            return other == this // short circuit if same object
                    || (other != null // this is first to avoid NPE below
                    && checkEqual(this.getName(), other.getName())
                    && checkEqual(this.getDate(), other.getDate())
                    && checkEqual(this.getTime(), other.getTime())
                    && checkEqual(((ReadOnlyEvent) this).getStartDate(), ((ReadOnlyEvent) other).getStartDate())
                    && checkEqual(((ReadOnlyEvent) this).getStartTime(), ((ReadOnlyEvent) other).getStartTime())
                    && checkEqual(this.getTag(), other.getTag())
                    && ((other.getFinished() == null && this.getFinished() == null)
                            || (other.getFinished() != null && other.getFinished().equals(this.getFinished()))));
                    // state checks here onwards
        }
    }
```
###### /java/seedu/address/model/task/RecurringTask.java
``` java
package seedu.address.model.task;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.tag.Tag;

public class RecurringTask extends Task implements ReadOnlyRecurringTask {

    public static final String PERIOD_DAILY = "every day";
    public static final String PERIOD_WEEKLY = "every week";
    public static final String PERIOD_MONTHLY = "every month";

    public static final String PERIOD_DAY_REGEX = "(?i)((every)?(\\s)*(day))|(daily)";
    public static final String PERIOD_WEEK_REGEX = "(?i)((every)?(\\s)*(week))|(weekly)";
    public static final String PERIOD_MONTH_REGEX = "(?i)((every)?(\\s)*(month))|(monthly)";

    protected RecurringMode mode;

    /**
     * Every field must not be null.
     */
    public RecurringTask(Name name, TaskDate date, TaskTime time, Description description, Tag tag, Venue venue,
            Priority priority, boolean isFavorite, RecurringMode mode) {
        super(name, date, time, description, tag, venue, priority, isFavorite);
        this.isRecurring = RecurringProperty.RECURRING;
        this.mode = mode;
        checkDateForRecurring();
    }

    /**
     * Constructor with flag isFinished
     */
    public RecurringTask(Name name, TaskDate date, TaskTime time, Description description, Tag tag, Venue venue,
            Priority priority, boolean isFavorite, FinishProperty isFinished, RecurringMode mode) {
        this(name, date, time, description, tag, venue, priority, isFavorite, mode);
        this.isFinished = isFinished;
    }

    /**
     * Creates a copy of the given ReadOnlyTask.
     * @throws IllegalValueException
     */
    public RecurringTask(ReadOnlyTask source) throws IllegalValueException {
        super(new Name(source.getName().getValue()), new TaskDate(source.getDate().getValue()),
                new TaskTime(source.getTime().getValue()), new Description(source.getDescription().getValue()),
                new Tag(source.getTag().getValue()), new Venue(source.getVenue().getValue()),
                new Priority(source.getPriority().getValue()), source.isFavorite(), source.getFinished(),
                source.getEventProperty(), source.getRecurringProperty());
        assert this.isRecurring == RecurringProperty.RECURRING;
        this.mode = ((ReadOnlyRecurringTask) source).getMode();
        checkDateForRecurring();
    }

    @Override
    /**
     * Updates this task with the details of {@code replacement}.
     */
    public void resetData(ReadOnlyTask replacement) {
        assert replacement != null;

        super.resetData(replacement);
        assert this.isRecurring == RecurringProperty.RECURRING;
        this.mode = ((ReadOnlyRecurringTask) replacement).getMode();
        checkDateForRecurring();
    }

    /**
     * Set date to be day if date is not specified
     */
    private void checkDateForRecurring() {
        if (this.date.getValue().isEmpty()) {
            try {
                this.date = new TaskDate("today");
            } catch (IllegalValueException e) {
                assert false;
            }
        }
    }

    @Override
    public void finishOnce() {
        this.date.addPeriod(mode);
    }

    @Override
    public String getRecurringPeriod() {
        if (mode.equals(RecurringMode.DAY)) {
            return PERIOD_DAILY;
        } else if (mode.equals(RecurringMode.WEEK)) {
            return PERIOD_WEEKLY;
        } else if (mode.equals(RecurringMode.MONTH)) {
            return PERIOD_MONTHLY;
        } else {
            assert false;
            return null;
        }
    }

    public void setRecurringMode(RecurringMode mode) {
        this.mode = mode;
    }

    @Override
    public RecurringMode getMode() {
        return this.mode;
    }
}
```
###### /java/seedu/address/model/task/Task.java
``` java
package seedu.address.model.task;

import java.util.Objects;

import seedu.address.commons.util.CollectionUtil;
import seedu.address.model.tag.Tag;

/**
 * Represents a Task in the address book.
 * Guarantees: details are present and not null, field values are validated.
 */
public class Task implements ReadOnlyTask {

    protected Name name;
    protected TaskDate date;
    protected TaskTime time;
    protected Description description;
    protected Venue venue;
    protected Priority priority;
    protected boolean isFavorite;
    protected FinishProperty isFinished;
    protected Tag tag;
    protected EventProperty isEvent;
    protected RecurringProperty isRecurring;

    /**
     * Every field must not be null.
     */
    public Task(Name name, TaskDate date, TaskTime time, Description description, Tag tag,
            Venue venue, Priority priority, boolean isFavorite) {
        assert !CollectionUtil.isAnyNull(name);
        this.name = name;
        this.date = date;
        this.time = time;
        this.description = description;
        this.tag =  tag;
        this.venue = venue;
        this.priority = priority;
        this.isFavorite = isFavorite;
        this.isFinished = FinishProperty.UNFINISHED;
        this.isEvent = EventProperty.NON_EVENT;
        this.isRecurring = RecurringProperty.NON_RECURRING;
    }

    /**
     * Constructor with flag on isFavorite
     */
    public Task(Name name, TaskDate date, TaskTime time, Description description, Tag tag,
            Venue venue, Priority priority, boolean isFavorite, FinishProperty isFinished) {
        assert !CollectionUtil.isAnyNull(name);
        this.name = name;
        this.date = date;
        this.time = time;
        this.description = description;
        this.tag =  tag;
        this.venue = venue;
        this.priority = priority;
        this.isFavorite = isFavorite;
        this.isFinished = isFinished;
        this.isEvent = EventProperty.NON_EVENT;
        this.isRecurring = RecurringProperty.NON_RECURRING;
    }

    /**
     *  Constructor of task with flag on isFinshed, flag on isEvent, flag on isRecurring
     */
    public Task(Name name, TaskDate date, TaskTime time, Description description, Tag tag,
            Venue venue, Priority priority, boolean isFavorite, FinishProperty isFinished,
            EventProperty isEvent, RecurringProperty isRecurring) {
        assert !CollectionUtil.isAnyNull(name);
        this.name = name;
        this.date = date;
        this.time = time;
        this.description = description;
        this.tag =  tag;
        this.venue = venue;
        this.priority = priority;
        this.isFavorite = isFavorite;
        this.isFinished = isFinished;
        this.isEvent = isEvent;
        this.isRecurring = isRecurring;
    }

    /**
     * Creates a copy of the given ReadOnlyTask.
     */
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getDate(), source.getTime(), source.getDescription(),
                source.getTag(), source.getVenue(), source.getPriority(),
                source.isFavorite(), source.getFinished(),
                source.getEventProperty(), source.getRecurringProperty());
    }

    public void setName(Name name) {
        assert name != null;
        this.name = name;
    }

    @Override
    public Name getName() {
        return name;
    }

    public void setDate(TaskDate date) {
        this.date = date;
    }

    @Override
    public TaskDate getDate() {
        return date;
    }

    public void setTime(TaskTime time) {
        this.time = time;
    }

    @Override
    public TaskTime getTime() {
        return time;
    }

    public void setDescription(Description description) {
        this.description = description;
    }

    @Override
    public Description getDescription() {
        return description;
    }

    @Override
    public Tag getTag() {
        return tag;
    }

    public void setTag(Tag tag) {
        assert tag != null;
        this.tag = tag;
    }

    @Override
    public Venue getVenue() {
        return venue;
    }

    public void setVenue(Venue venue) {
        this.venue = venue;
    }

    @Override
    public Priority getPriority() {
        return priority;
    }

    public void setPriority(Priority priority) {
        this.priority = priority;
    }

    @Override
    public boolean isFavorite() {
        return isFavorite;
    }

    @Override
    public String getFavoriteText() {
        if (isFavorite) {
            return "Favorite \u2764";
        } else {
            return "";
        }
    }

    public void setFavorite(boolean isFavorite) {
        this.isFavorite = isFavorite;
    }

    @Override
    public boolean isFinished() {
        return isFinished == FinishProperty.FINISHED;
    }

    @Override
    public String getFinishedText() {
        if (isFinished()) {
            return "Finished";
        } else {
            return "Unfinished";
        }
    }

    public void setFinish(Boolean isFinished) {
        if (isFinished) {
            this.isFinished = FinishProperty.FINISHED;
        } else {
            this.isFinished = FinishProperty.UNFINISHED;
        }
    }


    /**
     * Updates this task with the details of {@code replacement}.
     */
    public void resetData(ReadOnlyTask replacement) {
        assert replacement != null;

        this.setName(replacement.getName());
        this.setDate(replacement.getDate());
        this.setTime(replacement.getTime());
        this.setDescription(replacement.getDescription());
        this.setTag(replacement.getTag());
        this.setVenue(replacement.getVenue());
        this.setPriority(replacement.getPriority());
        this.setFavorite(replacement.isFavorite());
        this.setFinish(replacement.isFinished());
        this.setIsEvent(replacement.getEventProperty());
        this.setIsRecurring(replacement.getRecurringProperty());
    }

    private void setIsEvent(EventProperty isEvent) {
        this.isEvent = isEvent;
    }

    private void setIsRecurring(RecurringProperty isRecurring) {
        this.isRecurring = isRecurring;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                        && this.isSameStateAs((ReadOnlyTask) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, date, time, description, tag, venue, priority, isFavorite, isFinished);
    }

    @Override
    public String toString() {
        return getAsText();
    }

    @Override
    public boolean isEvent() {
        return this.isEvent == EventProperty.EVENT;
    }

    @Override
    public boolean isRecurring() {
        return this.isRecurring == RecurringProperty.RECURRING;
    }

    @Override
    public FinishProperty getFinished() {
        return this.isFinished;
    }

    @Override
    public EventProperty getEventProperty() {
        return this.isEvent;
    }

    public void setRecurringProperty(RecurringProperty isRecurring) {
        this.isRecurring = isRecurring;
    }

    @Override
    public RecurringProperty getRecurringProperty() {
        return this.isRecurring;
    }
}
```
###### /java/seedu/address/model/task/TaskDate.java
``` java
package seedu.address.model.task;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.TimeZone;
import java.util.concurrent.TimeUnit;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.task.ReadOnlyRecurringTask.RecurringMode;

/**
 * Represents a Task's due date in task manager.
 * Guarantees: immutable; is valid as declared in {@link #isValidDate(String)}
 */
public class TaskDate implements TaskField, Comparable<TaskDate> {

    public static final String MESSAGE_DATE_CONSTRAINTS_1 =
            "task due date should be the form dd/mm, dd/mm/yyyy or Monday, tomorrow, etc.";

    public static final String DATE_VALIDATION_REGEX = ".*/.*";
    public static final String DAY_MONTH_SEPARATOR = "/";
    public static final String MONTH_VALIDATION_REGEX_1 = "([13578])|(0[13578])|(1[02])";
    public static final String MONTH_VALIDATION_REGEX_2 = "([469])|(0[469])|(11)";
    public static final String MONTH_VALIDATION_REGEX_3 = "(2)|(02)";
    public static final String MONTH_VALIDATION_REGEX = MONTH_VALIDATION_REGEX_1 + "|"
            + MONTH_VALIDATION_REGEX_2 + "|" + MONTH_VALIDATION_REGEX_3;
    public static final String DAY_VALIDATION_REGEX_1 = "([1-9])|(0[1-9])|(1\\d)|(2\\d)|(3[0-1])";
    public static final String DAY_VALIDATION_REGEX_2 = "([1-9])|(0[1-9])|(1\\d)|(2\\d)|(30)";
    public static final String DAY_VALIDATION_REGEX_3 = "([1-9])|(0[1-9])|(1\\d)|(2[0-8])";
    public static final String DAY_VALIDATION_REGEX_4 = "([1-9])|(0[1-9])|(1\\d)|(2[0-9])";
    public static final String YEAR_VALIDATION_REGEX = "(201[789])|(20[2-9]\\d)";

    public static final String DAY_VALIDATION_MONDAY = "(?i)(monday)|(mon)";
    public static final String DAY_VALIDATION_TUESDAY = "(?i)(tuesday)|(tue)";
    public static final String DAY_VALIDATION_WEDNESDAY = "(?i)(wednesday)|(wed)";
    public static final String DAY_VALIDATION_THURSDAY = "(?i)(thursday)|(thu)|(thur)|(thurs)";
    public static final String DAY_VALIDATION_FRIDAY = "(?i)(friday)|(fri)";
    public static final String DAY_VALIDATION_SATURDAY = "(?i)(saturday)|(sat)";
    public static final String DAY_VALIDATION_SUNDAY = "(?i)(sunday)|(sun)";

    public static final String DAY_VALIDATION_TODAY = "(?i)(today)";
    public static final String DAY_VALIDATION_TOMORROW = "(?i)(tomorrow)|(tmr)";

    public static final SimpleDateFormat FORMATTER = new SimpleDateFormat("dd/MM/yyyy");


    public static final int INF = 1000000000;
    public static final String INF_DATE = "1/1/2100";

    private final Calendar today;

    private String value;
    public Date date;
    public final boolean isPastDue;

    /**
     * Validates given date.
     *
     * @throws IllegalValueException if given date string is invalid.
     */
    public TaskDate(String date) throws IllegalValueException {
        assert date != null;
        today = Calendar.getInstance(TimeZone.getTimeZone("Asia/Singapore"));
        String trimmedDate = date.trim();
        if (!isValidDate(trimmedDate)) {
            throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS_1);
        }
        if (isDayInWeek(trimmedDate)) {
            int day = dayInWeek(trimmedDate);
            int incre = 0;
            Calendar current = Calendar.getInstance();
            while ((current.get(Calendar.DAY_OF_WEEK) != day)) {
                current.add(Calendar.DATE, 1);
                incre += 1;
                if (incre >= 7) {
                    assert false;
                }
            }
            this.date = current.getTime();
            this.isPastDue = false;
            this.value = getDateString(current);
        } else if (isTodayOrTomorrow(trimmedDate)) {
            int incre = todayOrTomorrow(trimmedDate);
            Calendar current = Calendar.getInstance(TimeZone.getTimeZone("Asia/Singapore"));
            while (incre > 0) {
                incre = incre - 1;
                current.add(Calendar.DATE, 1);
            }
            this.isPastDue = false;
            this.date = current.getTime();
            this.value = getDateString(current);
        } else {
            try {
                this.date = "".equals(trimmedDate) ?
                        FORMATTER.parse(INF_DATE) :
                        FORMATTER.parse(parseDate(trimmedDate));
            } catch (ParseException e) {
                assert false : "impossble";
                throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS_1);
            }
            this.isPastDue = TimeUnit.DAYS.convert(
                    this.date.getTime() - today.getTime().getTime(), TimeUnit.MILLISECONDS) < 0;
            this.value = trimmedDate.isEmpty() ? trimmedDate : parseDate(trimmedDate);
        }
    }

    /**
     * Format the date by giving calendar instance
     */
    public static String getDateString(Calendar current) {
        return current.get(Calendar.DAY_OF_MONTH) + DAY_MONTH_SEPARATOR
                + (current.get(Calendar.MONTH) + 1) + DAY_MONTH_SEPARATOR
                + current.get(Calendar.YEAR);
    }

    /**
     * Format the date by specifying year, month, and day
     */
    public static String getDateString(int year, int month, int day) {
        return day + DAY_MONTH_SEPARATOR
                + month + DAY_MONTH_SEPARATOR
                + year;
    }

    public static String getDateString(String year, String month, String day) {
        return day + DAY_MONTH_SEPARATOR
                + month + DAY_MONTH_SEPARATOR
                + year;
    }

    /**
     * Returns if a given string is a valid date.
     */
    public static boolean isValidDate(String test) {
        if (test.isEmpty()) {
            return true;
        }
        if (isDayInWeek(test)) {
            return true;
        }
        if (isTodayOrTomorrow(test)) {
            return true;
        }
        if (!test.matches(DATE_VALIDATION_REGEX)) {
            return false;
        }
        String[] dayMonthYear = test.split(DAY_MONTH_SEPARATOR);
        if (dayMonthYear.length > 3) {
            return false;
        }
        String day = dayMonthYear[0];
        String month = dayMonthYear[1];
        String year = dayMonthYear.length == 3 ? dayMonthYear[2] : null;
        return isValidMonth(month) && isValidDay(day, month, year) && isValidYear(year);
    }

    private static boolean isTodayOrTomorrow(String test) {
        return todayOrTomorrow(test) != -1;
    }

    private static int todayOrTomorrow(String test) {
        if (test.matches(DAY_VALIDATION_TODAY)) {
            return 0;
        } else if (test.matches(DAY_VALIDATION_TOMORROW)) {
            return 1;
        } else {
            return -1;
        }
    }

    private static boolean isDayInWeek(String test) {
        return (dayInWeek(test) <= 7) && (dayInWeek(test) >= 1);
    }

    private static int dayInWeek(String test) {
        if (test.matches(DAY_VALIDATION_SUNDAY)) {
            return 1;
        } else if (test.matches(DAY_VALIDATION_MONDAY)) {
            return 2;
        } else if (test.matches(DAY_VALIDATION_TUESDAY)) {
            return 3;
        } else if (test.matches(DAY_VALIDATION_WEDNESDAY)) {
            return 4;
        } else if (test.matches(DAY_VALIDATION_THURSDAY)) {
            return 5;
        } else if (test.matches(DAY_VALIDATION_FRIDAY)) {
            return 6;
        } else if (test.matches(DAY_VALIDATION_SATURDAY)) {
            return 7;
        } else {
            return -1;
        }
    }

    private static boolean isValidDay(String test, String month, String year) {
        if (month.matches(MONTH_VALIDATION_REGEX_1)) {
            return test.matches(DAY_VALIDATION_REGEX_1);
        } else if (month.matches(MONTH_VALIDATION_REGEX_2)) {
            return test.matches(DAY_VALIDATION_REGEX_2);
        } else if (month.matches(MONTH_VALIDATION_REGEX_3) && !isLeapYear(year)) {
            return test.matches(DAY_VALIDATION_REGEX_3);
        } else if (month.matches(MONTH_VALIDATION_REGEX_3) && isLeapYear(year)) {
            return test.matches(DAY_VALIDATION_REGEX_4);
        }
        assert false;
        return false;
    }

    private static boolean isValidMonth(String test) {
        return test.matches(MONTH_VALIDATION_REGEX);
    }

    private static boolean isValidYear(String test) {
        return test == null || test.matches(YEAR_VALIDATION_REGEX);
    }

    private static boolean isLeapYear(String test) {
        if (test == null) {
            return true;
        }
        int year = Integer.parseInt(test);
        return (year % 400 == 0) || ((year % 100 != 0) && (year % 4 == 0));
    }

    private String parseDate(String validDate) throws IllegalValueException {
        String[] dayMonthYear = validDate.split(DAY_MONTH_SEPARATOR);
        if (dayMonthYear.length == 3) {
            return validDate;
        }
        String day = dayMonthYear[0];
        String month = dayMonthYear[1];
        String year = Integer.toString(today.get(Calendar.YEAR));
        try {
            Calendar yesterday = Calendar.getInstance();
            yesterday.add(Calendar.DATE, -1);
            String returnDate = getDateString(year, month, day);
            Date date = FORMATTER.parse(returnDate);
            if (date.compareTo(yesterday.getTime()) < 0) {
                year = Integer.toString(today.get(Calendar.YEAR) + 1);
                returnDate = getDateString(year, month, day);
            }
            date = FORMATTER.parse(returnDate);
            if (!isValidDay(day, month, year)) {
                throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS_1);
            } else {
                return returnDate;
            }
        } catch (ParseException e) {
            assert false : "impossible";
        }
        assert false : "impossible";
        return validDate;
    }

    /**
     * Add a recurring period for date
     */
    public void addPeriod(RecurringMode mode) {
        Calendar todayCalendar = Calendar.getInstance();
        todayCalendar.setTime(this.date);
        if (mode.equals(RecurringMode.DAY)) {
            todayCalendar.add(Calendar.DATE, 1);
        } else if (mode.equals(RecurringMode.WEEK)) {
            todayCalendar.add(Calendar.DATE, 7);
        } else if (mode.equals(RecurringMode.MONTH)) {
            todayCalendar.add(Calendar.MONTH, 1);
        } else {
            assert false;
        }
        this.date = todayCalendar.getTime();
        this.value = getDateString(todayCalendar);
    }

    public String getValue() {
        return value;
    }

    /** return if the task has past due*/
    public boolean isPastDue() {
        return isPastDue;
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskDate // instanceof handles nulls
                && this.value.equals(((TaskDate) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

    @Override
    public int compareTo(TaskDate other) {
        if (this.value.isEmpty()) {
            if (other.value.isEmpty()) {
                return 0;
            } else {
                return INF;
            }
        } else {
            if (other.value.isEmpty()) {
                return -INF;
            } else {
                long diff = this.date.getTime() - other.date.getTime();
                return (int) TimeUnit.HOURS.convert(diff, TimeUnit.MILLISECONDS);
            }
        }
    }

```
###### /java/seedu/address/model/task/TaskTime.java
``` java
package seedu.address.model.task;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.TimeUnit;

import seedu.address.commons.exceptions.IllegalValueException;

/**
 * Represents a task's due time in the task manager.
 * Guarantees: immutable; is valid as declared in {@link #isValidTime(String)}
 */
public class TaskTime implements TaskField, Comparable<TaskTime> {

    public static final String MESSAGE_TIME_CONSTRAINTS =
            "Task time should be the form hh:mm";

    /*
     * The first character of the time must not be a whitespace,
     * otherwise " " (a blank string) becomes a valid input.
     */
    public static final String HOUR_VALIDATION_REGEX = "(\\d)|(0\\d)|(1\\d)|(2[0-3])";
    public static final String MINUTE_VALIDATION_REGEX = "[0-5][0-9]";
    public static final String TIME_VALIDATION_REGEX = ".*:.*";
    public static final String HOUR_MINUTE_SEPARATOR = ":";

    public static final SimpleDateFormat FORMATTER = new SimpleDateFormat("hh:mm");

    public static final int INF = 1000000000;

    private final String value;
    private final Date time;

    /**
     * Validates given time.
     *
     * @throws IllegalValueException if given time string is invalid.
     */
    public TaskTime(String time) throws IllegalValueException {
        assert time != null;
        if (!isValidTime(time)) {
            throw new IllegalValueException(MESSAGE_TIME_CONSTRAINTS);
        }
        try {
            this.time = time.isEmpty() ? null : FORMATTER.parse(time);
        } catch (ParseException e) {
            assert false : "impossible";
            throw new IllegalValueException(MESSAGE_TIME_CONSTRAINTS);
        }
        this.value = time;
    }

    /**
     * Returns true if a given string is a valid person email.
     */
    public static boolean isValidTime(String test) {
        if (test.isEmpty()) {
            return true;
        }
        if (!test.matches(TIME_VALIDATION_REGEX)) {
            return false;
        }
        String[] hourAndMinute = test.split(HOUR_MINUTE_SEPARATOR);
        String hour = hourAndMinute[0];
        String minute = hourAndMinute[1];
        return isValidHour(hour) && isValidMinute(minute);
    }

    private static boolean isValidHour(String test) {
        return test.matches(HOUR_VALIDATION_REGEX);
    }

    private static boolean isValidMinute(String test) {
        return test.matches(MINUTE_VALIDATION_REGEX);
    }

    public String getValue() {
        return this.value;
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskTime // instanceof handles nulls
                && this.value.equals(((TaskTime) other).value)); // state check
    }

    @Override
    public int compareTo(TaskTime other) {
        if (this.time == null) {
            if (other.time == null) {
                return 0;
            } else {
                return INF;
            }
        } else {
            if (other.time == null) {
                return -INF;
            } else {
                long diff = this.time.getTime() - other.time.getTime();
                return (int) TimeUnit.HOURS.convert(diff, TimeUnit.MILLISECONDS);
            }
        }
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

```
###### /java/seedu/address/model/task/UniqueTaskList.java
``` java
    /**
     * Sort the UniqueTaskList. In the priority of
     * due date > priority > due time > name > tag
     */
    public void sort() {
        Collections.sort(internalList, (Task t1, Task t2) -> t1.getTag().compareTo(t2.getTag()));
        Collections.sort(internalList, (Task t1, Task t2) -> t1.getName().compareTo(t2.getName()));
        Collections.sort(internalList, (Task t1, Task t2) -> t1.getTime().compareTo(t2.getTime()));
        Collections.sort(internalList, (Task t1, Task t2) -> -t1.getPriority().compareTo(t2.getPriority()));
        Collections.sort(internalList, (Task t1, Task t2) -> t1.getDate().compareTo(t2.getDate()));
    }
```
###### /java/seedu/address/model/task/Venue.java
``` java
package seedu.address.model.task;

import seedu.address.commons.exceptions.IllegalValueException;

/**
 * Represents a Task's venue in task manager.
 * Guarantees: immutable; is valid as declared in {@link #isValidVenue(String)}
 */
public class Venue implements TaskField, Comparable<Venue> {

    public static final String MESSAGE_VENUE_CONSTRAINTS =
            "task venue can only contains alphanumerics and #, -, '.";

    // cannot begin with space; can only contains
    public static final String VENUE_VALIDATION_REGEX = "^((\\w)|([-#]))((\\w)|([-#'])|(\\s))*";

    private final String value;

    /**
     * Validity given venue.
     *
     * @throws IllegalValueException if given venue string is invalid.
     */
    public Venue(String venue) throws IllegalValueException {
        assert venue != null;
        String trimmedVenue = venue.trim();
        if (!isValidVenue(trimmedVenue)) {
            throw new IllegalValueException(MESSAGE_VENUE_CONSTRAINTS);
        }
        this.value = trimmedVenue;
    }

    /**
     * Returns if a given string is a valid venue.
     */
    public static boolean isValidVenue(String test) {
        if (test.isEmpty()) {
            return true;
        }
        return test.matches(VENUE_VALIDATION_REGEX);
    }

    public String getValue() {
        return this.value;
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Venue // instanceof handles nulls
                && this.value.equals(((Venue) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

    @Override
    public int compareTo(Venue other) {
        return this.value.compareTo(other.value);
    }

```
###### /java/seedu/address/model/util/SampleDataUtil.java
``` java
    public static Task[] getSampleTasks() {
        try {
            return new Task[] {
                new Task(new Name("pay tuition fee"), new TaskDate("25/3/2017"), new TaskTime(""),
                        new Description("don't forget!!!!"), new Tag(""),
                        new Venue(""), new Priority("3"), false),
                new Task(new Name("cs 2103"), new TaskDate("today"), new TaskTime("9:00"),
                        new Description("demo"), new Tag("study"),
                        new Venue("COM1"), new Priority("3"), true),
                new Event(new Name("cs final"), new TaskDate("4/5"), new TaskTime("15:00"),
                        new TaskTime("17:00"), new Description("cannot bring helpsheet"), new Tag("study"),
                        new Venue("MPSH"), new Priority("3"), true),
                new Task(new Name("clean up room"), new TaskDate("4/5"), new TaskTime("9:00"),
                        new Description("get ready to go home"), new Tag("personal"),
                        new Venue(""), new Priority("1"), false),
                new Task(new Name("Gym"), new TaskDate("12/3"), new TaskTime("11:00"),
                        new Description("50 mins workout"), new Tag("personal"),
                        new Venue("MPSH"), new Priority("2"), true),
                new Task(new Name("study hard"), new TaskDate(""), new TaskTime(""),
                        new Description("goal in my life"), new Tag("study"),
                        new Venue(""), new Priority("3"), true)
            };
        } catch (IllegalValueException e) {
            throw new AssertionError("sample data cannot be invalid", e);
        }
    }

```
